; --------------------------------------------------------------------------------------------------------------------- ;
; Lode Runner - it.prg
; --------------------------------------------------------------------------------------------------------------------- ;
; Memory Map
; --------------------------------------------------------------------------------------------------------------------- ;
; $0000 - $00ff:  Zero Page
; $0400 - $07f7:  Screen Multi Color
; $07f8 - $07ff:  Sprite Pointers
; $0800 - $09c3:  Buffer Expanded level data - in game modified with loderunner/enemies/holes
; $0a00 - $0bc3:  Buffer Expanded level data - original without loderunner/enemies/holes
; $0c00 - $0cff:  Buffer Sprite Data 01
; $0d00 - $0dff:  Buffer Sprite Data 02
; $0e00 - $0ec7:  Table HiRes rows start address LO
; $0f00 - $0fc7:  Table HiRes rows start address HI
; $1000 - $10ff:  Buffer Level Data Save/Load
; $1100 - $11ff:  Buffer High Score Save/Load
; $1200 - $12ff:  Game Work Tables
; $1300 - $133b:  Game Variables
; $1400 - $1fff:  Data Start Graphic
; $2000 - $3fff:  Screen Multicolor HiRes Display
; $4000 - $5fff:  Screen Multicolor HiRes Prepare
; --------------------------------------------------------------------------------------------------------------------- ;
; $6000 - $b7ff:  Game ($5800 bytes)
; $6000 - $93ae:  Game Code
; $93af - $b4ff:  
; $9500 - $993d:  Game Data Jingles
; $993e - $b7ff:  
; $a000 - $b0ff:  Game Image Data
; $b100 - $b1c8:  Game Data Demo Move Level 01
; $b1d0 - $b2c3:  Game Data Demo Move Level 02
; $b2c4 - $b369:  Game Data Demo Move Level 03
; $b36a - $b4ff:  
; $b500 - $b5ff:  Game Data Demo Level 01
; $b600 - $b6ff:  Game Data Demo Level 02
; $b700 - $b7ff:  Game Data Demo Level 03
; --------------------------------------------------------------------------------------------------------------------- ;
; $c000 - $c0ff:  Buffer Tunes Play Time
; $c100 - $c1ff:  Buffer Tunes Data Ptr Voice 2
; $c200 - $c2ff:  Buffer Tunes Data Ptr Voice 3
; $c300 - $c3ff:  Buffer Tunes Sustain/Release/Volume (not used)
; 
; $c800 - $c8ff:  Buffer High Score Work Old
; $c900 - $c9ff:  Buffer High Score Work New
; --------------------------------------------------------------------------------------------------------------------- ;
                            * = $6000
; --------------------------------------------------------------------------------------------------------------------- ;
; compiler settings
; --------------------------------------------------------------------------------------------------------------------- ;
                            .cpu "6502"                     ; standard 65xx processor
                            
Mem                         .include "../../inc/c64.MEM.asm" ; C64 Memory layout (includes found via -I cmd line option)
; --------------------------------------------------------------------------------------------------------------------- ;
Var                         .include "../inc/LR_Var.asm"    ; Game Variables
ZPG                         .include "../inc/LR_Zpg.asm"    ; Game Zero Page Equates
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; Start                     Does    : game start entry point
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
Start                      .block                           ; 
                            lda #LR_Volume_Off              ; get initial value
                            sta LR_Volume                   ; set volume off
                            
                            jsr StartInitMachine            ; set up the machine
                            jsr CopyProtectionHandler       ; check copy protection
; --------------------------------------------------------------------------------------------------------------------- ;
; read in score block and validate LR disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskRead                ; get flag read score from disk
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColdStart                 Does    : game restart in case of errors
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColdStart                  .block                           ; 
                            lda #$ff                        ; get initial value
                            sta LR_Volume                   ; ini volume
                            sta LR_LodeRuFallsDown          ; ini $00=fall $20=no fall $ff=init
                            sta LR_TuneDeath                ; <obsolete> here - overwritten in next ini block
                            sta LR_LodeRuShootMode          ; ini LR_LodeRuShootMode_Front
                            sta LR_StartCycle               ; ini LR_StartCycle_On
                            
                            lda #$00                        ; get init value
                            sta LR_TuneFreeBufferPosOff     ; ini offset to next free tune buffer byte
                            sta LR_TuneToPlayOff            ; ini offset to next tune to play
                            sta LR_LodeRuShoot              ; ini LR_LodeRuShoot_No
                            sta LR_TuneDeath                ; ini LR_TuneDeath_None
                            sta LR_KeyNew                   ; ini new key input
                            sta LR_KeyOld                   ; ini pressed key store
                            sta LR_SpriteShow               ; ini LR_SpriteShow_On
                            
                            lda #>LR_LevelDataBuf           ; get packed level data page from disk - Target: $1000-$10ff
                            sta DiskCmdExecRead.smSetDiskReadBufPtr_Hi   ; ini ReadDiskData command
                            sta DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; ini WriteDiskData command
                            sta LR_GoldJingleRndSeed        ; ini RND beam pos seed
                            
                            lda LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            sta LR_KeyOld                   ; ini pressed key store
                            
                            lda #LSTX_NONE                  ; get ini value - no key pressed
                            sta LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            
                            lda #LR_GameSpeed_Normal        ; get wait cout of 5 interupts before next move (normal speed)
                            sta LR_GameSpeed                ; ini normal speed 
                            
                            lda #LR_ControllerType_Joystick ; get controller typ joystick
                            sta LR_ControllerType           ; ini controller typ joystick
                            
                            lda #LR_GameMode_Start          ; get flag show start grafic
                            sta LR_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            
                            jmp StartGraficOut              ; expand the compressed start grafic
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStart                 Does    : start game preparations
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStart                  .block                           ; 
                            lda #$00                        ; get ini value
                            sta LR_Score_Lo                 ; ini scores
                            sta LR_Score_MidLo              ; 
                            sta LR_Score_MidHi              ; 
                            sta LR_Score_Hi                 ; 
                            sta LR_GameSpeedCtrl            ; ini game speed
                            sta LR_CirclePhase              ; ini LR_CirclePhase_Open - no close phase at 1st game start 
                            sta LR_EnemyBirthCol            ; ini LR_EnemyBirthCol_Min
                            sta LRZ_DemoMoveDuration        ; ini demo move duration
                            sta LRZ_DemoMoveDataPtr_Lo      ; ini demo move data pointer LO
                            
                            lda #>TabDemoMoves              ; ini demo move data pointer LO
                            sta LRZ_DemoMoveDataPtr_Hi      ; ini DemoMoveData pointer
                            sta LR_LevelReload              ; ini reload flag - force level reload if <> LR_LevelNumDisk
                            
                            lda #LR_NumLivesInit            ; get initial value
                            sta LR_NumLives                 ; ini number of lives
                            
                            lda #>LR_ScreenGfxDisplay       ; get gfx display screen
                            sta LRZ_TargetGfxOutput         ; ini target output indicator $20=$2000 $40=$4000
                            
                            jsr JingleGotAllGoldInit        ; init the jingle control data
                            jsr ScreenClearBoth             ; clear the display and prepare screen hires screens
                            
                            lda #HR_CYAN_RED                ; get hires color
                            jsr ColorLevel                  ; fill game level screen with the selected colors
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelStart                Does    : start a level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelStart                 .block                           ; 
                            ldx #LR_LevelLoad_Yes           ; get flag force new copy from disk and init
                            jsr GameLevelDataExpand         ; expand compressed level disk data
                            
                            sta LR_TuneToPlayOff            ; ini offset tune to play
                            sta LR_TuneFreeBufferPosOff     ; ini offset next free tune buffer byte
                            
                            lda #LR_CirclePhase_Both        ; get flag open/close phase after 1st game start
                            sta LR_CirclePhase              ; set flag both phases
                            
                            ldy LR_EnemyCount               ; get number of enemies ($00-$05)
                            lda TabEnemySpriteNum,y         ; get sprite enable value
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            lda #LR_JoystickMove_None       ; get initial value
                            sta LR_JoystickMoveDirY         ; ini joystick dir Y
                            sta LR_JoystickMoveDirX         ; ini joystick dir X
                            
                            lda LR_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            lsr a                           ; shift out mode flag
                            beq MainLoopInit                ; check: demo - yes: bypass flicker
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for player key - flicker loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
FlickerNextLodeRuSprt       lda SPENA                       ; VIC($D015) Sprite Enable Register
                            and #~SPENA_M0E                 ; switch off loderunner sprite
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            ldy #$90                        ; get waittime LO
                            ldx #$00                        ; get waittime HI
; --------------------------------------------------------------------------------------------------------------------- ;
; black loderunner phase
; --------------------------------------------------------------------------------------------------------------------- ;
WaitLodeRuBlack             dex                             ; dec waittime LO
                            jsr PlayerCheckInput            ; look for player input
                            bcs WaitPlayerEnd               ; check: did player press something - yes
                            
                            bne WaitLodeRuBlack             ; check: min waittime LO - no: continue
                            dey                             ; dec waittime HI
                            bne WaitLodeRuBlack             ; check: min waittime HI - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; switch loderunner sprite on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SPENA                       ; VIC($D015) Sprite Enable Register
                            ora #SPENA_M0E                  ; switch on loderunner sprite
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            ldy #$90                        ; get waittime LO
                            ldx #$00                        ; get waittime HI
; --------------------------------------------------------------------------------------------------------------------- ;
; white loderunner phase
; --------------------------------------------------------------------------------------------------------------------- ;
WaitLodeRuWhite             dex                             ; dec waittime LO
                            jsr PlayerCheckInput            ; look for player input
                            bcs WaitPlayerEnd               ; check: did player press something - yes
                            
                            bne WaitLodeRuWhite             ; check: min waittime LO - no: continue
                            dey                             ; dec waittime HI
                            bne WaitLodeRuWhite             ; check: min waittime HI - no: continue
                            
                            jmp FlickerNextLodeRuSprt       ; next round - wait and flicker loderunner sprite
; --------------------------------------------------------------------------------------------------------------------- ;
; end of wait - switch on a possibly switched off loderunner sprite
; --------------------------------------------------------------------------------------------------------------------- ;
WaitPlayerEnd               lda SPENA                       ; VIC($D015) Sprite Enable Register
                            ora #SPENA_M0E                  ; switch on loderunner sprite
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MainLoopInit              Does    : game main loop preparations
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoopInit               .block                           ; 
                            ldx #LR_LodeRuShoot_No          ; get initial value
                            stx LR_LodeRuShoot              ; ini loderunner does not shoot - $00=no $01=right $ff=left
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate offset into enemy move dispatch table
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_GameSpeedCtrl            ; get game speed control value ($00-$0a)
                            clc                             ; 
                            adc LR_EnemyCount               ; add number of enemies ($00-$05)
                            tay                             ; set enemy cycle tab offset
; --------------------------------------------------------------------------------------------------------------------- ;
; fill enemy move control table - used in EnemyMoveHandler
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabEnemyMoveCyclesOff,y     ; get offsets enemy move cycles tab
                            lda TabEnemyMoveCycle_01,x      ; get enemy move cycles tab value 1
                            sta LRZ_EnemyMoveCycle_01       ; set tab value 1 
                            
                            lda TabEnemyMoveCycle_02,x      ; get enemy move cycles tab value 2
                            sta LRZ_EnemyMoveCycle_02       ; set tab value 2
                            
                            lda TabEnemyMoveCycle_03,x      ; get enemy move cycles tab value 3
                            sta LRZ_EnemyMoveCycle_03       ; set tab calue 3
                            
                            ldy LR_GameSpeedCtrl            ; get lap counter for speed up ($00-$0a)
                            lda TabEnemyInHoleTime,y        ; get time in hole tab
                            sta LR_EnemyInHoleTime          ; set enemy in hole time
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; MainLoop                  Does    : game main loop
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop                   .block                           ; 
                            jsr LodeRuMoveHandler           ; conrol loderunner moves
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner has survived his last move
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LodeRuState              ; get loderunner heartbeat
                            beq LodeRuDeath                 ; check: loderunner had an accident - yes
                            
                            lda LR_GoldToCollect            ; get gold to collect count
                            bne MainLoop_CheckLrRow         ; check: got all - no: some gold still left over
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner still alive and all gold collected
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr JingleGotAllGoldCopy        ; prepare the all gold collected jingle
                            jsr LevelExitLadderShow         ; show possible exit ladders
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner must be on top of the screen 
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_CheckLrRow         lda LRZ_LodeRuRow               ; get actual row loderunner
                            bne MainLoop_CloseHoles         ; check: lodrunner on top row - no: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner must be on mid of image 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_LodeRuOnImgPosY         ; get loderunner pos on image left/right
                            cmp #LRZ_LodeRuOnImgPosY_Mid    ; test center of screen image
                            bne MainLoop_CloseHoles         ; check: center of screen image - no: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; all gold must be collected - level completed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_GoldToCollect            ; get number of gold to collect for this level
                            beq LevelComplete               ; check: got all gold - yes: level finished successfully
                            cmp #$ff                        ; test -1
                            beq LevelComplete               ; check: got all gold plus one - yes: level finished successfully
; --------------------------------------------------------------------------------------------------------------------- ;
; continue play
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_CloseHoles         jsr GameCloseHoles              ; close open holes and eventually kill trapped loderunner and enemies
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner survived the close hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LodeRuState              ; get loderunner heartbeat
                            beq LodeRuDeath                 ; check: loderunner was trapped in a hole - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; move next enemy - one by one
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveHandler            ; control all enemy moves
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LodeRuState              ; get loderunner heartbeat 
                            beq LodeRuDeath                 ; check: loderunner was cought by an enemy - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; wait a bit
; --------------------------------------------------------------------------------------------------------------------- ;
MainLoop_Delay              lda LR_CountIRQs                ; get wait counter (inc'd every IRQ)
                            cmp LR_GameSpeed                ; test with game speed
                            bcc MainLoop_Delay              ; check: lower - yes: wait
                                                              
                            lda #LR_CountIRQs_Init          ; get initial value
                            sta LR_CountIRQs                ; ini wait counter (inc'd every IRQ)
                                                              
                            jmp MainLoop                    ; continue the endless loop
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelComplete             Does    : prepare for next level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelComplete              .block                           ; 
                            inc LR_LevelNumGame             ; inc game level number 001-150
                            inc LR_LevelNumDisk             ; inc disk level number 000-149
; --------------------------------------------------------------------------------------------------------------------- ;
; finish the actual game tune
; --------------------------------------------------------------------------------------------------------------------- ;
WaitTuneFinished            lda LR_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            cmp LR_TuneToPlayOff            ; test still playing
                            bne WaitTuneFinished            ; check: tune still playing - yes: continue wait
                            
                            jsr JingleGotAllGoldNext        ; set the next level completed jingle
; --------------------------------------------------------------------------------------------------------------------- ;
; increase loderunner number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LR_NumLives                 ; 
                            bne ScoreTuneIni                ; check: maximum - no: bypass adaptation
                            
                            dec LR_NumLives                 ; ensure a max of $ff (255)
; --------------------------------------------------------------------------------------------------------------------- ;
; init level end scoring tune - each dec of LRZ_SfxScoreSub scores 100 points
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreTuneIni                lda #LRZ_SfxScoreSub_Start      ; get init score tune subtraction value
                            sta LRZ_SfxScoreSub             ; set substraction value
                            
                            sei                             ; disallow interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; increase score whilst the scoring tune gets higher and higher
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreTuneNext               lda #LRZ_SfxScoreSub_Base       ; get base tune value 
                            sec                             ; 
                            sbc LRZ_SfxScoreSub             ; 
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            ldy #$2c                        ; get wait time LO
ScoreWaitTuneGetNextHi      ldx #$00                        ; get wait time HI
ScoreWaitTuneDecNextLo      dex                             ; dec wait time LO
                            bne ScoreWaitTuneDecNextLo      ; check: min - no: continue
                            dey                             ; dec wait time HI
                            bne ScoreWaitTuneGetNextHi      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; switch tune off
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; score next 100
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; $00 - score add value LO - each time tick scores 100 points
                            iny                             ; $01 - score add value HI
                            jsr StatusOutScore              ; score and update status row
; --------------------------------------------------------------------------------------------------------------------- ;
; dec until 1500 points are scored
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_SfxScoreSub             ; sub value - tune gets higher and higher
                            bpl ScoreTuneNext               ; check: underflow - no: continue
                            
                            cli                             ; reallow interrupts
GoLevelStart                jmp LevelStart                  ; start next level
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuDeath               Does    : discount loderunner lives
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuDeath                .block                           ; 
                            dec LR_NumLives                 ; subtract from lives
                            
                            lda LR_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            lsr a                           ; shift out mode flag
                            bne LodeRuDeathTune             ; check: demo - no: play death tune
                            
                            jmp DemoVolumeHandler           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init funeral march
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuDeathTune             lda #LR_TuneDeath_Ini           ; get initial value
                            sta LR_TuneDeath                ; ini death tune
; --------------------------------------------------------------------------------------------------------------------- ;
; complete running jingles
; --------------------------------------------------------------------------------------------------------------------- ;
WaitForGameTunesFinish      lda LR_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            cmp LR_TuneToPlayOff            ; test with tune to play offset
                            bne WaitForGameTunesFinish      ; check: finished - no: wait for all in game tunes to be finished
; --------------------------------------------------------------------------------------------------------------------- ;
; reset values
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_LodeRuShoot_No          ; get shoot off
                            sta LR_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            lda #LR_LodeRuFallsDown_No      ; get flag no fall
                            sta LR_LodeRuFallsDown          ; set $00=fall $20=no fall $ff=init
                            
                            jsr StatusOutLives              ; write out remaining number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
; complete funeral march
; --------------------------------------------------------------------------------------------------------------------- ;
WaitForDeathTuneEnd         lda LR_TuneDeath                ; get death tune value
                            bne WaitForDeathTuneEnd         ; check: min - no: continue waiting
; --------------------------------------------------------------------------------------------------------------------- ;
; check number of lives
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_NumLives                 ; get number of lives
                            bne LevelComplete.GoLevelStart  ; check: all used up - no: continue game with one live less
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOver                  Does    : spin game over sign and wait for restart or demo
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOver                   .block                           ; 
                            jsr ScoreEntryHandler           ; check if score reached is worth an entry on the leaderboard
                            jsr GameOverSpinSign            ; spin game over billboard
; --------------------------------------------------------------------------------------------------------------------- ;
; init wait for demo or player input
; --------------------------------------------------------------------------------------------------------------------- ;
DemoWaitInit                ldx #$ff                        ; get wait time LO
                            ldy #$ff                        ; get wait time MID
                            
                            bcs DemoWaitIniCounter_Hi       ; check: flag demo - yes: bypass key reset
; --------------------------------------------------------------------------------------------------------------------- ;
; reset player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_KeyNew_None             ; get initial value
                            sta LR_KeyNew                   ; ini new key input
; --------------------------------------------------------------------------------------------------------------------- ;
; init wait counter HI
; --------------------------------------------------------------------------------------------------------------------- ;
DemoWaitIniCounter_Hi       lda #$03                        ; get wait time HI
                            sta LRZ_WaitForDemoCounter      ; set wait time HI
                            
DemoWaitPlayerInput         lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
; --------------------------------------------------------------------------------------------------------------------- ;
; check quick start joystick
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq GameStartInit               ; check: fire button pressed - yes
                            
                            lda LR_KeyNew                   ; get key pressed
; --------------------------------------------------------------------------------------------------------------------- ;
; check start the editor
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$8e                        ; test "E" to start editor
                            bne CheckShowLeaderboard        ; check: EQ - no: check <ENTER> to show leaderboard
                            
                            jmp BED_Start                   ; start the Loderunner Board Editor
; --------------------------------------------------------------------------------------------------------------------- ;
; check show leaderboard
; --------------------------------------------------------------------------------------------------------------------- ;
CheckShowLeaderboard        cmp #$01                        ; test <ENTER>
                            beq DemoHighScoreHandler.GoScoreShowLeaderboard ; check: EQ - yes: show leaderboard
                            
                            lda LR_KeyNew                   ; get player key
                            bne GameStartInit               ; check: player key - yes: start game
; --------------------------------------------------------------------------------------------------------------------- ;
; continue waiting
; --------------------------------------------------------------------------------------------------------------------- ;
                            dex                             ; count down wait time LO
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
                            dey                             ; count down wait time MID
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
                            dec LRZ_WaitForDemoCounter      ; count down wait time HI
                            bne DemoWaitPlayerInput         ; check: min - no: continue wait
; --------------------------------------------------------------------------------------------------------------------- ;
; wait time is over without any player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_GameMode                 ; game mode - get $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            bne DemoHighScoreHandler        ; check: start screen - no: show high scores
; --------------------------------------------------------------------------------------------------------------------- ;
; init start demo
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$01                        ; get initial value
                            stx LR_GameMode                 ; ini $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            stx LR_LevelNumGame             ; ini game level number 001-150
                            stx LRZ_DemoNoFunction          ; ini flag - used but has no function
                            stx LR_Cheated                  ; ini LR_Cheated_No
                            
                            ldx LR_Volume                   ; get volume
                            stx DemoVolumeHandler.smSetVolume ; set game volume
                            
                            lda #$00                        ; get demo volume off
                            sta LR_Volume                   ; set demo volume off
                            sta LR_LevelNumDisk             ; set disk level number 000-149 - 1st demo level
                            
                            jmp GameStart                   ; start game preparations
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoVolumeHandler         Does    : control game volume
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoVolumeHandler          .block                           ; 
smSetVolume                 = * + $01                       ; 
                            lda #LR_Volume_Off              ; get modified game volume
                            sta LR_Volume                   ; set game volume
                            
                            jmp GameOver.DemoWaitInit       ; init wait for demo
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoHighScoreHandler      Does    : show the leaderboard of ten entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoHighScoreHandler       .block                           ; 
                            cmp #LR_GameMode_Demo           ; test demo mode
                            bne DemoShowStartGraphic        ; check: was demo - no: show start graphic screen
; --------------------------------------------------------------------------------------------------------------------- ;
; show leaderboard after the demo
; --------------------------------------------------------------------------------------------------------------------- ;
GoScoreShowLeaderboard      jsr ScoreShowLeaderboard        ; show leaderboard
                            
                            lda #LR_GameMode_Play           ; get play mode
                            sta LR_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            
                            clc                             ; force new key reset
                            jmp GameOver.DemoWaitInit       ; init wait for demo
; --------------------------------------------------------------------------------------------------------------------- ;
DemoShowStartGraphic        lda #$00                        ; get initial value
                            sta LR_LevelNumDisk             ; set disk level number 000-149
                            sta LR_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            
                            jmp StartGraficOut              ; expand the compressed start grafic
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStartInit             Does    : initialize game (re)start values
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStartInit              .block                           ; 
                            ldx #LR_LevelNumDisk_Min        ; get initial value
                            stx LR_LevelNumDisk             ; ini disk level number 000-149
                            
                            inx                             ; 
                            stx LR_LevelNumGame             ; set game level number 001-150
                            stx LR_Cheated                  ; set LR_Cheated_No
                            
                            lda #LR_GameMode_Play           ; get play mode
                            sta LR_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            
                            lda #LR_Volume_Max              ; get switch on volume again
                            sta LR_Volume                   ; set volume
                            
                            jmp GameStart                   ; start game preparations
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesOff       = * ; 
                            .byte TabEnemyMoveCyclesBlock_00 - TabEnemyMoveCycles ; 00 - $00
                            .byte TabEnemyMoveCyclesBlock_01 - TabEnemyMoveCycles ; 01 - $03
                            .byte TabEnemyMoveCyclesBlock_02 - TabEnemyMoveCycles ; 02 - $06
                            .byte TabEnemyMoveCyclesBlock_03 - TabEnemyMoveCycles ; 03 - $09
                            .byte TabEnemyMoveCyclesBlock_04 - TabEnemyMoveCycles ; 04 - $0c
                            .byte TabEnemyMoveCyclesBlock_05 - TabEnemyMoveCycles ; 05 - $0f
                            .byte TabEnemyMoveCyclesBlock_06 - TabEnemyMoveCycles ; 06 - $12
                            .byte TabEnemyMoveCyclesBlock_07 - TabEnemyMoveCycles ; 07 - $15
                            .byte TabEnemyMoveCyclesBlock_08 - TabEnemyMoveCycles ; 08 - $18
                            .byte TabEnemyMoveCyclesBlock_09 - TabEnemyMoveCycles ; 09 - $1b
                            .byte TabEnemyMoveCyclesBlock_0a - TabEnemyMoveCycles ; 0a - $1e
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyInHoleTime          = *       ; 
                            .byte $26 ; $00
                            .byte $26 ; $01
                            .byte $2e ; $02
                            .byte $44 ; $03
                            .byte $47 ; $04
                            .byte $49 ; $05
                            .byte $4a ; $06
                            .byte $4b ; $07
                            .byte $4c ; $08
                            .byte $4d ; $09
                            .byte $4e ; $0a
                            .byte $4f ; $0b
                            .byte $50 ; $0c
                            .byte $51 ; $0d
                            .byte $52 ; $0e
                            .byte $53 ; $0f
                            .byte $54 ; $10
                            .byte $55 ; $11
                            .byte $56 ; $12
                            .byte $57 ; $13
                            .byte $58 ; $14
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartGraficOut            Does    : color the start grafic hires screen
;                                   : expand the compressed start grafic
;                           Expects : 
;                           Returns : 
;                           Remark  : each data block has 2 bytes - 1st=length / 2nd=data
; --------------------------------------------------------------------------------------------------------------------- ;
StartGraficOut             .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #HR_BLACK_BLACK             ; get initial value - clear screen
                            jsr ColorLevel                  ; fill game level screen with the selected colors
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare Multicolor BitMap Mode (ECM=0 BMM=1 MCM=1) - screen size 40*25
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
                            ora #SCROLY_BMM_ON              ; switch on Bitmap Mode (BMM)
                            sta SCROLY                      ; VIC($D011) VIC Control Register 1 (Vert Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; set charset location
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda VMCSB                       ; VIC($D018) VIC Chip Memory Control
                            and #~(VMCSB_CB_MASK | %00000001) ; clear char set location part
                            ora #VMCSB_CB_2000              ; chr generator to video base + $2000-$3fff
                            sta VMCSB                       ; VIC($D018) VIC Chip Memory Control
; --------------------------------------------------------------------------------------------------------------------- ;
; set start grafic hires colors
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get amount
ColorRegions_01             lda #HR_BLUE_BLACK              ; get color
                            sta LR_ScreenStartGfx_BroderB1,y; set color for "Broderbund Software"
                            sta LR_ScreenStartGfx_BroderB2,y; 
                            
                            lda #HR_WHITE_BLACK             ; get color
                            sta LR_ScreenStartGfx_LR,y      ; set color for "LODERUNNER"
                            
                            dey                             ; dec amount
                            bne ColorRegions_01             ; check: min - no: continue
                            
                            ldy #$50                        ; get amount
ColorRegions_02             lda #HR_RED_BLACK               ; get color
                            sta LR_ScreenStartGfx_Presents,y; set color for "Presents"
                            sta LR_ScreenStartGfx_By,y      ; set color for "By"
                            
                            lda #HR_WHITE_BLACK             ; get color
                            sta LR_ScreenStartGfx_Bigham,y  ; set color for "DOUG SMITH AND DANE BIGHAM"
                            
                            lda #HR_BLUE_BLACK              ; get color
                            sta LR_ScreenStartGfx_CoRi,y    ; set color for "(c) Copyright 1983"
                            
                            dey                             ; dec amount
                            bpl ColorRegions_02             ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set Multicolor BitMap Mode (ECM=0 BMM=1 MCM=1) - screen size 40*25
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
                            and #SCROLX_MCM_OFF             ; Multi Color Mode (MCM) off
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
; --------------------------------------------------------------------------------------------------------------------- ;
; init start grafic output pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<LR_StartGfxData           ; get start gfx in memory LO
                            sta LRZ_ScreenGfxPtr_Lo         ; set start gfx in ptr LO
                            lda #>LR_StartGfxData           ; get start gfx in memory HI
                            sta LRZ_ScreenGfxPtr_Hi         ; set start gfx in ptr HI
                            
                            lda #<LR_ScreenGfxDisplay - $01 ; get display screen address LO
                            sta LRZ_StartGfxDisplay_Lo      ; set start gfx output ptr LO
                            
                            lda #>LR_ScreenGfxDisplay - $01 ; get display screen address HI
                            sta LRZ_StartGfxDisplay_Hi      ; set start gfx output ptr HI
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextGfxDataInPair        ldy #$00                        ; get offset to gfx data byte count
                            lda (LRZ_ScreenGfxPtr),y        ; get gfx data byte count
                            sta LRZ_WorkStartGfxDataCount   ; set gfx data byte count
                            
                            iny                             ; set offset to gfx data byte
                            lda (LRZ_ScreenGfxPtr),y        ; get gfx data byte
                            sta LRZ_WorkStartGfxData        ; set gfx data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance gfx data pointer to next gfx data pair
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_ScreenGfxPtr_Lo         ; get grafic output ptr LO
                            clc                             ; 
                            adc #LR_StartGfxDataPtr_Len     ; add compressed data length
                            sta LRZ_ScreenGfxPtr_Lo         ; set grafic output ptr LO
                            bcc GetGfxCountAndDataByte      ; check: overflow - no
                            inc LRZ_ScreenGfxPtr_Hi         ; inc grafic output ptr HI
; --------------------------------------------------------------------------------------------------------------------- ;
; output the next start grafic data bytes
; --------------------------------------------------------------------------------------------------------------------- ;
GetGfxCountAndDataByte      lda LRZ_WorkStartGfxDataCount   ; get gfx data byte count
                            tay                             ; set gfx data byte count as offset
                            lda LRZ_WorkStartGfxData        ; get gfx data byte
                            
SetNextStartGfxDataByte     sta (LRZ_StartGfxDisplay),y     ; set start grafic data
                            dey                             ; dec gfx data byte count
                            bne SetNextStartGfxDataByte     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; advance start grafic output pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_StartGfxDisplay_Lo      ; get next start grafic pos LO
                            clc                             ; 
                            adc LRZ_WorkStartGfxDataCount   ; add old offset
                            sta LRZ_StartGfxDisplay_Lo      ; set next start grafic pos LO
                            bcc ChkEndOfCopy                ; check: overflow - no
                            inc LRZ_StartGfxDisplay_Hi      ; inc next start grafic pos HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check end of start grafic expand
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEndOfCopy                lda LRZ_StartGfxDisplay_Hi      ; get start grafic pos HI
                            cmp #>LR_ScreenGfxDisplayEnd    ; test maximum
                            bcc GetNextGfxDataInPair        ; check: LT - yes: continue
                            
                            jmp GameOver.DemoWaitInit       ; init wait for demo - .C set forces new key reset
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ_PlayTunes             Does    : play the tune available in IRQ tune buffer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_PlayTunes              .block                           ; 
                            ldx LR_TuneToPlayOff            ; get tune buffer offset
                            cpx LR_TuneFreeBufferPosOff     ; test with next free tune buffer offset
                            beq IRQ_PlayTunesOff            ; check: EQ - yes: all tunes completed - exit
                            
                            lda #CNTRL3_GATE_ADS | CNTRL3_TRI ; get start attack decay sustain/triangle wave
                            sta LR_WaveVoice2               ; set wave form voice 2
                            sta LR_WaveVoice3               ; set wave form voice 3
                            
                            lda LR_TuneSuReVol,x            ; get tune s/r/volume - not used
                            
                            lda #STNRIS2_STN_MASK           ; get sustain voice 2
                            and LR_Volume                   ; isolate sustain volume level
                            sta SUREL2                      ; SID($D40D) Oscillator 2 Sustain/Release
                            sta SUREL3                      ; SID($D414) Oscillator 3 Sustain/Release
                            
                            lda LR_TuneDataPtrVoice2,x      ; get new tab tune data pointer voice 2
                            bne SetFreqCtrlDataTableOff     ; check: none - yes
                            
                            sta LR_WaveVoice2               ; set new tab tune data pointer voice 2
                            
SetFreqCtrlDataTableOff     tay                             ; set as offset
                            lda TabFreqCtrlData_Lo,y        ; get freq data LO from buffer
                            sta FRELO2                      ; SID($D407) Oscillator 2 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq data HI from buffer
                            sta FREHI2                      ; SID($D408) Oscillator 2 Freq Ctrl (HI byte)
                            
                            lda LR_TuneDataPtrVoice3,x      ; get tab tune data pointer voice 3
                            bpl ChkTuneDataPtrZero          ; check: positive - yes
                            
                            lda LR_TuneDataPtrVoice2,x      ; get tab tune data pointer voice 2
                            tay                             ; set as offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set decreased freq for voice 3 HI/LO
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            lda TabFreqCtrlData_Lo,y        ; get freq data LO from buffer
                            sbc #$80                        ; decrease
                            sta FRELO3                      ; SID($D40E) Oscillator 3 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq data HI from buffer
                            sbc #$00                        ; subtract .C
                            sta FREHI3                      ; SID($D40F) Oscillator 3 Freq Ctrl (HI byte)
                            
                            jmp SetVoiceCtrlData            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTuneDataPtrZero          bne SetAsOffset                 ; check: zero - no
                            
                            sta LR_WaveVoice3               ; set tune data for voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
; set freq for voice 3 HI/LO
; --------------------------------------------------------------------------------------------------------------------- ;
SetAsOffset                 tay                             ; 
                            lda TabFreqCtrlData_Lo,y        ; get freq ctrl data LO
                            sta FRELO3                      ; SID($D40E) Oscillator 3 Freq Ctrl (LO byte)
                            
                            lda TabFreqCtrlData_Hi,y        ; get freq ctrl data HI
                            sta FREHI3                      ; SID($D40F) Oscillator 3 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; set voice control data for voice 2/voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
SetVoiceCtrlData            lda LR_WaveVoice2               ; get tune control data for voice 2
                            sta VCREG2                      ; SID($D40B) Oscillator 2 Control
                            
                            lda LR_WaveVoice3               ; get tune control data for voice 3
                            sta VCREG3                      ; SID($D412) Oscillator 3 Control
; --------------------------------------------------------------------------------------------------------------------- ;
; dec playtime
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LR_TunePlayTime,x           ; dec tune play time
                            bne IRQ_PlayTunesX              ; check: end of tune - no: exit - continue this one
; --------------------------------------------------------------------------------------------------------------------- ;
; set next tune to play
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LR_TuneToPlayOff            ; set offest to next tune to play
                            
IRQ_PlayTunesX              rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ_PlayTunesOff            lda #$00                        ; get reset value
                            sta VCREG2                      ; SID($D40B) Oscillator 2 Control
                            sta VCREG3                      ; SID($D412) Oscillator 3 Control
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuSetGetGoldJingle    Does    : fill the IRQ tune buffer with get gold jingle
;                           Expects : 
;                           Returns : 
;                           Remark  : jingle is played with IRQ
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuSetGetGoldJingle     .block                           ; 
                            pla                             ; 
                            sta LRZ_JingleDataPtr_Lo        ; set jingle data pointer LO
                            pla                             ; 
                            sta LRZ_JingleDataPtr_Hi        ; set jingle data pointer HI
                            bne IncJingleDataPtr            ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; copy next jingle part value to tune buffers
; --------------------------------------------------------------------------------------------------------------------- ;
PutNextJingleByteToBuf      sei                             ; disable interrupts - do not play any jingle now
; --------------------------------------------------------------------------------------------------------------------- ;
; a jingle data block has 4 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get initial offset
                            lda (LRZ_JingleDataPtr),y       ; get 1st jingle data block byte
                            beq PutNextJingleByteToBufX     ; check: EoD - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st byte: fill time buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LR_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            sta LR_TunePlayTime,x           ; set tab jingle time
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd byte: fill voice 2 value buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (LRZ_JingleDataPtr),y       ; get 2nd jingle data block byte
                            sta LR_TuneDataPtrVoice2,x      ; set tab jingle data pointer voice 2
; --------------------------------------------------------------------------------------------------------------------- ;
; 3rd byte: fill voice 3 value buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (LRZ_JingleDataPtr),y       ; get 3rd jingle data block byte
                            sta LR_TuneDataPtrVoice3,x      ; set tab jingle data pointer voice 3
; --------------------------------------------------------------------------------------------------------------------- ;
; 4th byte: fill sustain/release/volume buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (LRZ_JingleDataPtr),y       ; get 4th jingle data block byte
                            sta LR_TuneSuReVol,x            ; set tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
; advance pointer to next jingle block of data
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LR_TuneFreeBufferPosOff     ; inc offset next free tune buffer byte
                            lda LRZ_JingleDataPtr_Lo        ; get jingle data pointer LO
                            clc                             ; 
                            adc #LodeRuGetGold.TabGoldJinglePart_Len ; add tune part table length
                            sta LRZ_JingleDataPtr_Lo        ; set jingle data pointer LO
                            
                            lda LRZ_JingleDataPtr_Hi        ; get jingle data pointer HI
                            adc #$00                        ; add .C
                            sta LRZ_JingleDataPtr_Hi        ; set jingle data pointer HI
                            bne PutNextJingleByteToBuf      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
IncJingleDataPtr            inc LRZ_JingleDataPtr_Lo        ; inc jingle data pointer LO
                            bne PutNextJingleByteToBuf      ; check: overflow - no
                            inc LRZ_JingleDataPtr_Hi        ; inc jingle data pointer HI
                            bne PutNextJingleByteToBuf      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; push jingle data pointer to stack - thus return to code directly following jingle data
; --------------------------------------------------------------------------------------------------------------------- ;
PutNextJingleByteToBufX     lda LRZ_JingleDataPtr_Hi        ; get pointer jingle data end HI
                            pha                             ; push as return address
                            
                            lda LRZ_JingleDataPtr_Lo        ; get pointer jingle data end LO
                            pha                             ; push as return address
                            
                            cli                             ; enable interrupts - reallow play of jingles
                            rts                             ; return to instruction directly after end of jingle data
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetGoldJingleVal    Does   : return RND raster beam position within given limits
;                           Expects : .A=bottom limit
;                                   : .X=lower limit
;                                   : .Y=upper limit
;                           Returns : .A=raster beam position within limits
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetGoldJingleVal     .block                           ; 
                            sta LR_GoldJingleBeamLimit      ; save bottom limit
                            
GetNextRasterBeamPos        lda RASTER                      ; VIC($D012) Read: Current Raster Scan Line (Bit 8 in SCROLY = $D011)
                            sta LR_GoldJingleBeamPos        ; set beam pos
                            
                            cpx LR_GoldJingleBeamPos        ; test beam pos lower limit
                            bcc ChkUpperLimit               ; check: LT - yes
                            beq ChkUpperLimit               ; check: EQ - yes
                            
                            jmp GetNextRasterBeamPos        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkUpperLimit               cpy LR_GoldJingleBeamPos        ; test beam pos upper limit
                            bcc GetNextRasterBeamPos        ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; raster beam value is between upper and lower limit
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc LR_GoldJingleRndSeed        ; 
                            bcs ChkBottomLimit              ; check: underflow - no
                            
                            eor #$ff                        ; set ones complement - make positive
                            adc #$01                        ; 
                            
ChkBottomLimit              cmp LR_GoldJingleBeamLimit      ; test limit
                            bcc GetNextRasterBeamPos        ; check: LT - yes: get next beam pos
                            
                            lda LR_GoldJingleBeamPos        ; get correct beam pos
                            sta LR_GoldJingleRndSeed        ; set new seed
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldInit      Does    : initialize the jingle control data
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldInit       .block                           ; 
                            lda TabJingleMaxNum             ; get initial value
                            sta LR_JingleNum                ; set jingle count
                            
                            lda TabJingleHeight_Min         ; get initial value
                            sta LR_JingleHeight             ; ini jingle height
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldNext      Does    : set the next got all gold jingle
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldNext       .block                           ; 
                            dec LR_JingleNum                ; set next Jingle number
                            bpl JingleGotAllGoldNextX       ; check: underflow - no: exit
                            
                            inc LR_JingleHeight             ; inc Jingle height
                            
                            lda LR_JingleHeight             ; get Jingle height
                            cmp TabJingleHeight_Max         ; test max
                            bcc SetJingleMaxNum             ; check: LT - no: set Jingle to max
                            
                            lda TabJingleHeight_Min         ; get min height
                            sta LR_JingleHeight             ; set height to min again
                            
SetJingleMaxNum             lda TabJingleMaxNum             ; get initial value
                            sta LR_JingleNum                ; ini jingle number
                            
JingleGotAllGoldNextX       rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; JingleGotAllGoldCopy      Does    : fill the tune buffers with the data for the all gold collected jingle
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
JingleGotAllGoldCopy       .block                           ; 
                            lda LR_JingleNum                ; get Jingle number
                            asl a                           ; *2 for pointer length
                            tax                             ; set Jingle data pointer table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; set jingle data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabJingleDataPtr_Lo,x       ; get pointer to Jingle data LO
                            sta LRZ_JingleDataPtr_Lo        ; set Jingle data pointer LO
                            lda TabJingleDataPtr_Hi,x       ; get pointer to Jingle data HI
                            sta LRZ_JingleDataPtr_Hi        ; set Jingle data pointer LO
; --------------------------------------------------------------------------------------------------------------------- ;
; copy the jingle data
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextJingleDataBlock      sei                             ; disable interrupts - do not play any jingle now
                            
                            ldy #$00                        ; get offset Jingle data
                            lda (LRZ_JingleDataPtr),y       ; get Jingle data for play time
                            beq JingleGotAllGoldCopyX   ; check: end of data - yes: exit
                            
                            ldx LR_TuneFreeBufferPosOff     ; get offset next free tune buffer byte
                            sta LR_TunePlayTime,x           ; set tune play time
                            
                            iny                             ; advance offset Jingle data
                            lda (LRZ_JingleDataPtr),y       ; get Jingle data for voice 2
                            beq SetTuneDataVoice2           ; check: silence - yes: bypass adaption
                            
                            clc                             ; 
                            adc LR_JingleHeight             ; add actual jingle height
                            
SetTuneDataVoice2           sta LR_TuneDataPtrVoice2,x      ; set tab tune data pointer voice 2
                            
                            iny                             ; advance offset Jingle data
                            lda (LRZ_JingleDataPtr),y       ; get Jingle data for voice 3
                            beq SetTuneDataVoice3           ; check: silence - yes: bypass adaption
                            bmi SetTuneDataVoice3           ; check: silence - yes: bypass adaption
                            
                            clc                             ; 
                            adc LR_JingleHeight             ; add actual jingle height
                            
SetTuneDataVoice3           sta LR_TuneDataPtrVoice3,x      ; set tab tune data pointer voice 3
                            
                            iny                             ; advance offset Jingle data
                            lda (LRZ_JingleDataPtr),y       ; get Jingle data for sustain/release/volume
                            sta LR_TuneSuReVol,x            ; set tune s/r/volume  (not used)
                            
                            inc LR_TuneFreeBufferPosOff     ; inc offset to next free tune buffer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance Jingle data pointer - a jingle data block has 4 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_JingleDataPtr_Lo        ; get Jingle data pointer LO
                            clc                             ; 
                            adc #TabJingleDataBlock_Len     ; add entry block length
                            sta LRZ_JingleDataPtr_Lo        ; set Jingle data pointer LO
                            
                            lda LRZ_JingleDataPtr_Hi        ; get data pointer HI
                            adc #$00                        ; add .C
                            sta LRZ_JingleDataPtr_Hi        ; set data pointer HI
                            
                            bne GetNextJingleDataBlock      ; always (hopefully)
                            
JingleGotAllGoldCopyX       cli                             ; enable interrupts - reallow play of jingles
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IRQ                       Does    : loderunner IRQ routine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IRQ                        .block                           ; 
                            inc LR_CountIRQs                ; 
                            
                            lda #$00                        ; get initial value
                            sta LRZ_TuneValueVoice_01       ; set tune value voice 1
                            
                            lda LR_Volume                   ; get volume
                            and #MODEVOL_VOL_MASK           ; isolate volume
                            sta SIGVOL                      ; SID($D418) Volume/Filter Select
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is falling down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LodeRuFallsDown          ; get $00=fall $20=no fall $ff=init
                            bne InitFallBeep                ; check: not falling - yes
                            
                            ldx LR_TuneBeepFall             ; get fall beep
                            stx LRZ_TuneValueVoice_01       ; set tune value voice 1
                            
                            jmp CheckLodeRuShoot            ; check for shooting
; --------------------------------------------------------------------------------------------------------------------- ;
InitFallBeep                lda #LR_TuneBeepFall_Start      ; get initial value
                            sta LR_TuneBeepFall             ; set fall beep start value
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is shooting
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLodeRuShoot            lda LR_LodeRuShoot              ; get $00=no $01=right $ff=left
                            beq InitShootTune               ; check: no shoot - yes
                            
                            lda LR_TuneShoot                ; get actual shoot tune value
                            sec                             ; 
                            sbc #LR_TuneShoot_Step          ; step tune value down
                            sta LR_TuneShoot                ; set actual shoot tune value
                            sta LRZ_TuneValueVoice_01       ; set tune value voice 1
                            beq InitShootTune               ; check: zero - yes: reinit
                            
                            jmp CheckLodeRuDeath            ; check for death
; --------------------------------------------------------------------------------------------------------------------- ;
InitShootTune               lda #LR_TuneShoot_Start         ; get 
                            sta LR_TuneShoot                ; set 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner has died
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLodeRuDeath            lda LR_TuneDeath                ; get actual death tune
                            beq GetTuneValueToPlay          ; check: death - no
                            
                            sec                             ; 
                            sbc #LR_TuneDeath_Step          ; step tune value down
                            sta LRZ_TuneValueVoice_01       ; set tune value voice 1
                            sta LR_TuneDeath                ; set actual death tune
; --------------------------------------------------------------------------------------------------------------------- ;
; play tune
; --------------------------------------------------------------------------------------------------------------------- ;
GetTuneValueToPlay          lda LRZ_TuneValueVoice_01       ; get tune value voice 1
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            jsr IRQ_PlayTunes               ; play the tune available in IRQ tune buffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check keyboard input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LSTX                        ; KERNAL ZP: keyboard matrix value last key pressed
                            bne ChkKeyNone                  ; check: <INST/DEL> - no
                            
                            lda #$07                        ; get <CURSOR_DOWN>
                            
ChkKeyNone                  cmp #LSTX_NONE                  ; test no key pressed
                            bne GetFlagShiftKey             ; check: a key pressed - yes
                            
                            lda #$00                        ; get initial value
                            sta LR_KeyOld                   ; ini pressed key store
                            
                            jmp KEY                         ; continue with main KERNAL IRQ entry point
; --------------------------------------------------------------------------------------------------------------------- ;
GetFlagShiftKey             ldx SHFLAG                      ; get $01=shift $02=commodore $04=ctrl
                            beq ChkKeyOld                   ; check: SHFLAG_NONE - yes
                            
                            ora #$80                        ; set bit7 - mark shifted key input
                            
ChkKeyOld                   cmp LR_KeyOld                   ; test pressed key store
                            beq GoMainIRQ                   ; check: EQ key got - yes: bypass store
                            
                            sta LR_KeyOld                   ; set pressed key store
                            sta LR_KeyNew                   ; set new key
                            
GoMainIRQ                   jmp KEY                         ; continue with main KERNAL IRQ entry point
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartInitMachine          Does    : initially prepare the machine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StartInitMachine           .block                           ; 
                            lda R6510                       ; 6510 On-Chip I/O Data
                            and #%11000000 | LORAM_BASIC_OFF; switch basic off
                            sta R6510                       ; 6510 On-Chip I/O Data
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner bit-mapped memory
;   $19 blocks ($00-$18)
;     each block contains $140 (320) bytes and controls $08 horizontal pixel rows
;     every 8th Y-value starts a new block of $140 bytes
; --------------------------------------------------------------------------------------------------------------------- ;
;   byte number of the 1st byte in any block (X=pixel col number/Y=row number)
;     320*(INT(Y/8))
;   byte number contaning the requested hires bit
;     320*(INT(Y/8)) + (Y AND 7) + 8*(INT(X/8))
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
;       X !  Column $00  !  column $01  !  column $02  !     !  column $26  !  column $27  ! 
; Y       ! byte  number ! byte  number ! byte  number !     ! byte  number ! byte  number ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; row $00 !     0000     !     0008     !    0010      ! ... !     0130     !     0138     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $00
; row $07 !     0007     !     000f     !    0017      ! ... !     0137     !     013f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; row $08 !     0140     !     0148     !    0150      ! ... !     0282     !     0278     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $01
; row $0f !     0147     !     014f     !    0157      ! ... !     0277     !     027f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;
; ...     !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! 
; ----+--------------+--------------+--------------+-----+--------------+--------------+------------------------------- ;
; row $c0 !     1e00     !     1e08     !    1e10      ! ... !     1f30     !     1f38     ! 
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $18
; row $c7 !     1e07     !     1e0f     !    1e17      ! ... !     1f37     !     1f3f     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;

; block $19 not used
; ----+--------------+--------------+--------------+-----+--------------+--------------+------------------------------- ;
; row $c8 !     1f40     !     1f48     !    1f50      ! ... !     1f00     !     1f08     !  
;     ... !     ....     !     ....     !    ....      ! ... !     ....     !     ....     ! Block $19
; row $cf !     1f47     !     1f4f     !    1f57      ! ... !     1f07     !     1fff     ! 
; --------+--------------+--------------+--------------+-----+--------------+--------------+--------------------------- ;

; --------------------------------------------------------------------------------------------------------------------- ;
; init values of the tables containing the HiRes pixel row start addresses
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get intial value LO
                            sta LRZ_WorkHiresRowStartAdr_Lo ; ini work grafic row start address LO
                            lda #$00                        ; get initial value HI <obsolete>
                            sta LRZ_WorkHiresRowStartAdr_Hi ; ini work grafic row start address HI
                            
                            ldy #$00                        ; ini offset tab grafic row start pointer tab
                            
                            lda #VICSCN_NLINES              ; get hires block count (25)
                            sta LR_HiresBlockCount          ; ini hires block count (25*320 bytes)
; --------------------------------------------------------------------------------------------------------------------- ;
; create tables with HI/LO start addresses of $c8 HiRes rows forming $19 blocks of $08 stacked pixel rows
; --------------------------------------------------------------------------------------------------------------------- ;
; $0e00: block $00 LO - $00 $01 $02 $03 $04 $05 $06 $07 - start address LO - $08 pixel rows of block $00
; $0e08: block $01 LO - $40 $41 $42 $43 $44 $45 $46 $47 - start address LO - $08 pixel rows of block $01
; ...... ..... ... ..   ... ... ... ... ... ... ... ... 
; $0ec0: block $18 LO - $00 $01 $02 $03 $04 $05 $06 $07 - start address LO - $08 pixel rows of block $18
; --------------------------------------------------------------------------------------------------------------------- ;
; $0f00: block $00 HI - $00 $00 $00 $00 $00 $00 $00 $00 - start address HI - $08 pixel rows of block $00
; $0f08: block $01 HI - $01 $01 $01 $01 $01 $01 $01 $01 - start address HI - $08 pixel rows of block $01
; ...... ..... ... ..   ... ... ... ... ... ... ... ... 
; $0fc0: block $18 HI - $1e $1e $1e $1e $1e $1e $1e $1e - start address HI - $08 pixel rows of block $18
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextBlockRowCount        ldx #$08                        ; ini count stacked bytes per block
GetNextTabPairValue         lda LRZ_WorkHiresRowStartAdr_Hi ; get work grafic row start address HI
                            sta LR_HiresRowStartPtrTab_Hi,y ; set tab grafic row start address HI
                            
                            lda LRZ_WorkHiresRowStartAdr_Lo ; get work grafic row start address LO
                            sta LR_HiresRowStartPtrTab_Lo,y ; set tab grafic row start address LO
                            
                            inc LRZ_WorkHiresRowStartAdr_Lo ; inc work grafic row start address LO
                            
                            iny                             ; inc offset tab grafic row start pointer tab
                            dex                             ; dec count stacked bytes per block
                            bne GetNextTabPairValue         ; check: count stacked bytes per block min - no: contiinue
                            
                            clc                             ; .A=work grafic row start pointer LO
                            adc #<$140 - $07                ; add $140 (320) - sub 7 --> 8 rows are counted already in the inner loop
                            sta LRZ_WorkHiresRowStartAdr_Lo ; set work grafic row start address LO
                            
                            lda LRZ_WorkHiresRowStartAdr_Hi ; get work grafic row start address HI
                            adc #>$140 - $07                ; add $140 (320) - sub 7 --> 8 rows are counted already in the inner loop
                            sta LRZ_WorkHiresRowStartAdr_Hi ; set work grafic row start address HI
                            
                            dec LR_HiresBlockCount          ; dec hires block count
                            bne GetNextBlockRowCount        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set NMI vector to a simple RTI
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<NMI                       ; get start of NMI routine LO
                            sta NMINV_LO                    ; set Vector($0318/$0319): Hardware NMI interrupt address ($FE47)
                            lda #>NMI                       ; get start of NMI routine HI
                            sta NMINV_HI                    ; set Vector($0318/$0319): Hardware NMI interrupt address ($FE47)

                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #BLACK                      ; get color
                            sta BGCOL0                      ; VIC($D021) Background Color 0
                            sta EXTCOL                      ; VIC($D020) Border Color
; --------------------------------------------------------------------------------------------------------------------- ;
; set IRQ vector - handles all ingame tunes
; --------------------------------------------------------------------------------------------------------------------- ;
                            sei                             ; 
                            lda #<IRQ                       ; get start of IRQ routine LO
                            sta CINV_LO                     ; set Vector($0314/$0315): Hardware IRQ Interrupt address ($EA31)
                            lda #>IRQ                       ; get start of IRQ routine HI
                            sta CINV_HI                     ; set Vector($0314/$0315): Hardware IRQ Interrupt address ($EA31); IRQ vector
                            cli                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; ini SID
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$b0                        ; get initial value
                            sta SUREL1                      ; SID($D406) Oscillator 1 Sustain/Release
                            
                            lda #CNTRL1_TRI | CNTRL1_GATE_ADS ; get initial value
                            sta VCREG1                      ; SID($D404) Oscillator 1 Control
; --------------------------------------------------------------------------------------------------------------------- ;
; ini sprites
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #LR_SpriteData / SPRT_BLK_LEN ; get sprite storage pointer
                            stx LR_SpritePtr_00             ; set sprite 0 data pointer to LR_SpriteData + $00
                            inx                             ; 
                            stx LR_SpritePtr_02             ; set sprite 2 data pointer to LR_SpriteData + $40
                            inx                             ; 
                            stx LR_SpritePtr_03             ; set sprite 3 data pointer to LR_SpriteData + $80
                            inx                             ; 
                            stx LR_SpritePtr_04             ; set sprite 4 data pointer to LR_SpriteData + $c0
                            inx                             ; 
                            stx LR_SpritePtr_06             ; set sprite 6 data pointer to LR_SpriteData + $00
                            inx                             ; 
                            stx LR_SpritePtr_07             ; set sprite 7 data pointer to LR_SpriteData + $40
                            
                            lda #CYAN                       ; get color
                            ldy #$07                        ; ini enemy sprite count
SetNextEnemyColor           sta SP0COL,y                    ; VIC($D027) Color Sprite 0
                            
                            dey                             ; dec enemy sprite count
                            bne SetNextEnemyColor           ; check: enemy sprite count min - no: continue
                            
                            iny                             ; get Loderunner sprite color WHITE
                            sty SP0COL                      ; VIC($D027) Color Sprite 0
                            
                            lda #SPBGPR_ALL_FG              ; get all Sprites display priority in front of background
                            sta SPBGPR                      ; set VIC($D01B) Sprite to Foreground Display Priority
; --------------------------------------------------------------------------------------------------------------------- ;
; clear sprite buffers
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; init buffer page offset to $00
ClrNextSpriteBufferByte     sta ZP_START + $02,y            ; set zero page
                            sta LR_SpriteDataPage_01,y      ; set sprite data store at $0c00 to $00
                            sta LR_SpriteDataPage_02,y      ; set sprite data store at $0d00 to $00
                            
                            iny                             ; inc buffer page offset
                            bne ClrNextSpriteBufferByte     ; check: buffer page offset max - no: continue
                            
                            lda #SPENA_ALL_ON               ; get switch on all sprites
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ColorLevel                Does    : fill game level screen with the selected colors
;                           Expects : .A=hires color
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ColorLevel                 .block                           ; 
                            sta ssHiresColor                ; set actual hires color
                            
                            lda SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
                            ora #SCROLX_MCM_ON              ; switch on Multi Color Mode (MCM)
                            sta SCROLX                      ; VIC($D016) VIC Control Register 2 (Horiz Fine Scroll)
                            
                            ldy #$00                        ; get offset
ssHiresColor                = * + $01                       ; 
GetNextHiresColor           lda #HR_ORANGE_BLUE             ; get actual hires color
                            sta LR_ScreenMC_Page0,y         ; set hires color pages
                            sta LR_ScreenMC_Page1,y         ; 
                            sta LR_ScreenMC_Page2,y         ; 
                            sta LR_ScreenMC_Page3,y         ; 
                            
                            lda #WHITE                      ; get constant coloram color of WHITE
                            sta LR_ColorRam_Page0,y         ; set ColorRAM Page $00 - $D800 (of $D800-$DBFF)
                            sta LR_ColorRam_Page1,y         ; set ColorRAM Page $01 - $D900 (of $D800-$DBFF)
                            sta LR_ColorRam_Page2,y         ; set ColorRAM Page $02 - $DA00 (of $D800-$DBFF)
                            sta LR_ColorRam_Page3,y         ; set ColorRAM Page $03 - $DB00 (of $D800-$DBFF)
                            
                            dey                             ; dec offset
                            bne GetNextHiresColor           ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; NMI                       Does    : NMI interrupt
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
NMI                        .block                           ; 
                            rti                             ; nothing to do
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteNum           = *       ; 
                            .byte $01 ; .......# - $00
                            .byte $05 ; .....#.# - $01
                            .byte $0d ; ....##.# - $02
                            .byte $1d ; ...###.# - $03
                            .byte $5d ; .#.###.# - $04
                            .byte $dd ; ##.###.# - $05
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_Start                 Does    : board editor: start
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_Start                  .block                           ; 
                            lda #$00                        ; get initial value
                            sta LR_Score_Lo                 ; ini score 
                            sta LR_Score_MidLo              ; 
                            sta LR_Score_MidHi              ; 
                            sta LR_Score_Hi                 ; 
                            
                            lda #LR_LevelReload_Force       ; get force level reload
                            sta LR_LevelReload              ; set force level reload
                            
                            lda #$05                        ; get initial value
                            sta LR_NumLives                 ; ini live count ($05) 
                            sta LR_GameMode                 ; ini $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            sta LR_SpriteShow               ; ini LR_SpriteShow_Off
                            
                            lda LR_ControllerType           ; get controller type
                            sta BED_LevelPlay.smControllerType ; set type
                            
                            lda #LR_ControllerType_Keyboard ; get keyboard
                            sta LR_ControllerType           ; set keyboard
                            
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            cmp #LR_LevelNumDisk_Gap        ; test max level number - gap level reached
                            bcc BED_InitScreen              ; check: LT - yes: bypass level number reset
                            
                            lda #LR_LevelNumDisk_Min        ; get initial value
                            sta LR_LevelNumDisk             ; ini disk level number 000-149
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_InitScreen            Does    : board editor: clear screen and init
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_InitScreen             .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #HR_YELLOW_CYAN             ; get editor hires color
                            jsr ColorLevel                  ; fill game level screen with the selected colors
                            
                            lda #>LR_ScreenGfxDisplay       ; get address display screen HI
                            sta LRZ_TargetGfxOutput         ; set target output indicator $20=$2000 $40=$4000
                            
                            lda #$00                        ; get initial value
                            sta LR_KeyNew                   ; ini new key input
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta LRZ_ScreenCol               ; ini screen col ($00-$1b)
                            sta LRZ_ScreenRow               ; ini screen row ($00-$0f)
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;   LODE RUNNER BOARD EDITOR
                            .byte " " | $80 ; <SHIFT_SPACE> ; ----------------------------
                            .byte "l" | $80 ;               ;  R/S KEY ABORTS ANY COMMAND
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "b" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "b" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            
                            .byte $00 ; EndOfText
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CommandCheck          Does    : board editor: care for a valid command input and exec the appropriate routine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CommandCheck           .block                           ; 
                            lda LRZ_ScreenRow               ; get screen row ($00-$0f)
                            cmp #LRZ_ScreenRow_BED_Input_Max; test max input row
                            bcs BED_InitScreen              ; check: GE - yes: clear screen and init the board editor
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "c" | $80 ;               ; COMMAND>
                            .byte "o" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte ">" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            
GetNextCmdTabEntry          ldy TabBED_CmdChar,x            ; get next command table entry
                            beq BED_CommandError            ; check: EoT - yes: command invalid - error beep and wait for next command
                            
                            cmp TabBED_CmdChar,x            ; test valid command table entry
                            beq BED_CommandExec             ; check: EQ - yes: found one
                            
                            inx                             ; inc command table offset
                            bne GetNextCmdTabEntry          ; always (hopefully)
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CommandError          Does    : board editor: error beep and wait for next command
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CommandError           .block                           ; 
                            jsr EditorErrorBeep             ; output an error beep signal
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CommandExec           Does    : board editor: dispatch the selected command routine
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CommandExec            .block                           ; 
                            txa                             ; 
                            asl a                           ; *2
                            tax                             ; 
                            
                            lda TabBED_CmdAddress + $01,x   ; get adr board editor cmd HI
                            pha                             ; push on stack
                            lda TabBED_CmdAddress + $00,x   ; get adr board editor cmd LO
                            pha                             ; push on stack
                            
                            rts                             ; call edit command routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; board editor commands
; --------------------------------------------------------------------------------------------------------------------- ;
TabBED_CmdChar              = *       ; 
                            .byte $29 ; p - play level
                            .byte $14 ; c - clear level
                            .byte $0e ; e - edit level
                            .byte $24 ; m - move level
                            .byte $21 ; i - init disk
                            .byte $0d ; s - clear scores
                            
                            .byte $00 ; end of edit commands marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabBED_CmdAddress           = * ; 
                            .word BED_LevelPlay  - $01 ; play a selected game level from editor
                            .word BED_LevelClear - $01 ; clear a selected game level
                            .word BED_LevelEdit  - $01 ; edit a selected game level
                            .word BED_LevelMove  - $01 ; move a selected game level
                            .word BED_DiskInit   - $01 ; init a loderunner level disk
                            .word BED_ScoreClear - $01 ; clear loaderunner leaderboard on disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelPlay             Does    : board editor: play a selected game level from editor
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelPlay              .block                           ; 
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>PLAY LEVEL
                            .byte ">" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid level number
                            bcs BED_LevelPlayX_Bad          ; check: error - yes: beep and get next command
                            
smControllerType            = * + $01                       ; 
                            lda #$00                        ; get controller
                            sta LR_ControllerType           ; set controller
                            
                            lda #LR_GameMode_PlayFromEdit   ; get play from edit mode
                            sta LR_GameMode                 ; set game mode - $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            
                            lda #LR_Cheated_No              ; get flag not cheated
                            sta LR_Cheated                  ; set flag not cheated
                            
                            lda #LR_SpriteShow_On           ; get show sprites
                            sta LR_SpriteShow               ; set show sprites
                            
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            beq BED_LevelPlayX_Good         ; check: 1st level - yes: no cheating
                            
                            lsr LR_Cheated                  ; LR_Cheated_Yes
BED_LevelPlayX_Good         jmp GameStart                   ; start game preparations and play selected level
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelPlayX_Bad          jmp BED_CommandError            ; error beep and wait for next command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelClear            Does    : board editor: clear a level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelClear             .block                           ; 
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>CLEAR LEVEL
                            .byte ">" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ;
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid level number
                            bcs BED_LevelClearX_Bad         ; check: error - yes: beep and get next command
                            
                            jsr BED_CheckDiskType           ; check if loderunner user data disk
                            
                            ldy #$00                        ; ini offset to level data
                            tya                             ; get LR_TileNum_Empty     
ClearNextLevelDataByte      sta LR_LevelDataBuf,y           ; set get clear level store
                            
                            iny                             ; inc offset to level data
                            bne ClearNextLevelDataByte      ; check: max - no: continue
                            
                            lda #LR_DiskWrite               ; get flag disk write
                            jsr DiskOperationHandler        ; write cleared level to disk
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelClearX_Bad         jmp BED_CommandError            ; error beep and wait for next command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelEdit             Does    : board editor: edit a level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelEdit              .block                           ; 
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>EDIT LEVEL
                            .byte ">" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid level number
                            bcs BED_LevelEditX_Bad          ; check: error - yes: beep and get next command
                            
                            jmp LED_Start                   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelEditX_Bad          jmp BED_CommandError            ; error beep and wait for next command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelMove             Does    : board editor: move a level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelMove              .block                           ; 
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>MOVE LEVEL
                            .byte ">" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid source level number
                            bcs BED_LevelMoveX_Bad          ; check: error - yes: beep and get next command
                            
                            sty TabBED_SaveMoveLevelSource  ; save source level number
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;  TO LEVEL
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_LevelNumberGet          ; get a valid target level number
                            bcs BED_LevelMoveX_Bad          ; check: error - yes: beep and get next command
                            
                            sty TabBED_SaveMoveLevelTarget  ; save target level number
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ;   SOURCE DISKETTE
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; read source level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            jsr BED_CheckDiskType           ; check if loderunner user data disk
                            
                            lda TabBED_SaveMoveLevelSource  ; get source level number
                            sta LR_LevelNumDisk             ; set disk level number 000-149
                            
                            lda #LR_DiskRead                ; get flag disk read
                            jsr DiskOperationHandler        ; read block from source disk location
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ;   DESTINATION DISKETTE
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; write target level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            jsr BED_CheckDiskType           ; check if loderunner user data disk
                            
                            lda TabBED_SaveMoveLevelTarget  ; get target level number
                            sta LR_LevelNumDisk             ; set disk level number 000-149
                            
                            lda #LR_DiskWrite               ; get flag disk write
                            jsr DiskOperationHandler        ; write block to taget disk location
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelMoveX_Bad          jmp BED_CommandError            ; error beep and wait for next command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_DiskInit              Does    : board editor: initialize a user level disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_DiskInit               .block                           ; 
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; 
                            .byte ">" | $80 ;               ; 
                            .byte "i" | $80 ;               ; >>INITIALIZE
                            .byte "n" | $80 ;               ;   THIS PREPARES AN ALREADY 
                            .byte "i" | $80 ;               ;   FORMATTED DISK FOR USER 
                            .byte "t" | $80 ;               ;   CREATED LEVELS.
                            .byte "i" | $80 ;               ;   (WILL DESTROY OLD DATA).
                            .byte "a" | $80 ;               ;   ARE YOU SURE (Y/N)
                            .byte "l" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "z" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "p" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "f" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "m" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "f" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "u" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "(" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "o" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte ")" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "(" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte ")" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            
                            cmp #$19                        ; test "Y"
                            bne BED_DiskInitX               ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; check master disk - not modifiable
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            
                            cmp #LR_ScoreBufCheck_Mod_No    ; test disk is a master disk
                            bne IniDiskLevelInit            ; check: EQ - no: start initializing
                            
                            jsr BED_ErrorMsgDiskMaster      ; write out error message loderunner master disk
                            jmp BED_InitScreen              ; clear screen and init the board editor
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize disk
; --------------------------------------------------------------------------------------------------------------------- ;
IniDiskLevelInit            lda LR_LevelNumDisk             ; get disk level number 000-149
                            pha                             ; save actual level number
                            
                            lda #LR_DiskInit                ; get flag disk init
                            jsr DiskOperationHandler        ; init a level disk
                            
                            pla                             ; restore actual level number
                            sta LR_LevelNumDisk             ; set disk level number 000-149
                            
BED_DiskInitX               jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_ScoreClear            Does    : board editor: clear the leaderboard entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_ScoreClear             .block                           ; 
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte ">" | $80 ;               ; >>CLEAR SCORE FILE
                            .byte ">" | $80 ;               ;   THIS CLEARS THE HIGH
                            .byte "c" | $80 ;               ;   SCORE FILE OF ALL
                            .byte "l" | $80 ;               ;   ENTRIES.
                            .byte "e" | $80 ;               ;   ARE YOU SURE (Y/N)
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "f" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "f" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "o" | $80 ;               ; 
                            .byte "f" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "(" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte ")" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_GetCommandChar          ; get a command char from player
                            
                            cmp #$19                        ; test "Y"
                            bne BED_ScoreClearX             ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderunner disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            
                            cmp #LR_ScoreBufCheck_Bad       ; test no loderunnner disk ID found
                            beq ErrorMsgDiskUnknown         ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; clear leaderboard buffer entries
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get leaderboard entries offset
                            ldy #LR_ScoreBufTable_Len + $2f ; get HI scores buffer length plus some extra
ClearNextEntryByte          sta LR_ScoreBuf,y               ; set clear byte
                            
                            dey                             ; dec leaderboard entries offset
                            bpl ClearNextEntryByte          ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; write fresh leaderboard to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskWrite               ; get flag write block to disk
                            jsr ScoreDiskHandler            ; write out the leaderboard block
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
ErrorMsgDiskUnknown         jsr BED_ErrorMsgDiskUnknown     ; write out error message no loderunner data disk
                            
BED_ScoreClearX             jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_Start                 Does    : level editor: start
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_Start                  .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            jsr BED_CheckDiskType           ; check loderunner user data disk
                            
                            lda #HR_CYAN_RED                ; get hires color
                            jsr ColorLevel                  ; fill game level screen with the selected colors
                            
                            lda #>LR_ScreenGfxPrepare       ; get gfx prepare screen
                            sta LRZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag level data not modified
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #LRZ_LevelModified_No       ; get flag level data not modified
                            stx LRZ_LevelModified           ; ini edit status
; --------------------------------------------------------------------------------------------------------------------- ;
; reinit level without reload from disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            dex                             ; set flag LR_LevelLoad_No
                            jsr GameLevelDataExpand         ; expand compressed level disk data
                            bcc IniCursorHome               ; check: successful - yes
                            
                            jmp BED_CommandError            ; error beep and wait for next command
; --------------------------------------------------------------------------------------------------------------------- ;
IniCursorHome               lda #$00                        ; get initial value
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_GetKey                Does    : level editor: check input key for a valid tile number or a valid level editor command
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_GetKey                 .block                           ;
WaitNextPlayerInputKey      jsr LED_WaitForInput            ; set data pointer/blink cursor/wait for input
; --------------------------------------------------------------------------------------------------------------------- ;
; get a level tile number $00-$09
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_CheckInputDigit         ; check if key pressed is a digit
                            bcs CheckLevelEditorCmd         ; check: was digit - no: might be an level editor command
; --------------------------------------------------------------------------------------------------------------------- ;
; save a valid level tile number $00-$09
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta LRZ_ImageNumber             ; save level input tile $00-$09
; --------------------------------------------------------------------------------------------------------------------- ;
; get level data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check if level data is same than input tile number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScreenCol               ; get screen col ($00-$1b)
                            lda LRZ_ImageNumber             ; get level input tile $00-$09
                            eor (LRZ_LevelDataGamePtrRow),y ; unpacked level data ($0800-$09c3)
                            beq SetLevelTile                ; check: same as input data - yes: do not set modify flag
; --------------------------------------------------------------------------------------------------------------------- ;
; set flag level data was modified
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr LRZ_LevelModified           ; set LRZ_LevelModified_Yes 
; --------------------------------------------------------------------------------------------------------------------- ;
; store input tile number to level data
; --------------------------------------------------------------------------------------------------------------------- ;
SetLevelTile                lda LRZ_ImageNumber             ; get level input tile $00-$09
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            jmp WaitNextPlayerInputKey      ; wait for next key
; --------------------------------------------------------------------------------------------------------------------- ;
; input might be a level editor command
; --------------------------------------------------------------------------------------------------------------------- ;
CheckLevelEditorCmd         sta LRZ_ImageNumber             ; set level input tile $00-$09
                            
                            ldy #$ff                        ; preset -1 to allow pre loop inc
SetNextLevelEditorCmdOff    iny                             ; 
                            lda TabLED_CmdChar,y            ; get next command char table entry
                            beq LED_BeepBadInput            ; check: EoT - yes: beep and wait for next input
                            
                            cmp LRZ_ImageNumber             ; test with input char
                            bne SetNextLevelEditorCmdOff    ; check: EQ - no: not a cmd - continue
; --------------------------------------------------------------------------------------------------------------------- ;
; input was a level editor command - dispatch the appropriate sub-routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; 
                            asl a                           ; *2
                            tay                             ; 
                            
                            lda TabLED_CmdAddress + $01,y   ; get address command routine HI
                            pha                             ; push to stack
                            lda TabLED_CmdAddress + $00,y   ; get address command routine LO
                            pha                             ; push to stack
                            
                            rts                             ; dispatch command routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_BeepBadInput          Does    : level editor: error beep
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_BeepBadInput           .block                           ; 
                            jsr EditorErrorBeep             ; output an error beep signal
                            jmp LED_GetKey                  ; check input key for a valid tile number or a valid level editor command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorUp              Does    : level editor: step cursor up
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorUp               .block                           ; 
                            lda LRZ_ScreenRow               ; get screen row ($00-$0f)
                            beq LED_BeepBadInput            ; check: max up reached - yes: beep and wait for next input
                            
                            dec LRZ_ScreenRow               ; dec screen row ($00-$0f)
                            bpl LED_GetKey                  ; always - check input key for a valid tile number or a valid level editor command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorLeft            Does    : level editor: step cursor left
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorLeft             .block                           ; 
                            lda LRZ_ScreenCol               ; get screen col ($00-$1b)
                            beq LED_BeepBadInput            ; check: max left reached - yes: beep and wait for next input
                            
                            dec LRZ_ScreenCol               ; dec screen col ($00-$1b)
                            bpl LED_GetKey                  ; always - check input key for a valid tile number or a valid level editor command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorRight           Does    : level editor: step cursor right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorRight            .block                           ; 
                            lda LRZ_ScreenCol               ; get screen col ($00-$1b)
                            cmp #LRZ_ScreenCol_Max          ; test max col
                            bcs LED_BeepBadInput            ; check: GE - yes: beep and wait for next input
                            
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            bne LED_GetKey                  ; always - check input key for a valid tile number or a valid level editor command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CursorDown            Does    : level editor: step cursor down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CursorDown             .block                           ; 
                            lda LRZ_ScreenRow               ; get screen row ($00-$0f)
                            cmp #LRZ_ScreenRow_Max          ; test max row
                            bcs LED_BeepBadInput            ; check: GE - yes: beep and wait for next input
                            
                            inc LRZ_ScreenRow               ; inc screen row ($00-$0f)
                            bne LED_GetKey                  ; always - check input key for a valid tile number or a valid level editor command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelSaveHandler      Does    : level editor: save the edited level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelSaveHandler       .block                           ; 
                            lda LRZ_ScreenRow               ; get screen row ($00-$0f)
                            pha                             ; 
                            lda LRZ_ScreenCol               ; get screen col ($00-$1b)
                            pha                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; read in loderunner score block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read in the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderuner disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_ScoreBufCheck_Bad       ; test no loderunnner disk ID found
                            bne CheckUserLevelDisk          ; check: EQ - no
                            
                            jsr BED_ErrorMsgDiskUnknown     ; write out error message no loderunner data disk
                            jmp SetCursorHome               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CheckUserLevelDisk          cmp #LR_ScoreBufCheck_Mod_No    ; test disk is not a master disk
                            bne CompressLevelDataAndStore   ; check: EQ - no: compress and store
                            
                            jsr BED_ErrorMsgDiskMaster      ; write out error message loderunner master disk
                            jmp SetCursorHome               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CompressLevelDataAndStore   jsr GameLevelDataCompress       ; compress level data and store to disk
; --------------------------------------------------------------------------------------------------------------------- ;
; restore cursor position
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; 
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            pla                             ; 
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda #LRZ_LevelModified_No       ; get flag level data not modified
                            sta LRZ_LevelModified           ; set edit status
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetCursorHome               lda #$00                        ; get top left corner
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jmp LED_GetKey                  ; check input key for a valid tile number or a valid level editor command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelSave             Does    : level editor: save level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelSave              .block                           ; 
                            jsr LED_LevelSaveHandler        ; save the edited level
                            jmp LED_GetKey                  ; check input key for a valid tile number or a valid level editor command
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
;  LED_LevelNext            Does    : level editor: edit next level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelNext              .block                           ; 
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            cmp #LR_LevelNumDisk_Max        ; test max passed
ErrorBeep                   beq LED_BeepBadInput            ; check: EQ - yes: beep and wait for next input
                            
                            jsr LED_CheckLevelModified      ; check if level was modified and ask for acknowlege
                            
                            inc LR_LevelNumDisk             ; inc disk level number 000-149
                            inc LR_LevelNumGame             ; inc game level number 001-150
                            
                            jmp LED_Start                   ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_LevelPrev             Does    : level editor: edit previous level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_LevelPrev              .block                           ; 
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            beq LED_LevelNext.ErrorBeep     ; check: LR_LevelNumDiskMin - yes: error beep
                            
                            jsr LED_CheckLevelModified      ; check if level was modified and ask for acknowlege
                            
                            dec LR_LevelNumGame             ; dec game level number 001-150
                            dec LR_LevelNumDisk             ; dec disk level number 000-149
                            
                            jmp LED_Start                   ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_Quit                  Does    : level editor: quit
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_Quit                   .block                           ; 
                            jsr LED_CheckLevelModified      ; check if level was modified and ask for acknowlege
                            jmp BED_InitScreen              ; clear screen and init the board editor
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_CheckLevelModified    Does    : level editor: check if level was modified and ask for acknowlege
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_CheckLevelModified     .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_LevelModified           ; get edit status
                            beq LevelWasModified            ; check: level data modified - yes
                            
                            rts                             ; not modified - nothing to say - exit
; --------------------------------------------------------------------------------------------------------------------- ;
LevelWasModified            jsr ScreenDisplayClear          ; clear display grafic screen
; --------------------------------------------------------------------------------------------------------------------- ;
; save actual level color
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda ColorLevel.ssHiresColor     ; get actual hires color
                            pha                             ; save actual hires color
; --------------------------------------------------------------------------------------------------------------------- ;
; recolor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #HR_YELLOW_CYAN             ; get msg hires color
                            jsr ColorLevel                  ; fill game level screen with the selected colors
                            
                            lda #>LR_ScreenGfxDisplay       ; get gfx display screen
                            sta LRZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home to top left corner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "l" | $80 ;               ; LEVEL HAS BEEN CHANGED BUT
                            .byte "e" | $80 ;               ; NOT SAVED. DO YOU WISH TO
                            .byte "v" | $80 ;               ; SAVE MODIFIED LEVEL (Y/N)
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "h" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "b" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "b" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "n" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "y" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "w" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "s" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "m" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "f" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "(" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte "/" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte ")" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EditorErrorBeep             ; output an error beep signal
                            
GetNextBlankUnderCursor     lda #LRZ_ImageNumber_Blank      ; get 
                            jsr BED_CursorBlink             ; wait for input key and blink cursor
; --------------------------------------------------------------------------------------------------------------------- ;
; clear input
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #LR_KeyNew_None             ; get initial value
                            stx LR_KeyNew                   ; ini new key input
; --------------------------------------------------------------------------------------------------------------------- ;
; check input for Yes/No
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$27                        ; test "N"
                            beq RestoreScreenColors         ; check: EQ - yes: exit
                            
                            cmp #$19                        ; test "Y"
                            bne GetNextBlankUnderCursor     ; check: EQ - no: exit
                            
                            jsr LED_LevelSaveHandler        ; save the edited level
; --------------------------------------------------------------------------------------------------------------------- ;
; restore old colors
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreScreenColors         pla                             ; restore hires color
                            jmp ColorLevel                  ; fill game level screen with the selected colors
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CheckDiskType         Does    : check if disk is a loderunner data disk and if it is modifiable then
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CheckDiskType          .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskRead                ; get flag read block from disk
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            
                            cmp #LR_ScoreBufCheck_Bad       ; test no loderunnner disk ID found
                            bne ChkDiskModifiable           ; check: EQ - no: check if modifiable
                            
                            jsr BED_ErrorMsgDiskUnknown     ; write out error message no loderunner data disk
                            jmp BED_InitScreen              ; clear screen and init the board editor
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDiskModifiable           cmp #LR_ScoreBufCheck_Mod_No    ; test disk is not a master disk
                            bne BED_CheckDiskTypeX          ; check: EQ - no: good end
                            
                            jsr BED_ErrorMsgDiskMaster      ; write out error message loderunner master disk
                            jmp BED_InitScreen              ; clear screen and init the board editor
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CheckDiskTypeX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_ErrorMsgDiskMaster    Does    : write out error message loderunner master disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_ErrorMsgDiskMaster     .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
; --------------------------------------------------------------------------------------------------------------------- ;
; save actual screen colr
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda ColorLevel.ssHiresColor     ; get actual hires color
                            pha                             ; save actual hires color
                            
                            lda #>LR_ScreenGfxDisplay       ; get gfx display screen
                            sta LRZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            lda #HR_YELLOW_CYAN             ; get msg hires color
                            jsr ColorLevel                  ; fill game level screen with the selected colors
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home to top left corner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "u" | $80 ;               ; USER NOT ALLOWED TO
                            .byte "s" | $80 ;               ; MANIPULATE MASTER DISKETTE.
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "n" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "w" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "m" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "p" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "m" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_MsgHitAnyKey          Does    : board editor: wait for key after info message
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_MsgHitAnyKey           .block                           ; 
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "h" | $80 ;               ; HIT A KEY TO CONTINUE
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "y" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "t" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EditorErrorBeep             ; output an error beep signal
                            
                            lda #LRZ_ImageNumber_Blank      ; get blank chr under cursor
                            jsr BED_CursorBlink             ; wait for input key and blink cursor
; --------------------------------------------------------------------------------------------------------------------- ;
; init key input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_KeyNew_None             ; get initial value
                            sta LR_KeyNew                   ; ini new key input
; --------------------------------------------------------------------------------------------------------------------- ;
; update status row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>LR_ScreenGfxPrepare       ; get gfx prepare screen
                            sta LRZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
; --------------------------------------------------------------------------------------------------------------------- ;
; keep disk level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_LevelLoad_No            ; get flag do not load level from disk
                            sta LR_LevelLoad                ; level disk load control - reinit level without reload from disk
; --------------------------------------------------------------------------------------------------------------------- ;
; care for hidden ladders/trap doors/gold/enemies/loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LevelSpecialTileHandler     ; handle special level tiles and set up prepare gfx screen
; --------------------------------------------------------------------------------------------------------------------- ;
; restore screen colors
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore old hires color
                            jmp ColorLevel                  ; fill game level screen with the selected colors
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_ErrorMsgDiskUnknown   Does    : write out disk in drive is not a loderunner datta disk error message
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_ErrorMsgDiskUnknown    .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda ColorLevel.ssHiresColor     ; get actual hires color
                            pha                             ; 
                            
                            lda #HR_YELLOW_CYAN             ; get hires color
                            jsr ColorLevel                  ; fill game level screen with the selected colors
                            
                            lda #>LR_ScreenGfxDisplay       ; get gfx display screen
                            sta LRZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home to top left corner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "d" | $80 ;               ; DISKETTE IN DRIVE IS NOT A
                            .byte "i" | $80 ;               ; LODE RUNNER DATA DISK.
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "n" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "a" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "d" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte "k" | $80 ;               ; 
                            .byte "." | $80 ;               ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp BED_MsgHitAnyKey            ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LED_WaitForInput          Does    : level editor: set the data pointer to screen row/col
;                                   :               blink the cursor and wait for input
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LED_WaitForInput           .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy LRZ_ScreenCol               ; get screen col ($00-$1b)
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            
                            jsr BED_CursorBlink             ; wait for input key and blink cursor
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; level editor commands
; --------------------------------------------------------------------------------------------------------------------- ;
TabLED_CmdChar              = *       ; level editor commands
                            .byte $22 ; j - Move Cursor Left
                            .byte $21 ; i - Move Cursor Up
                            .byte $25 ; k - Move Cursor Right
                            .byte $24 ; m - Move Cursor Down
                            .byte $8d ; S - Save
                            .byte $95 ; F - Move a Level Forward
                            .byte $9c ; B - Move a Level Backward
                            .byte $be ; Q - Quit
                            
                            .byte $00 ; end of command table marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabLED_CmdAddress           = * ; level editor command routines
                            .word LED_CursorLeft  - $01 ; 
                            .word LED_CursorUp    - $01 ; 
                            .word LED_CursorRight - $01 ; 
                            .word LED_CursorDown  - $01 ; 
                            .word LED_LevelSave   - $01 ; 
                            .word LED_LevelNext   - $01 ; 
                            .word LED_LevelPrev   - $01 ; 
                            .word LED_Quit        - $01 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelNumberGet        Does    : board editor: get a level number
;                           Expects : 
;                           Returns : .C=0 - OK
;                                   : .C=1 - error
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelNumberGet         .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; convert disk level number previously played to digits
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LR_LevelNumDisk             ; get disk level number 000-149
                            iny                             ; make it a game level number
                            tya                             ; get value to be converted
                            jsr ConvertHexToDec             ; result in LR_Digit_100/LR_Digit_10/LR_Digit_1
                            
                            lda LRZ_ScreenCol               ; get screen col ($00-$1b)
                            sta TabBED_SaveCurrentScreenCol ; save screen col
; --------------------------------------------------------------------------------------------------------------------- ;
; output converted disk level number parts to the status row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset to converted level numbers
GetNextConvLvlvNum          lda LR_Digit,y                  ; get converted level number 100/10/1 part
                            
                            sty TabBED_SaveConvLevelNumOff  ; save offset to converted level numbers
                            
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            ldy TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            iny                             ; inc offset to converted level numbers
                            cpy #$03                        ; test max bypassed
                            bcc GetNextConvLvlvNum          ; check: LT - yes: limit not reached - continue
; --------------------------------------------------------------------------------------------------------------------- ;
; restore screen column
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabBED_SaveCurrentScreenCol ; get saved screen col
                            sta LRZ_ScreenCol               ; restore screen col ($00-$1b)
                            
                            ldy #$00                        ; ini offset to converted level numbers
                            sty TabBED_SaveConvLevelNumOff  ; set offset to converted level numbers
                            
GetNextLevelNumOff          ldx TabBED_SaveConvLevelNumOff  ; get converted level number offset
                            lda LR_Digit,x                  ; get 100/10/1 parts
                            clc                             ; 
                            adc #LRZ_ImageNumber_Digit      ; make it a digit image
                            jsr BED_CursorBlink             ; wait for input key and blink cursor
; --------------------------------------------------------------------------------------------------------------------- ;
; check if input was a digit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr BED_CheckInputDigit         ; check if key pressed is a digit
                            bcc DisplayInputDigit           ; check: was digit - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if input was a <RETURN>
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$01                        ; test <RETURN>
                            beq BED_LevelNumberToBin        ; check: EQ - yes: done - convert to binary level number
; --------------------------------------------------------------------------------------------------------------------- ;
; check if input was a cursor move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$07                        ; test <CURSOR_UP>
                            beq GetLevelNumOff              ; check: EQ - yes
                            
                            cmp #$82                        ; test <CURSOR_LEFT>
                            bne ChkCursorRight              ; check: EQ - no
                            
GetLevelNumOff              ldx TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            beq BeepBadInput                ; check: at left border of digit display - yes: beep and wait for next input
; --------------------------------------------------------------------------------------------------------------------- ;
; move digit display cursor one position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabBED_SaveConvLevelNumOff  ; dec offset to converted level numbers
                            dec LRZ_ScreenCol               ; dec screen col ($00-$1b)
                            jmp GetNextLevelNumOff          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCursorRight              cmp #$02                        ; test <CURSOR_RIGHT>
                            bne ChkRunStop                  ; check: EQ - no
                            
                            ldx TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            cpx #$02                        ; test right border
                            beq BeepBadInput                ; check: EQ - yes: beep and wait for next input
; --------------------------------------------------------------------------------------------------------------------- ;
; move digit display cursor one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            inc TabBED_SaveConvLevelNumOff  ; inc offset to converted level numbers
                            jmp GetNextLevelNumOff          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkRunStop                  cmp #$3f                        ; test <RUN/STOP>
                            bne ChkInputDigit               ; check: EQ - no: check if input was a digit
; --------------------------------------------------------------------------------------------------------------------- ;
; was <RUN/STOP> - level number input interrupted - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
ChkInputDigit               jsr BED_CheckInputDigit         ; check if key pressed is a digit
                            bcs BeepBadInput                ; check: was digit - no: beep and wait for next input
; --------------------------------------------------------------------------------------------------------------------- ;
; input was a digit - display at cursor position
; --------------------------------------------------------------------------------------------------------------------- ;
DisplayInputDigit           ldy TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            sta LR_Digit,y                  ; set update digit under screen pos - 100/10/1 parts
                            
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            inc TabBED_SaveConvLevelNumOff  ; inc offset to converted level numbers
                            lda TabBED_SaveConvLevelNumOff  ; get offset to converted level numbers
                            cmp #$03                        ; test passed right border
                            bcc GetNextLevelNumOff          ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; reset digit display cursor to rightmost position
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabBED_SaveConvLevelNumOff  ; dec offset to converted level numbers
                            dec LRZ_ScreenCol               ; dec screen col ($00-$1b)
                            jmp GetNextLevelNumOff          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
BeepBadInput                jsr EditorErrorBeep             ; output an error beep signal
                            jmp GetNextLevelNumOff          ; wait for next input
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_LevelNumberToBin      Does    : create a binary level number from level number input
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_LevelNumberToBin       .block                           ; 
                            lda TabBED_SaveCurrentScreenCol ; get save screen col
                            clc                             ; 
                            adc #$03                        ; add offset rightmost digit
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda #$00                        ; ini result
; --------------------------------------------------------------------------------------------------------------------- ;
; count 100s
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LR_Digit_100                ; get digit 100 part
                            beq Count10s                    ; check: had one - no: count 10s
                            
                            clc                             ; 
AddNext100                  adc #$64                        ; 100
                            bcs BED_LevelNumberToBinX       ; check: overflow - yes: done - exit
                            
                            dex                             ; dec digit 100 part
                            bne AddNext100                  ; check: min - no: continue add 100
; --------------------------------------------------------------------------------------------------------------------- ;
; count 10s
; --------------------------------------------------------------------------------------------------------------------- ;
Count10s                    ldx LR_Digit_10                 ; get digit 10 part
                            beq Add1s                       ; check: had one - no: add 1s
                            
                            clc                             ; 
AddNext10                   adc #$0a                        ; 10
                            bcs BED_LevelNumberToBinX       ; check: overflow - yes: done - exit
                            
                            dex                             ; dec digit 10 part
                            bne AddNext10                   ; check: min - no: continue add 10
; --------------------------------------------------------------------------------------------------------------------- ;
; add 1s
; --------------------------------------------------------------------------------------------------------------------- ;
Add1s                       clc                             ; 
                            adc LR_Digit_1                  ; digit 1 part
                            bcs BED_LevelNumberToBinX       ; check: overflow - yes: something went wrong
; --------------------------------------------------------------------------------------------------------------------- ;
; store level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta LR_LevelNumGame             ; set game level number 001-150
; --------------------------------------------------------------------------------------------------------------------- ;
; store disk level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; get game level number
                            dey                             ; disk level number starts at 000
                            sty LR_LevelNumDisk             ; set disk level number 000-149
; --------------------------------------------------------------------------------------------------------------------- ;
; .C=0 - .Y <  LR_LevelNumGame_Max
; .C=1 - .Y >= LR_LevelNumGame_Max
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #LR_LevelNumGame_Max        ; test 150
                            
BED_LevelNumberToBinX       rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_GetCommandChar        Does    : board editor: get a command char from player
;                           Expects : 
;                           Returns : .A=command char
; --------------------------------------------------------------------------------------------------------------------- ;
BED_GetCommandChar         .block                           ; 
                            lda #LRZ_ImageNumber_Blank      ; get blank chr under cursor
                            jsr BED_CursorBlink             ; wait for input key and blink cursor
                            
                            ldx #LR_KeyNew_None             ; get initial value
                            stx LR_KeyNew                   ; ini new key input
                            
                            cmp #$3f                        ; test <RUN/STOP>
                            bne BED_GetCommandCharX         ; check: EQ - no: return command char
; --------------------------------------------------------------------------------------------------------------------- ;
; command char input interrupted - get a new one
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp BED_CommandCheck            ; test valid command input and exec the appropriate routine
; --------------------------------------------------------------------------------------------------------------------- ;
BED_GetCommandCharX         rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSaveLeaderboardOffId     = *       ; offset input new leaderboard entry ID
TabBED_SaveConvLevelNumOff  .byte $00 ; offset to converted level numbers
TabBED_SaveCurrentScreenCol .byte $00 ; 
TabBED_SaveMoveLevelSource  .byte $00 ; 
TabBED_SaveMoveLevelTarget  .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CheckInputDigit       Does    : board editor: check input char for a digit
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CheckInputDigit        .block                           ; 
                            lda LR_KeyNew                   ; get actual key
                            
                            ldy #LR_KeyNew_None             ; get initial value
                            sty LR_KeyNew                   ; ini new key input
                            
                            ldy #TabBED_KeyDigit_Len - $01  ; get length digit key tab
ChkNextDigitTabEntry        cmp TabBED_KeyDigit,y           ; test key entered is a digit
                            beq WasDigit                    ; check: EQ - yes
                            
                            dey                             ; dec length digit key tab
                            bpl ChkNextDigitTabEntry        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; input char was not a digit
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; flag: input was no digit
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; input char was a digit
; --------------------------------------------------------------------------------------------------------------------- ;
WasDigit                    tya                             ; get digit replacement (rank)
                            clc                             ; flag: input was a digit
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabBED_KeyDigit             = *       ; 
                            .byte $23 ; 0
                            .byte $38 ; 1
                            .byte $3b ; 2
                            .byte $08 ; 3
                            .byte $0b ; 4
                            .byte $10 ; 5
                            .byte $13 ; 6
                            .byte $18 ; 7
                            .byte $1b ; 8
                            .byte $20 ; 9
TabBED_KeyDigit_Len         = * - TabBED_KeyDigit ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabLodeRuDiskId             = *       ; 
                            .byte $c4 ; D
                            .byte $c1 ; A
                            .byte $ce ; N
                            .byte $c5 ; E
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte $c2 ; B
                            .byte $c9 ; I
                            .byte $c7 ; G
                            .byte $c8 ; H
                            .byte $c1 ; A
                            .byte $cd ; M
TabLodeRuDiskId_Len         = * - TabLodeRuDiskId - $01
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreEntryHandler         Does    : check if the gamer score is worth an entry on the leaderboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreEntryHandler          .block                           ; 
                            lda LR_Cheated                  ; get flag cheated
                            beq ScoreEntryHandlerX          ; check: LR_Cheated_Yes - yes: no leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
; check zero score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_Score_Lo                 ; combine score bytes
                            ora LR_Score_MidLo              ; 
                            ora LR_Score_MidHi              ; 
                            ora LR_Score_Hi                 ; 
                            beq ScoreEntryHandlerX          ; check: all zero - yes: no leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
; read in leaderbord block from disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskRead                ; get flag read score from disk
                            jsr ScoreDiskHandler            ; read in the leaderboard block
                            beq ScoreEntryHandlerX          ; check: LR_ScoreBufCheck_Bad - yes: no leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
; copy leaderboard entries to work buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset
GetNextDiskScoreByte        lda LR_ScoreBuf,y               ; get disk block data
                            sta LR_ScoreBufWork,y           ; set work buffer data
                            
                            iny                             ; inc offset
                            bne GetNextDiskScoreByte        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; test if the score reached qualifies for a new leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$01                        ; get entry count - start with entry one
GetNextScoreBufferOff       ldx TabScoreBufEntryOff,y       ; get score buffer entry offset
                            
                            lda LR_LevelNumGame             ; get game level number 001-150
                            cmp LR_ScoreBufLevel,x          ; test score board entry - level
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda LR_Score_Hi                 ; get score HI
                            cmp LR_ScoreBufValue_Hi,x       ; test score board entry - score HI
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda LR_Score_MidHi              ; get score MID HI
                            cmp LR_ScoreBufValue_Mid_Hi,x   ; test score board entry - score MID HI
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda LR_Score_MidLo              ; get score MID LO
                            cmp LR_ScoreBufValue_Mid_Lo,x   ; test score board entry - score MID LO
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
                            lda LR_Score_Lo                 ; get score LO
                            cmp LR_ScoreBufValue_Lo,x       ; test score board entry - score LO
                            bcc IncScoreEntryCount          ; check: LT - yes: set next entry
                            bne ScoreEntryNew               ; check: EQ - no: higher/not equal - new entry
                            
IncScoreEntryCount          iny                             ; inc entry count
                            cpy #LR_ScoreBufEntry_Max + $01 ; test max score entries
                            bcc GetNextScoreBufferOff       ; check: max reached - no: continue
                            
ScoreEntryHandlerX          rts                             ; exit no new leaderboard entry
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreEntryNew             Does    : insert the new gamer score into the leaderboard
;                           Expects : .Y=leaderboard entry number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreEntryNew              .block                           ; 
                            cpy #LR_ScoreBufEntry_Max       ; test bottom of scrore entries
                            beq GetNewScorerIdChars         ; check: EQ - yes: no insertion for enry 10 - simply overwrite
                            
                            sty LRZ_ScoreBoardOff           ; set number of new entry
; --------------------------------------------------------------------------------------------------------------------- ;
; open a score buffer slot for insertion of the new candidate
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #LR_ScoreBufEntry_Max - $01 ; get max entries to move
GetNextScoreEntryOff        ldx TabScoreBufEntryOff,y       ; get score buffer entry offset
                            lda #LR_ScoreBufEntry_Len       ; get score buffer entry length
                            sta LRZ_WorkScoreEntryLen       ; set entry length
; --------------------------------------------------------------------------------------------------------------------- ;
; free a buffer entry for insertion by moving the entries one position down
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSourceByte           lda LR_ScoreBufEntryFrom,x      ; get source
                            sta LR_ScoreBufEntryTo,x        ; set target - move data one position down
                            
                            inx                             ; inc score buffer entry row offset
                            dec LRZ_WorkScoreEntryLen       ; dec score buffer entry length
                            bne GetNextSourceByte           ; check: entry length min - no: continue
                            
                            cpy LRZ_ScoreBoardOff           ; test with number of new entry
                            beq GetNewScorerIdChars         ; check: EQ - yes: target pos reached - done
                            
                            dey                             ; dec max number of score buffer entries
                            bne GetNextScoreEntryOff        ; check: min - no: move next entry
; --------------------------------------------------------------------------------------------------------------------- ;
; insert new scorers data
; --------------------------------------------------------------------------------------------------------------------- ;
; clear scorer id
; --------------------------------------------------------------------------------------------------------------------- ;
GetNewScorerIdChars         ldx TabScoreBufEntryOff,y       ; get score buffer entry offset
                            lda #$a0                        ; get <SHIFT_SPACE>
                            sta LR_ScoreBufID_Char1,x       ; ini player id char 1
                            sta LR_ScoreBufID_Char2,x       ; ini player id char 2
                            sta LR_ScoreBufID_Char3,x       ; ini player id char 3
; --------------------------------------------------------------------------------------------------------------------- ;
; insert level number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LevelNumGame             ; get game level number 001-150
                            sta LR_ScoreBufLevel,x          ; set level
; --------------------------------------------------------------------------------------------------------------------- ;
; insert new score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_Score_Hi                 ; get score HI
                            sta LR_ScoreBufValue_Hi,x       ; set score HI
                            
                            lda LR_Score_MidHi              ; get score MID HI
                            sta LR_ScoreBufValue_Mid_Hi,x   ; set score MID HI
                            
                            lda LR_Score_MidLo              ; get score MID LO
                            sta LR_ScoreBufValue_Mid_Lo,x   ; set score MID LO
                            
                            lda LR_Score_Lo                 ; get score LO
                            sta LR_ScoreBufValue_Lo,x       ; set score LO
; --------------------------------------------------------------------------------------------------------------------- ;
; init fetch of new initials
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty LRZ_WorkScoreNewEntryNum    ; save number of new entry
                            
                            lda TabScoreBufEntryOff,y       ; get score buffer entry offset
                            sta smLeaderboardIdOff_In       ; set input entry offset
                            sta smLeaderboardIdOff_Out      ; set output entry offset
                            
                            jsr ScoreShowLeaderboard        ; show leaderboard
; --------------------------------------------------------------------------------------------------------------------- ;
; get board entry row number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_WorkScoreNewEntryNum    ; restore number of new entry
                            clc                             ; 
                            adc #LR_BoardHeaderRows         ; add number of header rows
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; get board entry column number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_BoardEntryCol_Id        ; get start col initials
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            ldx #$00                        ; get initial value
                            stx TabSaveLeaderboardOffId     ; ini offset to input ID of new board entry
                            
GetNextLeaderboardOffId     ldx TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
smLeaderboardIdOff_In       = * + $01                       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; wait for player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_ScoreBuf,x               ; get 1st scorer ID char
                            jsr TextCharPrepare             ; prepare and substitute char for output
                            jsr BED_CursorBlink             ; wait for input key and blink cursor
                            
                            ldx #LR_KeyNew_None             ; get inital value
                            stx LR_KeyNew                   ; ini new key input
                            
                            jsr InputKeySubstitute          ; get a leaderbord scorer ID char substitution
; --------------------------------------------------------------------------------------------------------------------- ;
; check for legal control chars
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #$8d                        ; test <ENTER>
                            beq WriteNewLeaderboardToDisk   ; check: EQ - yes: finished - write to disk
                            
                            cmp #$88                        ; test <CURSOR_LEFT>
                            bne ChkCursorRight              ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; test input cursor position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
                            beq BeepWrongInput              ; check: left border reached - yes: error beep
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor one position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabSaveLeaderboardOffId     ; dec offset to input ID of new board entry
                            dec LRZ_ScreenCol               ; dec screen col ($00-$1b)
                            jmp GetNextLeaderboardOffId     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCursorRight              cmp #$95                        ; test <CURSOR_RIGHT>
                            bne CheckScoreIdChar            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; test input cursor position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
                            cpx #LR_BoardEntryCol_Id_Len    ; test max right
                            beq BeepWrongInput              ; check: max right - yes: error beep
; --------------------------------------------------------------------------------------------------------------------- ;
; move input cursor one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            inc TabSaveLeaderboardOffId     ; inc offset to input ID of new board entry
                            jmp GetNextLeaderboardOffId     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check for legal special chars
; --------------------------------------------------------------------------------------------------------------------- ;
CheckScoreIdChar            cmp #$ae                        ; test "."
                            beq ShowScorerIdChar            ; check: EQ - yes: display it
                            
                            cmp #$a0                        ; test <SHIFT_SPACE>
                            beq ShowScorerIdChar            ; check: EQ - yes: display it
                            
                            cmp #$c1                        ; test "A"
                            bcc BeepWrongInput              ; check: LT - yes: error beep
                            
                            cmp #$db                        ; test "Z" + 1
                            bcs BeepWrongInput              ; check: GE - yes: error beep
; --------------------------------------------------------------------------------------------------------------------- ;
; output id char entered
; --------------------------------------------------------------------------------------------------------------------- ;
ShowScorerIdChar            ldy TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
smLeaderboardIdOff_Out      = * + $01                       ; 
                            sta LR_ScoreBuf,y               ; set store typed chr into score initials area
                            
                            jsr TextOutCharHandler          ; control the output of a single char
; --------------------------------------------------------------------------------------------------------------------- ;
; advance cursor
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabSaveLeaderboardOffId     ; inc offset to input ID of new board entry
                            lda TabSaveLeaderboardOffId     ; get offset to input ID of new board entry
                            cmp #LR_BoardEntryCol_Id_Len + $01 ; test max right
                            bcc GetNextLeaderboardOffId     ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; correct cursor position to right border
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec TabSaveLeaderboardOffId     ; dec offset to input ID of new board entry
                            dec LRZ_ScreenCol               ; dec screen col ($00-$1b)
                            jmp GetNextLeaderboardOffId     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
BeepWrongInput              jsr EditorErrorBeep             ; output an error beep signal
                            jmp GetNextLeaderboardOffId     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; prevent updated leaderboard from being overwritten
; --------------------------------------------------------------------------------------------------------------------- ;
WriteNewLeaderboardToDisk   ldy #$00                        ; ini offset
GetNextNewScoreByte         lda LR_ScoreBuf,y               ; get score disk block data
                            sta LR_ScoreBufWorkNew,y        ; set score work buffer data
                            
                            iny                             ; inc offset
                            bne GetNextNewScoreByte         ; check: max - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; get leaderboard from disk with check
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskRead                ; get flag read score from disk
                            jsr ScoreDiskHandler            ; read in the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
; copy leaderboard data back - prevent manipulations
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini offset
GetNextSaveScoreByte        lda LR_ScoreBuf,y               ; get new leaderboard byte from save buffer
                            cmp LR_ScoreBufWork,y           ; test with leaderboard work bffer
                            bne ScoreEntryNewX              ; check: EQ - no: manipulated - exit
                            
                            lda LR_ScoreBufWorkNew,y        ; get new leaderboard byte
                            sta LR_ScoreBuf,y               ; set disk leaderboard byte
                            
                            iny                             ; inc offset
                            bne GetNextSaveScoreByte        ; check: max - no: continue
                            
                            lda #LR_DiskWrite               ; get flag write block to disk
                            jsr ScoreDiskHandler            ; write out the leaderboard block
                            
ScoreEntryNewX              jmp GameOver.DemoWaitInit       ; init wait for demo
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreShowLeaderboard      Does    : show the leaderboard of 10 entries
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreShowLeaderboard       .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            
                            lda #HR_YELLOW_CYAN             ; get leaderboard hires color
                            jsr ColorLevel                  ; fill game level screen with the selected colors
; --------------------------------------------------------------------------------------------------------------------- ;
; set cursor home
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ;    LODE RUNNER HIGH SCORES
                            .byte " " | $80 ; <SHIFT_SPACE> ;     INITIALS LEVEL SCORE
                            .byte " " | $80 ; <SHIFT_SPACE> ;     -------- ----- -----
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "d" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "r" | $80 ;               ; 
                            .byte "u" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "h" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "g" | $80 ;               ; 
                            .byte "h" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "i" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "t" | $80 ;               ; 
                            .byte "i" | $80 ;               ; 
                            .byte "a" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte "s" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "s" | $80 ;               ; 
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte "-" | $80 ;               ; 
                            .byte CR  | $80 ; <RETURN>      ; <NL>
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get initial value
                            sta LRZ_ScoreBoardRank          ; ini actual rank
                            
ScoreNextEntryOut           cmp #$0a                        ; test 10th entry
                            bne ShowEntryLowerTen           ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; rank 10 starts with a "1"
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$01                        ; get 1 - start rank 10 with a "1"
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda #$00                        ; get 0 - continue rank 10 with a "0"
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            jmp ScoreRowHeaderOut           ; output the header
; --------------------------------------------------------------------------------------------------------------------- ;
; rank digits 1-9 start with a blank
; --------------------------------------------------------------------------------------------------------------------- ;
ShowEntryLowerTen           lda #$a0                        ; rank 1-9 - start with <SHIFT_SPACE>
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            lda LRZ_ScoreBoardRank          ; get actual rank
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
ScoreRowHeaderOut           jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
; score row header
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "." | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ScoreBoardRank          ; get actual rank
                            ldy TabScoreBufEntryOff,x       ; get score buffer entry offset
                            sty LRZ_ScoreBoardOff           ; set score board offset
                            
                            lda LR_ScoreBufLevel,y          ; get level number
                            bne ScoreRowInitials            ; check: zero - no: show scorer initials
                            
                            jmp ScoreSetNextEntry           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; output top scorer ID
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreRowInitials            ldy LRZ_ScoreBoardOff           ; get score board offset
                            lda LR_ScoreBufID_Char1,y       ; get player id char 1
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            ldy LRZ_ScoreBoardOff           ; get score board offset
                            lda LR_ScoreBufID_Char2,y       ; get player id char 2
                            jsr TextOutCharHandler          ; control the output of a single char
                            
                            ldy LRZ_ScoreBoardOff           ; get score board offset
                            lda LR_ScoreBufID_Char3,y       ; get player id char 3
                            jsr TextOutCharHandler          ; control the output of a single char
; --------------------------------------------------------------------------------------------------------------------- ;
; score row filler between initials and level
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; output level number reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScoreBoardOff           ; get score board offset
                            lda LR_ScoreBufLevel,y          ; get level number reached
                            jsr ConvertHexToDec             ; result in LR_Digit_100/LR_Digit_10/LR_Digit_1
                            
                            lda LR_Digit_100                ; get digit 100 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
; score row gap between level and score
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
; output top scorer score reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScoreBoardOff           ; get score board offset
                            lda LR_ScoreBufValue_Hi,y       ; get score
                            jsr ScoreSplitDigit             ; split BCD number in 10s and 1s part for output
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            ldy LRZ_ScoreBoardOff           ; get score board offset
                            lda LR_ScoreBufValue_Mid_Hi,y   ; get score
                            jsr ScoreSplitDigit             ; split BCD number in 10s and 1s part for output
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            ldy LRZ_ScoreBoardOff           ; get score board offset
                            lda LR_ScoreBufValue_Mid_Lo,y   ; get score
                            jsr ScoreSplitDigit             ; split BCD number in 10s and 1s part for output
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            ldy LRZ_ScoreBoardOff           ; get score board offset
                            lda LR_ScoreBufValue_Lo,y       ; get score
                            jsr ScoreSplitDigit             ; split BCD number in 10s and 1s part for output
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreSetNextEntry           jsr TextCharOutNewLine          ; set cursor to next line
                            
                            inc LRZ_ScoreBoardRank          ; inc actual rank
; --------------------------------------------------------------------------------------------------------------------- ;
; check all entries processed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_ScoreBoardRank          ; get actual rank
                            cmp #LR_ScoreBufEntry_Max + $01 ; test max passed
                            bcs ScoreShowLeaderboardX       ; check: max passed - yes: exit
                            
                            jmp ScoreNextEntryOut           ; show next leaderboard entry
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreShowLeaderboardX       rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabScoreBufEntryOff         = * ; start of each leaderboard entry in the score buffer
                            .byte $00                        ; 
                            .byte LR_ScoreBufEntry_Len * $00 ; $00
                            .byte LR_ScoreBufEntry_Len * $01 ; $08
                            .byte LR_ScoreBufEntry_Len * $02 ; $10
                            .byte LR_ScoreBufEntry_Len * $03 ; $18
                            .byte LR_ScoreBufEntry_Len * $04 ; $20
                            .byte LR_ScoreBufEntry_Len * $05 ; $28
                            .byte LR_ScoreBufEntry_Len * $06 ; $30
                            .byte LR_ScoreBufEntry_Len * $07 ; $38
                            .byte LR_ScoreBufEntry_Len * $08 ; $40
                            .byte LR_ScoreBufEntry_Len * $09 ; $48
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; InputKeySubstitute        Does    : get a leaderbord scorer ID char substitution
;                           Expects : .A=raw scorer ID char
;                           Returns : .A=scorer ID char substitution
; --------------------------------------------------------------------------------------------------------------------- ;
InputKeySubstitute         .block                           ; 
                            cmp #$82                        ; test <CURSOR_LEFT>
                            bne GetKeySubstTabValue         ; check: EQ - no
                            
                            lda #$07                        ; get <CURSOR_UP> replacement value
                            
GetKeySubstTabValue         tay                             ; set key as key substitution table offset
                            lda TabKeySubstValue,y          ; get key substitution table value
                            ora #$80                        ; set bit7
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabKeySubstValue            = *       ; 
                            .byte $00 ; $00 - INST/DEL
                            .byte $0d ; $01 - RETURN
                            .byte $15 ; $02 - CURSOR_LEFT
                            .byte $ff ; $03 - F7            - ignore
                            .byte $ff ; $04 - F1            - ignore
                            .byte $ff ; $05 - F3            - ignore
                            .byte $ff ; $06 - F5            - ignore
                            .byte $08 ; $07 - CURSOR_UP
                            
                            .byte $33 ; $08 - 3
                            .byte $57 ; $09 - W
                            .byte $41 ; $0a - A
                            .byte $34 ; $0b - 4
                            .byte $5a ; $0c - Z
                            .byte $53 ; $0d - S
                            .byte $45 ; $0e - E
                            .byte $ff ; $0f - SHIFT_Left    - ignore
                            
                            .byte $35 ; $10 - 5
                            .byte $52 ; $11 - R
                            .byte $44 ; $12 - D
                            .byte $36 ; $13 - 6
                            .byte $43 ; $14 - C
                            .byte $46 ; $15 - F
                            .byte $54 ; $16 - T
                            .byte $58 ; $17 - X
                            
                            .byte $37 ; $18 - 7
                            .byte $59 ; $19 - Y
                            .byte $47 ; $1a - G
                            .byte $38 ; $1b - 8
                            .byte $42 ; $1c - B
                            .byte $48 ; $1d - H
                            .byte $55 ; $1e - U
                            .byte $56 ; $1f - V
                            
                            .byte $39 ; $20 - 9
                            .byte $49 ; $21 - I
                            .byte $4a ; $22 - J
                            .byte $30 ; $23 - 0
                            .byte $4d ; $24 - M
                            .byte $4b ; $25 - K
                            .byte $4f ; $26 - O
                            .byte $4e ; $27 - N
                            
                            .byte $2b ; $28 - +
                            .byte $50 ; $29 - P
                            .byte $4c ; $2a - L
                            .byte $2d ; $2b - 
                            .byte $2e ; $2c - .
                            .byte $3a ; $2d - :
                            .byte $ff ; $2e - @             - ignore
                            .byte $2c ; $2f - ,
                            
                            .byte $5c ; $30 - £
                            .byte $2a ; $31 - *
                            .byte $3b ; $32 - ;
                            .byte $ff ; $33 - CLR/HOME      - ignore
                            .byte $ff ; $34 - SHIFT RIGHT   - ignore
                            .byte $3d ; $35 - =
                            .byte $ff ; $36 - ARROW UP      - ignore
                            .byte $2f ; $37 - /
                            
                            .byte $31 ; $38 - 1
                            .byte $ff ; $39 - ARROW LEFT    - ignore
                            .byte $ff ; $3a - CTRL          - ignore
                            .byte $32 ; $3b - 2
                            .byte $20 ; $3c - SPACE
                            .byte $ff ; $3d - C=            - ignore
                            .byte $51 ; $3e - Q
                            .byte $ff ; $3f - RUN/STOP      - ignore
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelDataExpand       Does    : expand compressed level disk data
;                           Expects : .X=0 - data needs a copy to prepare hires screen
;                                   : .X=1 - data already copied to prepare hires screen
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelDataExpand        .block                           ; 
                            stx LR_LevelLoad                ; set flag level disk load control
                            
                            ldx #$ff                        ; get initial value $ff
                            stx LRZ_LodeRuCol               ; ini no loderunner found
                            
                            inx                             ; get initial value $00
                            stx LR_ExitLadderCount          ; ini LR_ExitLadderCount_None
                            stx LR_GoldToCollect            ; ini LR_GoldToCollect_None
                            stx LR_EnemyCount               ; ini LR_EnmyCount_None
                            stx LR_EnemyToMoveNum           ; ini LR_EnemyToMoveNum_None
                            stx LRZ_ShootStepCtrl           ; ini loderunner shoot step image table offset
                            stx LRZ_LevelDiskDataOff        ; ini disk level data offset
                            stx LRZ_WorkLevelDataPartCtrl   ; ini right nibble disk data byte processing
                            stx LRZ_ScreenRow               ; ini screen row ($00-$0f)
                            
                            txa                             ; $00
                            ldx #LR_WA_HoleMax              ; get count max entries of hole open time table
IniNextOpenHoleTabEntry     sta LR_WA_HoleOpenTime,x        ; ini hole open time tab
                            
                            dex                             ; dec count entries of hole open time table
                            bpl IniNextOpenHoleTabEntry     ; check: min - no: continue
                            
                            ldx #LR_WA_EnemyBirth_Len       ; get count max entries of enemy rebirth time table
IniNextRibirthTimeTabEntry  sta LR_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
                            
                            dex                             ; dec count of enemy rebirth time table
                            bpl IniNextRibirthTimeTabEntry  ; check: min - no: continue
                            
                            lda #LR_LodeRuState_Alive       ; get loderunner alive
                            sta LR_LodeRuState              ; set loderunner alive
                            
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            cmp LR_LevelReload              ; test with reload
                            beq SetNoDiskLoadRequired       ; check: EQ - yes: level aready loaded - no reload necessary
                            
                            lda #LR_DiskRead                ; get flag read block
                            jsr DiskOperationHandler        ; read block from disk
; --------------------------------------------------------------------------------------------------------------------- ;
; set LR_LevelNumDisk=LR_LevelReload - avoids level data reload from disk for the same level number
; --------------------------------------------------------------------------------------------------------------------- ;
SetNoDiskLoadRequired       lda LR_LevelNumDisk             ; get disk level number 000-149
                            sta LR_LevelReload              ; set avoid level data reload
; --------------------------------------------------------------------------------------------------------------------- ;
; expand the level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
SetNextLevelDataRowPtr      lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set game level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set control level data row pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set control level data row pointer LOlevel control data pointer HI
                            
                            lda #LRZ_ScreenCol_Min          ; get initial value
                            sta LRZ_ScreenCol               ; ini screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; handle compressed data nibble control flag
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextNibbleCtrl           lda LRZ_WorkLevelDataPartCtrl   ; get control left/right nibble to process - 00=right/01=left
                            lsr a                           ; set .C to control left/right nibble processing
; --------------------------------------------------------------------------------------------------------------------- ;
; get compressed data byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LevelDiskDataOff        ; get disk level data offset
                            lda LR_LevelDataBuf,y           ; get a packed level data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; check compressed data nibble control flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            bcs IsolateNibbleLeft           ; check: right nibble handled already - yes: process left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; process right compressed data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$0f                        ; ....#### - isolate right nibble
                            bpl ForceProcessingLeftNibble   ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; process left compressed data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
IsolateNibbleLeft           lsr a                           ; .####... - isolate left nibble
                            lsr a                           ; ..####..
                            lsr a                           ; ...####.
                            lsr a                           ; ....####
; --------------------------------------------------------------------------------------------------------------------- ;
; both nibbles processed - set offset to next disk byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_LevelDiskDataOff        ; inc offset to next disk level byte
                            
ForceProcessingLeftNibble   inc LRZ_WorkLevelDataPartCtrl   ; force .C set the next round - process left nibble
                            
                            ldy LRZ_ScreenCol               ; get screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; care for valid level tile number
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Max             ; test valid byte range of $00-$09
                            bcc StoreUnpackedLevelTile      ; check: LT - yes: valid
                            
                            lda #LR_TileNum_Empty           ; get invalid level tile replacement - store an empty tile
; --------------------------------------------------------------------------------------------------------------------- ;
; store level tile into both level data buffers
; --------------------------------------------------------------------------------------------------------------------- ;
StoreUnpackedLevelTile      sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (LRZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            
                            lda LRZ_ScreenCol               ; get screen col ($00-$1b)
                            cmp #LRZ_ScreenCol_Max + $01    ; test max passed
                            bcc GetNextNibbleCtrl           ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next row - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenRow               ; inc screen row ($00-$0f)
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            cpy #LRZ_ScreenRow_Max + $01    ; test max
                            bcc SetNextLevelDataRowPtr      ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; care for hidden ladders/trap doors/gold/enemies/loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LevelSpecialTileHandler     ; handle special level tiles and set up prepare gfx screen
                            bcc GameContinue                ; check: loderunner tile found - yes: continue the game
; --------------------------------------------------------------------------------------------------------------------- ;
; missing loderunner level data tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            beq GameColdStart               ; check: still 1st level - yes: coldstart
; --------------------------------------------------------------------------------------------------------------------- ;
; force restart with 1st level
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #LR_LevelNumDisk_Min        ; get initial value
                            stx LR_LevelNumDisk             ; set disk level number 000-149 - last level completed
; --------------------------------------------------------------------------------------------------------------------- ;
; try to increase the game speed
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_GameSpeedCtrl            ; get game speed ($00-$0a)
                            cmp #LR_GameSpeedCtrl_Max       ; test game speed max
                            bcs GameRestart                 ; check: GE - yes: max reached or bypassed - bypass inc
                            
                            inc LR_GameSpeedCtrl            ; make the game a bit difficulter
                            
GameRestart                 dex                             ; set flag LR_LevelLoad_No
                            jmp GameLevelDataExpand         ; expand compressed level disk data
; --------------------------------------------------------------------------------------------------------------------- ;
GameContinue                rts                             ; continue the running game
; --------------------------------------------------------------------------------------------------------------------- ;
; error restart - probably no loderunner level disk
; --------------------------------------------------------------------------------------------------------------------- ;
GameColdStart               jmp ColdStart                   ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameLevelDataCompress     Does    : compress expanded level data and store to disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameLevelDataCompress      .block                           ; 
                            lda #$00                        ; get initial value
                            sta LRZ_LevelDiskDataOff        ; ini disk level data offset
                            sta LRZ_WorkLevelDataPartCtrl   ; ini right nibble disk data byte processing
                            sta LRZ_ScreenRow               ; ini screen row ($00-$0f)
                            
SetNextLevelDataRowPtr      ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set game level data row pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy #LRZ_ScreenCol_Min          ; get inital value
                            sty LRZ_ScreenCol               ; ini screen col ($00-$1b)
                            
GetNextNibbleCtrl           lda LRZ_WorkLevelDataPartCtrl   ; get control left/right nibble to process - 00=right/01=left
                            lsr a                           ; set .C to control left/right nibble processing
                            
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            bcs IsolateNibbleLeft           ; check: right nibble handled already - yes: process left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; process right data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta LRZ_ImageNumber             ; save as right nibble
                            bpl ForceProcessingLeftNibble   ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; process left data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
IsolateNibbleLeft           asl a                           ; isolate left nibble
                            asl a                           ; 
                            asl a                           ; 
                            asl a                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; insert right data nibble
; --------------------------------------------------------------------------------------------------------------------- ;
                            ora LRZ_ImageNumber             ; insert right nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; store complete data byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LevelDiskDataOff        ; get disk level data offset
                            sta LR_LevelDataBuf,y           ; set packed level data byte
; --------------------------------------------------------------------------------------------------------------------- ;
; both nibbles processed - set offset to next disk byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_LevelDiskDataOff        ; disk level data offset
                            
ForceProcessingLeftNibble   inc LRZ_WorkLevelDataPartCtrl   ; will set .C the next round - force left nibble
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            ldy LRZ_ScreenCol               ; get screen col ($00-$1b)
                            cpy #LRZ_ScreenCol_Max + $01    ; test max passed
                            bcc GetNextNibbleCtrl           ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next row - check max
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda LRZ_ScreenRow               ; get screen row ($00-$0f)
                            cmp #LRZ_ScreenRow_Max + $01    ; test max passed
                            bcc SetNextLevelDataRowPtr      ; check: LT - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; write packed data block to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskWrite               ; get flag write block to disk
                            jmp DiskOperationHandler        ; write level data block to disk and exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskOperationHandler      Does    : decide whether a level is to be loaded from disk or not (demo)
;                           Expects : .A=$01 - Read
;                                   : .A=$02 - Write
;                                   : .A=$04 - Init
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskOperationHandler       .block                           ; 
                            pha                             ; save mode - $01=read $02=write $04=init
                            bpl ChkDemoOrGameLevels         ; check: negative - no
; --------------------------------------------------------------------------------------------------------------------- ;
; reset a possible negative bit (never set)
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore mode - $01=read $02=write $04=init
                            and #$7f                        ; .####### - clear bit7
                            pha                             ; save mode - $01=read $02=write $04=init
                            
                            jmp DiskCmdHandler              ; open channels and device for read/write/init commands
; --------------------------------------------------------------------------------------------------------------------- ;
; demo levels are built in - only game levels must be loaded from disk
; --------------------------------------------------------------------------------------------------------------------- ;
ChkDemoOrGameLevels         lda LR_GameMode                 ; set $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            lsr a                           ; shift out mode flag
                            beq DemoLevelDataHandler        ; check: demo - yes: demo - levels are built in - no load necessary
; --------------------------------------------------------------------------------------------------------------------- ;
; only game levels have to be loaded
; --------------------------------------------------------------------------------------------------------------------- ;
                            jmp DiskCmdStringInit           ; init disk command string for read/write/init
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoLevelDataHandler      Does    : control demo level data selection
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoLevelDataHandler       .block                           ; 
                            pla                             ; remove mode from stack
; --------------------------------------------------------------------------------------------------------------------- ;
; 3 demo levels are built in
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            cmp #LR_LevelNumDisk_Demo_Max   ; test max 3 demo levels
                            bcc SetNextDemoLevelDataAddress ; check: LT - yes: continue with next demo level data address
; --------------------------------------------------------------------------------------------------------------------- ;
; maximum reached - restart at demo level one
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_LevelNumDisk_Min        ; get restart at level 1
                            sta LR_LevelNumDisk             ; set disk level number 000-149
; --------------------------------------------------------------------------------------------------------------------- ;
; increase demo speed
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LR_GameSpeedCtrl            ; inc game speed ($00-$0a)
                            
                            ldx LR_GameSpeedCtrl            ; get game speed
                            cpx #LR_GameSpeedCtrl_Max       ; test game speed max
                            bcc SetNextDemoLevelDataAddress ; check: LT - yes: bypass correction
                            
                            dec LR_GameSpeedCtrl            ; correct game speed to max
; --------------------------------------------------------------------------------------------------------------------- ;
; set level data pointer to next demo level data
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextDemoLevelDataAddress clc                             ; 
                            adc #>TabDemoDataLevel          ; add demo level number do demo level data base address
                            sta smTabDemoDataLevel          ; set address to next level data
                            
                            ldy #$00                        ; get demo level data offset
smTabDemoDataLevel          = * + $02                       ; 
GetNextDemoLevelDataByte    lda TabDemoDataLevel,y          ; get demo level data from $b500/$b600/$b700
                            sta LR_LevelDataBuf,y           ; set next demo level data byte
                            
                            iny                             ; inc demo level data offset
                            bne GetNextDemoLevelDataByte    ; check: max - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreDiskHandler          Does    : read or write the leaderboard block
;                           Expects : .A=$01 - Disk Read
;                                   : .A=$02 - Disk Write
;                           Returns : .A=LR_ScoreBufCheck_Bad     - loderunner disk ID not found
;                                   : .A=LR_ScoreBufCheck_Mod_No  - loderunner master disk
;                                   : .A=LR_ScoreBufCheck_Mod_Yes - loderunner player level data disk
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreDiskHandler           .block                           ; 
                            tax                             ; save access type - 01=read 02=write
                            
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            pha                             ; save disk level number
                            
                            inc DiskCmdExecRead.smSetDiskReadBufPtr_Hi   ; select read buffer
                            inc DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; select write buffer
                            
                            lda #LR_LevelNumDisk_Score      ; get disk level 151 - stores the leaderboard data
                            sta LR_LevelNumDisk             ; set disk level number 151
                            
                            txa                             ; restore access type - 01=read 02=write
                            jsr DiskOperationHandler        ; read leaderboard block from disk
                            
                            pla                             ; restore disk level number
                            sta LR_LevelNumDisk             ; set disk level number 000-149
                            
                            dec DiskCmdExecRead.smSetDiskReadBufPtr_Hi   ; reset read buffer
                            dec DiskCmdExecWrite.smSetDiskWriteBufPtr_Hi ; reset write buffer
; --------------------------------------------------------------------------------------------------------------------- ;
; init check loderunner disk id DANE BIGHAM
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabLodeRuDiskId_Len        ; get length of loderunner disk id string
                            
                            lda #$00                        ; get initial value
                            sta LRZ_WorkChkDiskIdResult     ; ini check result
; --------------------------------------------------------------------------------------------------------------------- ;
; check loderunner disk id DANE BIGHAM
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextDiskIdChar           lda LR_ScoreBufDiskId,y         ; get a loderunner disk id char
                            eor TabLodeRuDiskId,y           ; flip with tabled disk id char
                            ora LRZ_WorkChkDiskIdResult     ; insert old check result
                            sta LRZ_WorkChkDiskIdResult     ; set new check result
                            
                            dey                             ; dec disk id length
                            bpl GetNextDiskIdChar           ; check: end of disk id string - no: continue
                            
                            lda LRZ_WorkChkDiskIdResult     ; get check result
                            beq ChkLoderunnerDiskFlag       ; check: disk id correct - yes: loderunner data disk in drive
                            
                            lda #LR_ScoreBufCheck_Bad       ; get flag lodrunner disk ID not found
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set correct disk flag
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLoderunnerDiskFlag       lda #LR_ScoreBufCheck_Mod_No    ; preset flag disk in drive is a non modifiable loderunner master disk
                            
                            ldx LR_ScoreBufDiskFlag         ; get disk block indicator flag
                            bne ScoreDiskHandlerX           ; check: player data disk - no: exit
                            
                            lda #LR_ScoreBufCheck_Mod_Yes   ; get flag disk in drive is a modifiable player level disk
                            
ScoreDiskHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdStringInit         Does    : init disk command string for read/write/init
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdStringInit          .block                           ; 
                            lda #SPENA_ALL_OFF              ; get switch off all sprites
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)
                            
                            ldx #"0"                        ; preset sector number HI for sector values below 10
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate sector/track numbers from disk level number
; each track contains 16 level blocks ($00-$0f)
; start track is track 3
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LevelNumDisk             ; get disk level number 000-149
; --------------------------------------------------------------------------------------------------------------------- ;
; Sector_number = LR_LevelNumDisk MOD 15
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #$0f                        ; get the rest of the division by 15
                            
                            cmp #$0a                        ; test value 10
                            bcc PutSectorNum_Hi             ; check: LT - yes: set sector number HI
                            
                            ldx #"1"                        ; get sector number HI for sector values above 9
                            
                            sec                             ; 
                            sbc #$0a                        ; subtract 10 for 1s part
                            
PutSectorNum_Hi             stx TabDiskCmd_Sec_Hi           ; set disk comand sector number HI
                            
                            clc                             ; 
                            adc #"0"                        ; generate char digit 0-9 from binary
                            sta TabDiskCmd_Sec_Lo           ; set disk comand sector number LO
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LevelNumDisk             ; get disk level number 000-149
; --------------------------------------------------------------------------------------------------------------------- ;
; track_number = INT(LR_LevelNumDisk/16) + 3
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr a                           ; /2
                            lsr a                           ; /4
                            lsr a                           ; /8
                            lsr a                           ; /16
; --------------------------------------------------------------------------------------------------------------------- ;
; add start track number
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #LR_LevelDataStartTrackNum  ; add start level data track 3
                            
                            ldx #"0"                        ; preset track number HI for track values below 10
                            
                            cmp #$0a                        ; test value 10
                            bcc PutTrackNum_Hi              ; check: LT - yes: set track number HI
                            
                            ldx #"1"                        ; get track number HI for track values above 9
                            
                            sec                             ; 
                            sbc #$0a                        ; subtract 10 for 1s part
                            
PutTrackNum_Hi              stx TabDiskCmd_Trk_Hi           ; set disk comand track number HI
                            
                            clc                             ; 
                            adc #"0"                        ; generate char digit 0-9 from binary
                            sta TabDiskCmd_Trk_Lo           ; set disk comand track number LO
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdHandler            Does    : open channels and device for read/write/init commands
;                           Expects : STACK=mode $01=read $02=write $04=init
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdHandler             .block                           ; 
                            lda #$00                        ; get flag no filename
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            
                            lda #SA_CHANNEL_CMD             ; get channel number: command channel
                            ldx #FA_DISK                    ; get drive number (8)
                            ldy #SA_CHANNEL_CMD             ; get secondary address
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            bcs DiskError                   ; check: disk error - yes: DiskError
                            
                            lda #FileNameString_Len         ; get length data set name '#'
                            ldx #<FileNameString            ; get adr filename LO
                            ldy #>FileNameString            ; get adr filename HI
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            
                            lda #$02                        ; get channel number: data
                            ldx #FA_DISK                    ; get drive number (8)
                            ldy #$02                        ; get secondary address
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            bcs DiskError                   ; check: disk error - yes: DiskError
; --------------------------------------------------------------------------------------------------------------------- ;
; handle access mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore mode - $01=read $02=write $04=init
                            
                            lsr a                           ; shift READ bit to .C
                            bcs DiskCmdExecRead             ; check: READ mode - yes: exec READ
                            
                            lsr a                           ; shift WRITE bit to .C
                            bcc DiskCmdExecInit             ; check: WRITE mode - no: exec INIT
                            
                            jmp DiskCmdExecWrite            ; exec write
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecInit           Does    : initialize a loderunner level data disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecInit            .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear packed level data buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #LR_TileNum_Empty           ; get empty loderunner level data tile
                            tya                             ; ini level data offset
ClearNextBufferByte         sta LR_ScoreBuf,y               ; clear HI score buffer
                            sta LR_LevelDataBuf,y           ; clear packed level data buffer
                            
                            iny                             ; inc buffer offset
                            bne ClearNextBufferByte         ; check: max - no: continue
                            
                            lda #LR_LevelNumDisk_Max        ; get 149 blocks to write
                            sta LR_LevelNumDisk             ; ini disk level number 000-149
                            
                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)
; --------------------------------------------------------------------------------------------------------------------- ;
; write 150 empty level blocks
; --------------------------------------------------------------------------------------------------------------------- ;
WriteNextLevelDataBlock     lda #LR_DiskWrite               ; get flag write 150 empty levels to disk
                            jsr DiskOperationHandler        ; write block to disk
                            
                            dec LR_LevelNumDisk             ; dec disk level number 000-149
                            
                            lda LR_LevelNumDisk             ; get disk level number 000-149
                            cmp #$ff                        ; test min
                            bne WriteNextLevelDataBlock     ; check: EQ - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill leaderboad block with loderunner disk string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #TabLodeRuDiskId_Len        ; get length loderunner disk id string
SetNextDiskIdChar           lda TabLodeRuDiskId,y           ; get loderunner disk id=DANE BIGHAM
                            sta LR_ScoreBufDiskId,y         ; set store as loderunner disk id in HI score data block
                            
                            dey                             ; dec length loderunner disk id sting
                            bpl SetNextDiskIdChar           ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; fill leaderboad block with player level id flag
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; flag LR_DiskUserData
                            sty LR_ScoreBufDiskFlag         ; set indicator store in Highscore block
; --------------------------------------------------------------------------------------------------------------------- ;
; write the leaderboard block
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_DiskWrite               ; get flag write block to disk
                            jsr ScoreDiskHandler            ; write out the leaderboard block
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskError                 Does    : jump back to start in case of a disk error
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskError                  .block                           ; 
                            jmp StartGraficOut              ; expand the compressed start grafic
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecRead           Does    : read a block from disk into packed data buffer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecRead            .block                           ; 
                            lda #"1"                        ; get command id read
                            sta TabDiskCmd_CmdType          ; set command id to u1=read
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
; --------------------------------------------------------------------------------------------------------------------- ;
; open command channel
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #SA_CHANNEL_CMD             ; get command channel
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
                            bcs DiskError                   ; check: disk error - yes: DiskError
; --------------------------------------------------------------------------------------------------------------------- ;
; transfer the disk read command string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get ini offset cmd string
PutNextDiskCmdCharRead      lda TabDiskCmd,y                ; get disk command string - u1:02 0 tt .ss
                            beq GoDiskCmdCheckRC            ; check: end of cmd string - yes: check RC
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc cmd string offset
                            jmp PutNextDiskCmdCharRead      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check rc
; --------------------------------------------------------------------------------------------------------------------- ;
GoDiskCmdCheckRC            jsr DiskCmdCheckRC              ; check the disk command return code
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #$02                        ; get data channel number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            bcs DiskError                   ; check: disk error - yes: DiskError
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
; --------------------------------------------------------------------------------------------------------------------- ;
; read in disk buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get ini get byte count
GetNextDiskByte             jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
smSetDiskReadBufPtr_Hi      = * + $02                       ; 
                            sta LR_LevelDataBuf,y           ; set get store disk data byte
                            
                            iny                             ; inc get byte count
                            bne GetNextDiskByte             ; check: 255 bytes read - no: continue
                            
                            jmp DiskCmdResetSpeed           ; activate the slow 1542 C64 mode
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdExecWrite          Does    : write a block from packed data buffer to disk
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecWrite           .block                           ; 
                            lda #"2"                        ; get command id write 
                            sta TabDiskCmd_CmdType          ; set u2=write
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #$02                        ; get data channel number
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
                            bcs DiskError                   ; check: disk error - yes: DiskError
; --------------------------------------------------------------------------------------------------------------------- ;
; write out data buffer to disk
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini level data pointer
smSetDiskWriteBufPtr_Hi     = * + $02                       ; 
GetNextPackedLevelDataByte  lda LR_LevelDataBuf,y           ; get data byte
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc level data pointer
                            bne GetNextPackedLevelDataByte  ; check: max - no: continue
                            
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
; --------------------------------------------------------------------------------------------------------------------- ;
; open command channel
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #SA_CHANNEL_CMD             ; get command channel
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
; --------------------------------------------------------------------------------------------------------------------- ;
; transfer the disk write command string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get command string offset
PutNextDiskCmdCharWrite     lda TabDiskCmd,y                ; get disk command string u2:02 0 tt ss
                            beq DiskCmdExecWriteX           ; check: EoC mmarker - yes: exit
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc command string offset
                            jmp PutNextDiskCmdCharWrite     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdExecWriteX           jsr DiskCmdCheckRC              ; check the disk command return code
                            jmp DiskCmdResetSpeed           ; activate the slow 1542 C64 mode
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; <obsolete>
; --------------------------------------------------------------------------------------------------------------------- ;
FileNameString              .byte "#" ; 
FileNameString_Len          = * - FileNameString ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmd                  = *       ; 
                            .byte "u" ; user command id
TabDiskCmd_CmdType          .byte "1" ; user command type - 1=read  2=write
                            .byte ":" ; 
                            .byte "0" ; channel number
                            .byte "2" ; 
                            .byte " " ; 
                            .byte "0" ; drive number
                            .byte " " ; 
TabDiskCmd_Trk_Hi           .byte "0" ; track number HI
TabDiskCmd_Trk_Lo           .byte "3" ; track number LO
                            .byte " " ; 
TabDiskCmd_Sec_Hi           .byte "0" ; sector number HI
TabDiskCmd_Sec_Lo           .byte "0" ; sector number LO
                            
                            .byte CR  ; <ENTER>
TabDiskCmd_Len              = * - TabDiskCmd ; 
                            
                            .byte $00 ; end of command string
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdSetSlowMode          = *      ; 
                            .byte "u" ; user command id
                            .byte "+" ; set slow C64 mode
                            
                            .byte CR  ; <ENTER>
                            .byte $00 ; End of String marker
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdCheckRC            Does    : check the disk command return code
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdCheckRC             .block                           ; 
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #SA_CHANNEL_CMD             ; get command channel number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            sta LRZ_WorkDiskRC              ; set disk RC number 1st part
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            ora LRZ_WorkDiskRC              ; insert disk RC number 2nd part
                            sta LRZ_WorkDiskRC              ; set combined disk RC number
                            
GetNextDiskMsgChar          jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            
                            cmp #CR                         ; test <ENTER>
                            bne GetNextDiskMsgChar          ; check: EQ - no: read rest of the message
                            
                            lda LRZ_WorkDiskRC              ; get combined disk RC number
                            cmp #"0"                        ; test OK
                            beq DiskCmdCheckRCX             ; check: EQ - yes: good end
                            
                            jmp ColdStart                   ; bad end - disk error - restart
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdCheckRCX             rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DiskCmdResetSpeed         Does    : activate the slow 1541 C64 mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdResetSpeed          .block                           ; 
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #SA_CHANNEL_CMD             ; get command channel number
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
; --------------------------------------------------------------------------------------------------------------------- ;
; transfer the disk command string
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini disk command offset
GetNextDiskCmdChar          lda DiskCmdSetSlowMode,y        ; get cmd u+
                            beq DiskCmdResetSpeedX          ; check: EoC marker - yes: exit
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc disk command offset
                            jmp GetNextDiskCmdChar          ; 
; --------------------------------------------------------------------------------------------------------------------- ;
DiskCmdResetSpeedX          jmp CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelSpecialTileHandler   Does    : handle special level tiles and set up prepare gfx screen
;                           Expects : 
;                           Returns : .C=1 - no loderunner tile found
; --------------------------------------------------------------------------------------------------------------------- ;
LevelSpecialTileHandler    .block                           ; 
                            ldy #LRZ_ScreenRow_Max          ; get max - start at bottom of screen
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda #SPENA_ALL_OFF              ; get switch off sprites
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
; --------------------------------------------------------------------------------------------------------------------- ;
; set level data row pointers
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextLevelDataRowPtr      lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; init row column offset to maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #LRZ_ScreenCol_Max          ; get max cols - start at rightmost column 
                            sty LRZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; get next level data col byte for this row
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextLevelDataByte        lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            
                            ldx LR_LevelLoad                ; get flag level disk load control
                            beq GoLevelTileOutToScreenPrep  ; check: loaded already - yes: nothing to do but output to prepare screen
; --------------------------------------------------------------------------------------------------------------------- ;
; handle hidden ladders
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_LadderExit      ; test hidden ladder
                            bne HandleGold                  ; check: EQ - no: handle gold next
                            
                            ldx LR_ExitLadderCount          ; get actual number of hidden ladders
                            cpx #LR_ExitLadderCount_Max - $03 ; test max
                            bcs SetLevelTileBlank           ; check: GE - yes: do not count and blank it out
; --------------------------------------------------------------------------------------------------------------------- ;
; count hidden ladder and store its position
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LR_ExitLadderCount          ; inc number of hidden ladders
                            
                            inx                             ; inc table offset
                            lda LRZ_ScreenRow               ; get screen row ($00-$0f)
                            sta LR_WA_ExitLadderRow,x       ; set row numer in hidden ladder row table
                            
                            tya                             ; get hidden ladder column
                            sta LR_WA_ExitLadderCol,x       ; set column number in hidden ladder column table
; --------------------------------------------------------------------------------------------------------------------- ;
; insert a blank level tile into game/ctrl level data
; --------------------------------------------------------------------------------------------------------------------- ;
SetLevelTileBlank           lda #LR_TileNum_Empty           ; get empty tile for hidden ladder/enemy
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (LRZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; branch enlargement
; --------------------------------------------------------------------------------------------------------------------- ;
GoLevelTileOutToScreenPrep  beq LevelTileOutToScreenPrep    ; always - branch enlargement
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level gold
; --------------------------------------------------------------------------------------------------------------------- ;
HandleGold                  cmp #LR_TileNum_Gold            ; test gold
                            bne HandleEnemies               ; check: EQ - no: handle enemy next
                            
                            inc LR_GoldToCollect            ; count level gold to collect
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level enemies
; --------------------------------------------------------------------------------------------------------------------- ;
HandleEnemies               cmp #LR_TileNum_Enemy           ; test enemy
                            bne HandleLoderunner            ; check: EQ - no: handle loderunner next
                            
                            ldx LR_EnemyCount               ; get number of enemies ($00-$05)
                            cpx #LR_EnemyCount_Max          ; test max of 5
                            bcs SetLevelTileBlank           ; check: GE - yes: bypass enemy 
                            
                            inc LR_EnemyToMoveNum           ; inc number of enemies to move
                            inc LR_EnemyCount               ; inc number of enemies ($00-$05)
                            
                            inx                             ; inc enemy count for table offset
                            tya                             ; get column number
                            sta LR_SA_EnemyCol,x            ; set enemy save area column
                            
                            lda LRZ_ScreenRow               ; get screen row ($00-$0f)
                            sta LR_SA_EnemyRow,x            ; set enemy save area row
                            
                            lda #$00                        ; get initial value
                            sta LR_SA_EnemyHoleGoldTime,x   ; ini enemy either has gold or locked in a hole time
                            sta LR_SA_EnemySprtNum,x        ; ini actual enemy sprite number
                            
                            lda #LR_PosOnImage_Center       ; get centered position
                            sta LR_SA_EnemyPosOnImgPosX,x   ; ini enemy pos on image left/right tab
                            sta LR_SA_EnemyPosOnImgPosY,x   ; ini enemy pos on image up/down tab
; --------------------------------------------------------------------------------------------------------------------- ;
; clear ctrl level data from enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Empty           ; get empty space
                            sta (LRZ_LevelDataCtrlPtrRow),y ; clear enemy in play level ctrl data ($0a00-$0bc3)
                            
                            lda #LR_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #LR_TileNum_Enemy           ; get enemy tile
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; branch enlargements
; --------------------------------------------------------------------------------------------------------------------- ;
GoSetNextLevelDataRowPtr    bpl SetNextLevelDataRowPtr      ; always - branch enlargement
GoGetNextLevelDataByte      bpl GetNextLevelDataByte        ; always - branch enlargement
; --------------------------------------------------------------------------------------------------------------------- ;
; handle level loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
HandleLoderunner            cmp #LR_TileNum_LodeRunner      ; test loderunner
                            bne ChkTrapDoorDisplay          ; check: EQ - no: handle trapdoors next
; --------------------------------------------------------------------------------------------------------------------- ;
; take the 1st one only - ignore the rest
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_LodeRuCol               ; get actual col loderunner
                            bpl SetLevelTileBlank           ; check: loderunner found already - yes: blank this one out
                            
                            sty LRZ_LodeRuCol               ; ini actual col loderunner
                            
                            ldx LRZ_ScreenRow               ; get screen row ($00-$0f)
                            stx LRZ_LodeRuRow               ; ini actual row loderunner
                            
                            ldx #LRZ_LodeRuOnImgPosX_Mid    ; get middle
                            stx LRZ_LodeRuOnImgPosX         ; ini loderunner pos on image left/right
                            stx LRZ_LodeRuOnImgPosY         ; ini loderunner vertical pos on image
                            
                            ldx #LRZ_LodeRuSprtNumRunRi_00  ; get sprite number run right start
                            stx LRZ_LodeRuSprtNum           ; ini loderunner sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; clear ctrl level data from loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Empty           ; get empty space
                            sta (LRZ_LevelDataCtrlPtrRow),y ; clear loderunner in play level ctrl data ($0a00-$0bc3)
                            
                            lda #LR_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #LR_TileNum_LodeRunner      ; get loderunner tile
                            bne LevelTileOutToScreenPrep    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; hide tap doors from display
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTrapDoorDisplay          cmp #LR_TileNum_BrickTrap       ; test trap door
                            bne LevelTileOutToScreenPrep    ; check: EQ - no
                            
                            lda #LR_TileNum_BrickSoft       ; get blank trap door gfx substitution
; --------------------------------------------------------------------------------------------------------------------- ;
; output level tile to prepare gfx screen
; --------------------------------------------------------------------------------------------------------------------- ;
LevelTileOutToScreenPrep    jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; count screen column down
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_ScreenCol               ; set next screen col (00-1b) bottom up
                            ldy LRZ_ScreenCol               ; get screen col (00-1b)
                            bpl GoGetNextLevelDataByte      ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; count screen row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_ScreenRow               ; dec screen row (00-0f) - bottom up
                            ldy LRZ_ScreenRow               ; get screen row (00-0f)
                            bpl GoSetNextLevelDataRowPtr    ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; special level tiles handled - prepare gfx screen set up
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LevelLoad                ; get flag level disk load control
                            beq ScreenCopyDispToPrep        ; check: loaded already - yes: copy display to prepare screen
                            
                            lda LRZ_LodeRuCol               ; get actual col loderunner
                            bpl GameStartCycleCheck         ; check: loderunner tile found - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; error end no loderunner tile found
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; set error flag no loderunner tile found
                            rts                             ; exit with error flag set
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenCopyDispToPrep      Does    : copy the display gfx hires screen data to the prepared hires gfx screen 
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenCopyDispToPrep       .block                           ; 
                            lda #>LR_ScreenGfxDisplay       ; get display hires screen address HI
                            sta LRZ_ScreenRowPreparePtr_Hi  ; set screen prepare start of row pointer HI
                            
                            lda #>LR_ScreenGfxPrepare       ; get prepare hires screen address HI
                            sta LRZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            lda #$00                        ; get display/prepare hires screen address LO
                            sta LRZ_ScreenRowPreparePtr_Lo  ; set screen prepare start of row pointer LO
                            sta LRZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            
                            tay                             ; ini page offset
GetNextScrnGfxDispByte      lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display byte
                            sta (LRZ_ScreenRowPreparePtr),y ; set screen prepare byte
                            
                            iny                             ; inc page offset
                            bne GetNextScrnGfxDispByte      ; check: page copied - no: continue
                            
                            inc LRZ_ScreenRowPreparePtr_Hi  ; inc screen prepare start of row pointer HI
                            inc LRZ_ScreenRowDisplayPtr_Hi  ; inc screen display start of row pointer LO
                            
                            ldx LRZ_ScreenRowDisplayPtr_Hi  ; get screen display start of row pointer LO
                            cpx #>LR_ScreenGfxPrepareEnd + $01 ; test end of copy reached
                            bcc GetNextScrnGfxDispByte      ; check: end of copy - no: continue
                            
                            clc                             ; set flag all ok
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameInitStatusRows        Does    : prepare the status rows on both gfx screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameInitStatusRows         .block                           ; 
                            lda #>LR_ScreenGfxPrepare       ; get gfx prepare screen
                            sta LRZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            
                            jsr StatusAreaSetup             ; display the status row with separator and text
                            jsr ScreenCopyDispToPrep        ; copy prepared hires screen data to display screen
                            
                            lda #>LR_ScreenGfxDisplay       ; get gfx display screen
                            sta LRZ_TargetGfxOutput         ; set target output indicator - $20=$2000 $40=$4000
                            bne GameScreenPrepareClear      ; always - clear screen prepare from loderunner/enemy tiles
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameStartCycleCheck       Does    : check start cycle flag
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameStartCycleCheck        .block                           ; 
                            lda LR_StartCycle               ; get flag start cycle  $ff=LR_StartCycle_On
                            beq GameInitStatusRows          ; check: LR_StartCycle_Off - yes: bypass start cycle
                            
                            jsr StartCycleHandler           ; control display of the level start cycle
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameScreenPrepareClear    Does    : clear screen prepare from loderunner/enemy tiles
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameScreenPrepareClear     .block                           ; 
                            ldy #LRZ_ScreenRow_Max          ; get max
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
SetNextGameLevelTilePtr     lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy #LRZ_ScreenCol_Max          ; get max cols
                            sty LRZ_ScreenCol               ; ini screen col ($00-$1b)
                            
GetNextGameLevelTile        lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #LR_TileNum_LodeRunner      ; test loderunner
                            beq GetGameLevelTileBlank       ; check: EQ - yes: substitute with a blank
                            
                            cmp #LR_TileNum_Enemy           ; test enemy
                            bne SetNextLevelDataPos         ; check: NE - yes: do not substitute
; --------------------------------------------------------------------------------------------------------------------- ;
; substitute lodrunner/enemy level tiles on prepare screen with blank
; --------------------------------------------------------------------------------------------------------------------- ;
GetGameLevelTileBlank       lda #LR_TileNum_Empty           ; get empty tile substitution
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; set next screen column
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextLevelDataPos         dec LRZ_ScreenCol               ; dec screen col ($00-$1b)
                            ldy LRZ_ScreenCol               ; get screen col ($00-$1b)
                            bpl GetNextGameLevelTile        ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next screen row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_ScreenRow               ; dec screen row ($00-$0f)
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            bpl SetNextGameLevelTilePtr     ; check: min - no: continue
                            
                            clc                             ; set flag good end
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveHandler         Does    : control lodrunner moves
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveHandler          .block                           ; 
                            lda #LR_LodeRuGetGold_Picked    ; get flag gold collected completely
                            sta LR_LodeRuGetGold            ; set flag get gold  $00=just gets it
; --------------------------------------------------------------------------------------------------------------------- ;
; check shooting first
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_LodeRuShoot              ; get $00=no $01=right $ff=left
                            beq LodeRuMoves                 ; check: shoot - no: move him
                            bpl GoLodeRuShootRight          ; check: shoot right - yes
                            
                            jmp LodeRuShootLeft             ; shoot left
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuShootRight          jmp LodeRuShootRight            ; shoot right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoves                 ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level tile loderunner is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)  = data 'under' lr
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq GoStopFallingStartMoving    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            bne ChkOnImagePosY_Left         ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is in the center of a hires screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #LRZ_LodeRuOnImgPosY_Mid    ; test in middle of screen image
                            beq GoStopFallingStartMoving    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is left of the center of a hires screen image
; --------------------------------------------------------------------------------------------------------------------- ;
ChkOnImagePosY_Left         lda LRZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #LRZ_LodeRuOnImgPosY_Mid    ; test in middle of screen image
                            bcc LodeRuFallsDown             ; check: LT - yes: below center
; --------------------------------------------------------------------------------------------------------------------- ;
; test if loderunner is on bottom row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            cpy #LRZ_ScreenRow_Max          ; test max rows
                            beq GoStopFallingStartMoving    ; check: EQ - yes: bottom reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) + 1
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level data tile below loderunner is empty - let him fall down then
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Empty           ; test empty tile
                            beq LodeRuFallsDown             ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level data tile below loderunner is an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Enemy           ; test enemy
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq GoStopFallingStartMoving    ; check: EQ - yes: move loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; test if level ctrl data tile below loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne LodeRuFallsDown             ; check: EQ - no: loderunner falls down
                            
GoStopFallingStartMoving    jmp StopFallingStartMoving      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner is falling down
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuFallsDown             lda #LR_LodeRuFallsDown_Yes     ; get flag loderunner falls down
                            sta LR_LodeRuFallsDown          ; set loderunner falls down
; --------------------------------------------------------------------------------------------------------------------- ;
; step fall beep down 
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LR_TuneBeepFall             ; dec fall beep
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #LRZ_LodeRuSprtNumFallLe    ; get sprite number fall left
                            
                            ldx LRZ_LodeRuShootMode         ; get shoot mode
                            bmi SetLodeRuSpriteNum          ; check: LRZ_LodeRuShootMode_Front - yes
                            
                            lda #LRZ_LodeRuSprtNumFallRi    ; get sprite number fall right
                            
SetLodeRuSpriteNum          sta LRZ_LodeRuSprtNum           ; set loderunner sprite number
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            inc LRZ_LodeRuOnImgPosY         ; inc loderunner vertical pos on image
                            
                            lda LRZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            cmp #LRZ_LodeRuOnImgPosY_Max + $01 ; test beyond max
                            bcs SetOnImagePosY_Start        ; check: GE - yes: reinit to start
                            
                            jsr LodeRuGetGold               ; pic up and score the gold
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
SetOnImagePosY_Start        lda #LRZ_LodeRuOnImgPosY_Min    ; get min
                            sta LRZ_LodeRuOnImgPosY         ; set loderunner vertical pos on image
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetLevelGameTile            ; check: EQ - no
                            
                            lda #LR_TileNum_Empty           ; get empty tile substitution
                            
SetLevelGameTile            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_LodeRuRow               ; inc actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row below old loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; set the game level tile under new loderunner row to loderunner tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda #LR_TileNum_LodeRunner      ; get loderunner
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; end of loderunner fall down
; --------------------------------------------------------------------------------------------------------------------- ;
StopFallingStartMoving      lda LR_LodeRuFallsDown          ; get $00=fall $20=no fall $ff=init
                            bne GetEndOfFall                ; check: end of fall - yes <obsolete>
                            
GetEndOfFall                lda #LR_LodeRuFallsDown_No      ; get end of fall
                            sta LR_LodeRuFallsDown          ; set end of fall
; --------------------------------------------------------------------------------------------------------------------- ;
; check move direction
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
; --------------------------------------------------------------------------------------------------------------------- ;
; handle move directions up/down
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_JoystickMoveDirY         ; get move direction up/down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesUp            cmp #LR_JoystickMoveDirY_Up     ; test move up
                            bne ChkLodeRuMovesDown          ; check: EQ - no: check move down
                            
                            jsr LodeRunMoveUp               ; try to move him up
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully moved up
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesDown          cmp #LR_JoystickMoveDirY_Do     ; test move down
                            bne ChkLodeRuShootLeft          ; check: EQ - no: check shoot left
                            
                            jsr LodeRuMoveDown              ; try to move him down
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully moved down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuShootLeft          cmp #LR_JoystickShoot_Le        ; test shoot left
                            bne ChkLodeRuShootRight         ; check: EQ - no: check shoot right
                            
                            jsr LodeRuShootLeftInit         ; try to shoot left
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully shoot left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuShootRight         cmp #LR_JoystickShoot_Ri        ; test shoot right
                            bne GetLodeRuMoveDirLeRi        ; check: EQ - no: check moves left/right
                            
                            jsr LodeRuShootRightInit        ; try to shoot right
                            bcs GetLodeRuMoveDirLeRi        ; check: successfull - no: check left/right
                            
                            rts                             ; successfully shoot right
; --------------------------------------------------------------------------------------------------------------------- ;
; handle move directions left/right
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuMoveDirLeRi        lda LR_JoystickMoveDirX         ; get get move direction left/right
                            cmp #LR_JoystickMoveDirX_Le     ; test move left
                            bne ChkLodeRuMovesRight         ; check: EQ - no: check move right
                            
                            jmp LodeRuMoveLeft              ; try to move him left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuMovesRight         cmp #LR_JoystickMoveDirX_Ri     ; test move right
                            bne LodeRuMoveHandlerX          ; check: EQ - no: exit
                            
                            jmp LodeRuMoveRight             ; try to move him right
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveHandlerX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveLeft            Does    : try to move loderunner left
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveLeft             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on right side of the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cpx #LRZ_LodeRuOnImgPosX_Mid + $01 ; test loderunner right of image center
                            bcs GoGetLodeRuPosXY            ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if lodreunner is an max left col already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            beq LodeRuMoveLeftImpossible    ; check: max left - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile left of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveLeftImpossible    ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveLeftImpossible    ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly left is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickTrap       ; test trap door
                            bne GoGetLodeRuPosXY            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked - impossible to move left
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveLeftImpossible    rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #LRZ_LodeRuShootMode_Front  ; get shoot to front of loderunner
                            sta LRZ_LodeRuShootMode         ; set shoot mode
                            
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
                            
                            dec LRZ_LodeRuOnImgPosX         ; loderunner pos on image left/right = one step left
                            bpl GoLodeRuGetGold             ; check: move from actual to next left field not yet complete
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #LR_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_LodeRuCol               ; dec actual col loderunner
                            dey                             ; dec column offset
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_LodeRunner      ; get loderunner
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set loderunner max PosX of a screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_LodeRuOnImgPosX_Max    ; get max right
                            sta LRZ_LodeRuOnImgPosX         ; set loderunner pos on image left/right
                            bne GetCtrlTileUnderLodeRu      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlTileUnderLodeRu      ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq GetSpriteNumbers_Pole       ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number run left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_LodeRuSprtNumRunLe_00  ; get sprite numbers move left min
                            ldx #LRZ_LodeRuSprtNumRunLe_02  ; get sprite numbers move left max
                            bne SetNextSpriteNumber         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number pole left
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumbers_Pole       lda #LRZ_LodeRuSprtNumPoleLe_00 ; get sprite numnumber hang along a pole left min
                            ldx #LRZ_LodeRuSprtNumPoleLe_02 ; get sprite numnumber hang along a pole left max
                            
SetNextSpriteNumber         jsr LodeRuMoveSpriteNumRotate   ; rotate loderunner sprite number between min and max values
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveRight           Does    : try to move loderunner right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveRight            .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on left side of the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cpx #LRZ_LodeRuOnImgPosX_Mid    ; test loderunner left of image center
                            bcc GoGetLodeRuPosXY            ; check: LT - yes: left of center
; --------------------------------------------------------------------------------------------------------------------- ;
; check if lodreunner is an max right col already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            cpy #LRZ_ScreenCol_Max          ; test max right
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile right of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveRightImpossible   ; check: EQ - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game data tile directly right is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickTrap       ; test trap door
                            bne GoGetLodeRuPosXY            ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked - impossible to move right 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveRightImpossible   rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            lda #LRZ_LodeRuShootMode_Back   ; get shoot to back of loderunner
                            sta LRZ_LodeRuShootMode         ; set shoot mode
                            
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
                            
                            inc LRZ_LodeRuOnImgPosX         ; inc loderunner pos on image left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            cmp #LRZ_LodeRuOnImgPosX_Max + $01 ; test max PosX
                            bcc GoLodeRuGetGold             ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #LR_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_LodeRuCol               ; inc actual col loderunner
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_LodeRunner      ; get loderunner
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set loderunner min PosX of a screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_LodeRuOnImgPosX_Min    ; get min right
                            sta LRZ_LodeRuOnImgPosX         ; set loderunner pos on image left/right
                            beq GetCtrlTileUnderLodeRu      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlTileUnderLodeRu      ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is a pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq GetSpriteNumbers_Pole       ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number run right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_LodeRuSprtNumRunRi_00  ; get sprite numbers move right min
                            ldx #LRZ_LodeRuSprtNumRunRi_02  ; get sprite numbers move right max
                            bne GoGoSetNextSpriteNumber     ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number pole right
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumbers_Pole       lda #LRZ_LodeRuSprtNumPoleRi_00 ; get sprite numnumber hang along a pole right min
                            ldx #LRZ_LodeRuSprtNumPoleRi_02 ; get sprite numnumber hang along a pole right max
                            
GoGoSetNextSpriteNumber     jsr LodeRuMoveSpriteNumRotate   ; rotate loderunner sprite number between min and max values
                            jmp LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRunMoveUp             Does    : try to move loderunner up
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRunMoveUp              .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq GetLodeRuImagePosY          ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuOnImgPosY         ; get loderunner pos on image up/down
                            cpy #LRZ_LodeRuOnImgPosY_Mid + $01 ; test loderunner above the image center
                            bcc LodeRuMoveUpImpossible      ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level tile beyond loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3) + 1 = data below lr
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the tile beyond loderunner is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq GoGetLodeRuPosXY            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; no ladder/blocked/on top row already - impossible to move up
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveUpImpossible      sec                             ; exit with flag no move up possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuImagePosY          ldy LRZ_LodeRuOnImgPosY         ; get loderunner pos on image up/down
                            cpy #LRZ_LodeRuOnImgPosY_Mid + $01 ; test below center
                            bcs GoGetLodeRuPosXY            ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on top of the screen already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            beq LodeRuMoveUpImpossible      ; check: top of screen - yes: no further move up possible
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row above loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo - $01,y  ; get expanded level data row pointer lo
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi - $01,y ; get expanded level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game level tile above loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) - 1 = data above lr
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
; check if game tile above loderunner is a trap door
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickTrap       ; test trap door
                            beq LodeRuMoveUpImpossible      ; check: EQ - yes: blocked - no move
; --------------------------------------------------------------------------------------------------------------------- ;
GoGetLodeRuPosXY            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            dec LRZ_LodeRuOnImgPosY         ; loderunner pos on image up/down = one step up
                            bpl GoLodeRuGetGold             ; check: move from actual to next up field not yet complete
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #LR_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_LodeRuRow               ; dec actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda #LR_TileNum_LodeRunner      ; get loderunner
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            lda #LRZ_LodeRuOnImgPosY_Max    ; get max PosY
                            sta LRZ_LodeRuOnImgPosY         ; ini loderunner vertical PosY on image
                            bne GetSpriteNumLimitsMoveUpDo  ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jsr LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number ladder
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumLimitsMoveUpDo  lda #LRZ_LodeRuSprtNumLadder_00 ; get sprite numbers climb up/do min
                            ldx #LRZ_LodeRuSprtNumLadder_01 ; get sprite numbers climb up/do max
                            jsr LodeRuMoveSpriteNumRotate   ; rotate loderunner sprite number between min and max values
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
                            
                            clc                             ; set flag move up was successfulgood end
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveDown            Does    : try to move loderunner down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveDown             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cpy #LRZ_LodeRuOnImgPosY_Mid    ; test above center of screen image
                            bcc GetLodeRuImagePosY          ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is on the bottom of the screen already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            cpy #LRZ_ScreenRow_Max          ; test bottom of screen
                            bcs LodeRuMoveDownImpossible    ; check: GE - yes: bottom reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3) + 1
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile below loderunner is a solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq LodeRuMoveDownImpossible    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the tile below loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne GetLodeRuImagePosY          ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked/on bottom row already - impossible to move down
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveDownImpossible    sec                             ; exit with flag no move down possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetLodeRuImagePosY          jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            
                            inc LRZ_LodeRuOnImgPosY         ; inc loderunner vertical pos on image - one step down
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is above the screen image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cmp #LRZ_LodeRuOnImgPosY_Max + $01 ; test still on screen image
                            bcc GoLodeRuGetGold             ; check: LT - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get the level ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile under loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetTileToLevelGameData      ; check: EQ - no
                            
                            lda #LR_TileNum_Empty           ; get empty substitution for normal brick
                            
SetTileToLevelGameData      sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; step loderunner col one position down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_LodeRuRow               ; inc actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store loderunner tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda #LR_TileNum_LodeRunner      ; get loderunner
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init lodrunner vertical pos on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_LodeRuOnImgPosY_Min    ; get min
                            sta LRZ_LodeRuOnImgPosY         ; ini loderunner vertical pos on image
                            
                            jmp LodeRunMoveUp.GetSpriteNumLimitsMoveUpDo ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GoLodeRuGetGold             jmp LodeRunMoveUp.GoLodeRuGetGold ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeftX          Does    : switch off loderunner shoot left/right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftX           .block                           ; 
                            jmp LodeRuShootLeft.SetLodeRuShootFinish ; set flag shoot finished and exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeftInit       Does    : init try to shoot a hole into a normal brick on the left side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftInit        .block                           ; 
                            lda #LR_LodeRuShoot_Le          ; get shoot left
                            sta LR_LodeRuShoot              ; ini shoot
                            sta LR_JoystickMoveDirY         ; ini movedir Y
                            sta LR_JoystickMoveDirX         ; ini movedir X
                            
                            lda #TabImageNumShootSparkLe_Min; get initial value
                            sta LRZ_ShootStepCtrl           ; ini loderunner shoot step image table offset
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootLeft           Does    : try to shoot a hole into a normal brick on the left side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeft            .block                           ; 
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            cpy #LRZ_ScreenRow_Max          ; test max row
                            bcs LodeRuShootLeftX            ; check: GE - yes: no normal walls left for shooting - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc row number
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner on leftmost pos already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            beq LodeRuShootLeftX            ; check: leftmost position - yes: no room left for shoot left - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile below left of loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile below left of loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne LodeRuShootLeftX            ; check: EQ - no: only normal bricks are shootable - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/control data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the game tile left of loderunner is empty - an enemy may interrupt the process
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            dey                             ; step one position left
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #LR_TileNum_Empty           ; test empty space
                            bne SetLodeRuScreenRowColDoLe   ; check: EQ - no: blocked no shoot left possible
; --------------------------------------------------------------------------------------------------------------------- ;
; center loderunner on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
                            lda #LRZ_LodeRuSprtNumRunLe_00  ; preset sprite number run left start
                            
                            cpx #LRZ_ShootStepCtrl_Switch_Le; test time to switch sprite num
                            bcs SetLodeRuSpriteNum          ; check: switch sprite - no
                            
                            lda #LRZ_LodeRuSprtNumShootLe   ; get sprite number shoot left
                            
SetLodeRuSpriteNum          sta LRZ_LodeRuSprtNum           ; set sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still alive
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; check shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabImageNumShootSparkLe_Max; test maximum loderunner shoot step image table offset
                            beq LodeRuShootLeftFinish       ; check: EQ - yes: open a hole in shoot direction
                            
                            cpx #TabImageNumShootSparkLe_Min; test minimum loderunner shoot step image table offset
                            beq GetImageShootSpark          ; check: EQ - yes: get appropriate spark image number
                            
                            lda TabImageNumShootSpark - $01,x ; get image number shoot spark
                            pha                             ; save image number shoot spark
                            
                            ldx LRZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one column left
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot spark
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
GetImageShootSpark          lda TabImageNumShootSpark,x     ; get shoot spark image number
                            pha                             ; save image number shoot spark
                            
                            ldx LRZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one col left
                            stx LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; output melted ground
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda TabImageNumShootMeltGround,x; get image shoot melts ground
                            inc LRZ_ScreenRow               ; inc screen row ($00-$0f)
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; advance shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ShootStepCtrl           ; inc loderunner shoot step image table offset
                            
                            clc                             ; set flag successful shoot left
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked left/interrupted by an enemy - no shoot possible - clean up traces
; --------------------------------------------------------------------------------------------------------------------- ;
; step screen row/col from loderunner level data row/col one position down/left for final image output
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuScreenRowColDoLe   ldy LRZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step one row down
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            dey                             ; step one col left
                            sty LRZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; output no shoot finish brick to left col on row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_BrickSoft       ; get normal brick - unsuccesful finish shooting
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            beq SetLodeRuShootFinish        ; check: min - yes: done
                            
                            dex                             ; dec loderunner shoot step image table offset
                            lda TabImageNumShootSpark,x     ; get previous spark image number
                            pha                             ; save spark image number
                            
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            ldx LRZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one row up
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore spark image number
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot flag to finished
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuShootFinish        lda #LR_LodeRuShoot_No          ; get flag shoot no
                            sta LR_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            sec                             ; set flag no shoot left possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; open a hole in shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootLeftFinish       ldx LRZ_LodeRuCol               ; get actual col loderunner
                            dex                             ; step one position left
                            jmp LodeRuShootFinish           ; open a hole in shoot direction
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRightX         Does    : exit point of LodeRuShootRight
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightX          .block                           ; 
                            jmp LodeRuShootRight.SetLodeRuShootFinish ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRightInit      Does    : init try to shoot a hole into a normal brick on the right side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightInit       .block                           ; 
                            lda #LR_LodeRuShoot_Ri          ; get shoot right
                            sta LR_LodeRuShoot              ; ini shoot
                            sta LR_JoystickMoveDirY         ; ini movedir Y
                            sta LR_JoystickMoveDirX         ; ini movedir X
                            
                            lda #TabImageNumShootSparkRi_Min; get initial value
                            sta LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootRight          Does    : try to shoot a hole into a normal brick on the right side of loderunner
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRight           .block                           ; 
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            cpy #LRZ_ScreenRow_Max          ; test max
                            bcs LodeRuShootRightX           ; check: GE - yes: no normal walls left for shooting - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc row number
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner on rightmost pos already
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            cpy #LRZ_ScreenCol_Max          ; test rightmost position
                            bcs LodeRuShootRightX           ; check: GE - yes: no room left for shoot right - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the game data tile below right of loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile below right of loderunner is a normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne LodeRuShootRightX           ; check: EQ - no: only normal bricks are shootable - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/control data row pointers to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            jsr GameSetLevelDataPtrsToRow   ; set level data pointers to start of selected row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the game tile right of loderunner is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            iny                             ; step one position right
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            cmp #LR_TileNum_Empty           ; test empty space
                            bne SetLodeRuScreenRowColDoRi   ; check: EQ - no: blocked no shoot right possible
; --------------------------------------------------------------------------------------------------------------------- ;
; center loderunner on image
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr LodeRuCenterImagePosX       ; center loderunner horizontally
                            jsr LodeRuCenterImagePosY       ; center loderunner vertically
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda #LRZ_LodeRuSprtNumRunRi_00  ; get sprite number run right start
                            
                            cpx #LRZ_ShootStepCtrl_Switch_Ri; test time to switch sprite num
                            bcs SetLodeRuSpriteNum          ; check: switch sprite - no 
                            
                            lda #LRZ_LodeRuSprtNumShootRi   ; get sprite number shoot right
                            
SetLodeRuSpriteNum          sta LRZ_LodeRuSprtNum           ; set loderunner sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; check if loderunner is still alive
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr LodeRuCaughtHandler         ; check if loderunner was caught by an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; check shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabImageNumShootSparkRi_Max; test max
                            beq LodeRuShootRightFinish      ; check: EQ - yes
                            
                            cpx #TabImageNumShootSparkRi_Min; test min
                            beq GetImageShootSpark          ; check: EQ - yes
                            
                            lda TabImageNumShootSpark - $01,x ; get image number shoot spark
                            pha                             ; save image number shoot spark
                            
                            ldx LRZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one col right
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot spark
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            
GetImageShootSpark          lda TabImageNumShootSpark,x     ; get shoot spark image number
                            pha                             ; save shoot spark image number
                            
                            ldx LRZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one col right
                            stx LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore image number shoot spark
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; setp screen row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenRow               ; inc screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; output melted ground - pointer is in the 2nd half of the table - needs subtraction
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            lda TabImageNumShootMeltGround - TabImageNumShootSparkRi_Min,x; get image shoot melts ground
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; advance shoot step image table pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ShootStepCtrl           ; inc loderunner shoot step image table offset
                            
                            clc                             ; set flag successful shoot right
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; blocked right/interrupted by an enemy - no shoot possible - clean up traces
; --------------------------------------------------------------------------------------------------------------------- ;
; step screen row/col from loderunner level data row/col one position down/right for final image output
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuScreenRowColDoRi   ldy LRZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step one row down
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            iny                             ; step one col right
                            sty LRZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; output shoot finish brick to right col on row beyond loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_BrickSoft       ; get normal brick - finished shooting
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            ldx LRZ_ShootStepCtrl           ; get loderunner shoot step image table offset
                            cpx #TabImageNumShootSparkRi_Min; test minimum loderunner shoot step image table offset
                            beq SetLodeRuShootFinish        ; check: EQ - yes: min reached - finished
                            
                            dex                             ; 
                            lda TabImageNumShootSpark,x     ; get shoot spark image number
                            pha                             ; save shoot spark image number
                            
                            ldx LRZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; set on column right
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            pla                             ; restore shoot spark image number
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set shoot flag to finished
; --------------------------------------------------------------------------------------------------------------------- ;
SetLodeRuShootFinish        lda #LR_LodeRuShoot_No          ; get flag shoot no
                            sta LR_LodeRuShoot              ; set $00=no $01=right $ff=left
                            
                            sec                             ; set flag no shoot right possible
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; open a hole in shoot direction
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootRightFinish      ldx LRZ_LodeRuCol               ; get actual col loderunner
                            inx                             ; step one position right
                            jmp LodeRuShootFinish           ; open a hole in shoot direction
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; convert a sprite image number into a sprite count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumSpriteLodeRu          = *       ; 
                            .byte $0b ; $00 - Run  Le 00
                            .byte $0c ; $01 - Run  Le 01
                            .byte $0d ; $02 - Run  Le 02
                            .byte $18 ; $03 - Pole Le 00
                            .byte $19 ; $04 - Pole Le 01
                            .byte $1a ; $05 - Pole Le 02
                            .byte $0f ; $06 - Fire Le
                            .byte $13 ; $07 - Fall Le
                            .byte $09 ; $08 - Run  Ri 00 = Level Tile Loderunner
                            .byte $10 ; $09 - Run  Ri 01
                            .byte $11 ; $0a - Run  Ri 02
                            .byte $15 ; $0b - Pole Ri 00
                            .byte $16 ; $0c - Pole Ri 01
                            .byte $17 ; $0d - Pole Ri 02
                            .byte $25 ; $0e - Fire Ri
                            .byte $14 ; $0f - Fall Ri
                            .byte $0e ; $10 - Ladder 00
                            .byte $12 ; $11 - Ladder 01
; --------------------------------------------------------------------------------------------------------------------- ;
; convert an image number into a image count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageNumShootSpark       = *       ; shoot image number tables left/right
TabImageNumShootSparkLe     = *       ; 
TabImageNumShootSparkLe_Min = * - TabImageNumShootSpark ; start of table left
                            .byte $1b ; $00 - shot spark le    00
                            .byte $1b ; $01 - shot spark le    00
                            .byte $1c ; $02 - shot spark le    01
                            .byte $1c ; $03 - shot spark le    01
                            .byte $1d ; $04 - shot spark le/ri 02
                            .byte $1d ; $05 - shot spark le/ri 03
                            .byte $1e ; $06 - shot spark le/ri 03
                            .byte $1e ; $07 - shot spark le/ri 03
                            .byte $00 ; $08 - empty space
                            .byte $00 ; $09 - empty space
                            .byte $00 ; $0a - empty space
                            .byte $00 ; $0b - empty space
TabImageNumShootSparkLe_Max = * - TabImageNumShootSpark ; end of table left
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageNumShootSparkRi     = *       ; 
TabImageNumShootSparkRi_Min = * - TabImageNumShootSpark ; start of table right
                            .byte $26 ; $00 - shot spark ri    00
                            .byte $26 ; $01 - shot spark ri    00
                            .byte $27 ; $02 - shot spark ri    01
                            .byte $27 ; $03 - shot spark ri    01
                            .byte $1d ; $04 - shot spark le/ri 02
                            .byte $1d ; $05 - shot spark le/ri 02
                            .byte $1e ; $06 - shot spark le/ri 03
                            .byte $1e ; $07 - shot spark le/ri 03
                            .byte $00 ; $08 - empty space
                            .byte $00 ; $09 - empty space
                            .byte $00 ; $0a - empty space
                            .byte $00 ; $0b - empty space
TabImageNumShootSparkRi_Max = * - TabImageNumShootSpark ; end of table right
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageNumShootMeltGround  = *       ; 
                            .byte $1f ; $0c - melt ground phase 00
                            .byte $1f ; $0d - melt ground phase 00
                            .byte $20 ; $0e - melt ground phase 01
                            .byte $20 ; $0f - melt ground phase 01
                            .byte $21 ; $00 - melt ground phase 02
                            .byte $21 ; $01 - melt ground phase 02
                            .byte $22 ; $02 - melt ground phase 03
                            .byte $22 ; $03 - melt ground phase 03
                            .byte $23 ; $04 - melt ground phase 04
                            .byte $23 ; $05 - melt ground phase 04
                            .byte $24 ; $06 - melt ground phase 05
                            .byte $24 ; $07 - melt ground phase 05
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; DemoHandler               Does    : control game demo mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
DemoHandler                .block                           ; 
                            lda LR_KeyNew                   ; get keyboard interaction
                            bne DemoEnd                     ; check: player keybord interaction - yes: end demo
                            
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            bne DemoRun                     ; check: player joystick interaction - no: continue demo
; --------------------------------------------------------------------------------------------------------------------- ;
; player interaction - end demo with sudden death
; --------------------------------------------------------------------------------------------------------------------- ;
DemoEnd                     lsr LRZ_DemoNoFunction          ; reset flad - used but has no function
                            lsr LR_LodeRuState              ; set LR_LodeRuState_Death
                            
                            lda #LR_NumLivesDemo            ; care for one hit death
                            sta LR_NumLives                 ; set one hit death
                            
                            rts                             ; exit end of demo
; --------------------------------------------------------------------------------------------------------------------- ;
; continue demo
; --------------------------------------------------------------------------------------------------------------------- ;
DemoRun                     lda LRZ_DemoMoveDuration        ; get duration demo move
                            bne DemoMoveContinue            ; check: not ended yet
; --------------------------------------------------------------------------------------------------------------------- ;
; old move has ended - get a new one
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; ini demo move table offset
                            lda (LRZ_DemoMoveDataPtr),y     ; get demo move type
                            sta LRZ_DemoMoveType            ; set demo move type (l/r/u/d/fire)
                            
                            iny                             ; inc demo move table offset
                            lda (LRZ_DemoMoveDataPtr),y     ; get demo move duration
                            sta LRZ_DemoMoveDuration        ; set demo move duration
; --------------------------------------------------------------------------------------------------------------------- ;
; advance demo move data pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_DemoMoveDataPtr_Lo      ; get demo data pointer LO
                            clc                             ; 
                            adc #TabDemoMoveEntry_Len       ; point to next demo data pair
                            sta LRZ_DemoMoveDataPtr_Lo      ; set demo data pointer LO
                            
                            lda LRZ_DemoMoveDataPtr_Hi      ; get demo data pointer HI
                            adc #$00                        ; add .C
                            sta LRZ_DemoMoveDataPtr_Hi      ; set demo data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; continue actual demo move
; --------------------------------------------------------------------------------------------------------------------- ;
DemoMoveContinue            lda LRZ_DemoMoveType            ; get demo move type (l/r/u/d/fire)
                            and #$0f                        ; isolate right nibble for up/do moves
                            tax                             ; set up/do move as table offset
                            
                            lda TabDemoJoystickMove,x       ; get demo joystick action
                            sta LR_JoystickMoveDirY         ; set demo move up/do
                            
                            lda LRZ_DemoMoveType            ; get demo move type (l/r/u/d/fire)
                            lsr a                           ; isolate left nibble for left/right moves
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            tax                             ; set le/ri move as table offset
                            
                            lda TabDemoJoystickMove,x       ; get demo joystick action
                            sta LR_JoystickMoveDirX         ; set demo move le/ri
                            
                            dec LRZ_DemoMoveDuration        ; dec duration demo move
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoJoystickMove         = *       ; 
                            .byte LR_JoystickMoveDirY_Up   ; 
                            .byte LR_JoystickMoveDirX_Le   ; 
                            .byte LR_JoystickMoveDirY_Do   ; 
                            .byte LR_JoystickMoveDirX_Ri   ; 
                            .byte LR_JoystickShoot_Ri      ; 
                            .byte LR_JoystickShoot_Le      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameInputHandler          Does    : set joystick actions or control dispatch of in game key routines
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameInputHandler           .block                           ; 
                            lda LR_GameMode                 ; get game mode - $00=start_screen $01=demo $02=play $03=play_from_edit $05=edit
                            cmp #LR_GameMode_Demo           ; test demo
                            beq DemoHandler                 ; check: EQ - yes: control demo
; --------------------------------------------------------------------------------------------------------------------- ;
; no demo - get key
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LR_KeyNew                   ; get new key entered
                            bne IniNewKey                   ; check: pressed - yes
                            
                            lda LR_ControllerType           ; get controler type  $ca=joystick  $cb=keyboard
                            cmp #LR_ControllerType_Keyboard ; test keyboard
                            beq GameInputHandlerX           ; check: EQ - yes
                            
GoJoystickControl           jmp GameSetJoystickAction       ; get and set joystick shoot or move directions
; --------------------------------------------------------------------------------------------------------------------- ;
IniNewKey                   lda #LR_KeyNew_None             ; get initial value
                            sta LR_KeyNew                   ; ini new key input
                            
                            stx LRZ_WorkKeyNew              ; save new key entered
                            
                            ldy #$ff                        ; preset -1 to allow loop start inc
SetNextIngameKeyTabOff      iny                             ; 
                            lda TabIGC_CmdChar,y            ; get in game keys tab value  (U F Run/Stop R A J K + - Z D)
                            beq ChkControllerType           ; check: EoT command key - yes: no legal command key found
                            
                            cmp LRZ_WorkKeyNew              ; test with new key entered
                            bne SetNextIngameKeyTabOff      ; check: EQ - no: continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch in game key routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; 
                            asl a                           ; *2
                            tay                             ; 
                            
                            lda TabIGC_CmdAddress + $01,y   ; get ingame key routine address HI
                            pha                             ; push as return address HI
                            
                            lda TabIGC_CmdAddress + $00,y   ; get ingame key routine address LO
                            pha                             ; push as return address LO
                            
                            rts                             ; dispatch command
; --------------------------------------------------------------------------------------------------------------------- ;
ChkControllerType           lda LR_ControllerType           ; get controler type  $ca=joystick  $cb=keyboard
                            cmp #LR_ControllerType_Joystick ; test joystick
                            beq GoJoystickControl           ; check: EQ - yes
                            
                            ldx LRZ_WorkKeyNew              ; get new key entered
                            stx LR_JoystickMoveDirY         ; set jostick move Y
                            stx LR_JoystickMoveDirX         ; set jostick move X
                            
GameInputHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_LevelNext             Does    : in game cmd: play next level
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_LevelNext              .block                           ; 
                            inc LR_NumLives                 ; inc lives
                            
                            inc LR_LevelNumGame             ; game level number 001-150
                            inc LR_LevelNumDisk             ; disk level number 000-149
                            
                            lsr LR_LodeRuState              ; set LR_LodeRuState_Death
                            lsr LR_Cheated                  ; set LR_Cheated_Yes
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_IncNumLife            Does    : in game cmd: increase life counter
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_IncNumLife             .block                           ; 
                            inc LR_NumLives                 ; inc lives
                            bne NumLivesOut                 ; check: max reached - no
                            
                            dec LR_NumLives                 ; dec again - limit to $ff (255)
                            
NumLivesOut                 jsr StatusOutLives              ; write out number of lives
                            
                            lsr LR_Cheated                  ; set LR_Cheated_Yes
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_UnDispatched          Does    : in game cmd: inc lives and game speed - not dispatched
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_UnDispatched           .block                           ; 
                            inc LR_GameSpeedCtrl            ; 
                            inc LR_NumLives                 ; 
                            
                            lsr LR_LodeRuState              ; LR_LodeRuState_Death
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Pause                 Does    : in game cmd: pause the game until next RUN/STOP is pressed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Pause                  .block                           ; 
GetNextPauseKey             jsr GetNewKey                   ; wait for a input key set in IRQ
                            
                            cmp #$3f                        ; test <RUN/STOP>
                            bne GetNextPauseKey             ; check: EQ - no: continue pause
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Resign                Does    : in game cmd: resign
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Resign                 .block                           ; 
                            jmp GameOver                    ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Suicide               Does    : in game cmd: commit suicide
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Suicide                .block                           ; 
                            lsr LR_LodeRuState              ; set LR_LodeRuState_Death
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetJoystick           Does    : in game cmd: set input to joystick
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetJoystick            .block                           ; 
                            lda #LR_ControllerType_Joystick ; get joystick
                            sta LR_ControllerType           ; set controller type
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_SetKeyboard           Does    : in game cmd: set input to keyboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_SetKeyboard            .block                           ; 
                            lda #LR_ControllerType_Keyboard ; get keyboard
                            sta LR_ControllerType           ; set controller type
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_DecSpeed              Does    : in game cmd: decrease game speed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_DecSpeed               .block                           ; 
                            lda LR_GameSpeed                ; get game speed for decrease
                            cmp #LR_GameSpeed_Min           ; test min
                            beq IGC_IncSpeed.IGC_IncSpeedX  ; check: EQ - yes: bypass decrease
                            
                            dec LR_GameSpeed                ; slow down
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_IncSpeed              Does    : in game cmd: increase game speed
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_IncSpeed               .block                           ; 
                            lda LR_GameSpeed                ; get game speed for increase
                            cmp #LR_GameSpeed_Max           ; test max
                            beq IGC_IncSpeedX               ; check: EQ - yes: bypass increase
                            
                            inc LR_GameSpeed                ; speed up
                            
IGC_IncSpeedX               jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_Cycle                 Does    : in game cmd: toggle start circle
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_Cycle                  .block                           ; 
                            lda LR_StartCycle               ; 
                            eor #$ff                        ; toggle cycle flag
                            sta LR_StartCycle               ; 
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; IGC_ShootMode             Does    : in game cmd: toggle shoot mode
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
IGC_ShootMode              .block                           ; 
                            lda LR_LodeRuShootMode          ; 
                            eor #$ff                        ; toggle shoot mode
                            sta LR_LodeRuShootMode          ; 
                            
                            jmp GameInputHandler            ; get keyboard and joystick input - dispatch in game key routines
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSetJoystickAction     Does    : get and set joystick shoot or move directions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSetJoystickAction      .block                           ; 
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            bne ChkJoystickMoves            ; check: shoot - no: check move directions
; --------------------------------------------------------------------------------------------------------------------- ;
; was shoot - handle mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_LodeRuShootMode         ; get shoot mode
                            eor LR_LodeRuShootMode          ; toggle shoot mode
                            bpl ShootLeft                   ; check: shoot mode LRZ_LodeRuShootMode_Back - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; shoot right and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_JoystickShoot_Ri        ; get shoot right
                            sta LR_JoystickMoveDirY         ; set shoot right Y
                            sta LR_JoystickMoveDirX         ; set shoot right X
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; shoot left and exit
; --------------------------------------------------------------------------------------------------------------------- ;
ShootLeft                   lda #LR_JoystickShoot_Le        ; get shoot left
                            sta LR_JoystickMoveDirY         ; set shoot left Y
                            sta LR_JoystickMoveDirX         ; set shoot left X
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick directional moves
; --------------------------------------------------------------------------------------------------------------------- ;
ChkJoystickMoves            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            sta LRZ_WorkJoystickMove        ; save CIA value
                            
                            and #CIAPRA_JOY_DO              ; Bit 1: Joystick 2 - Down  0=pressed
                            beq GetJoystickMove_Down        ; check: down - yes: set down
                            
                            lda LRZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_UP              ; Bit 0: Joystick 2 - Up    0=pressed
                            beq GetJoystickMove_Up          ; check: up - yes: set up
; --------------------------------------------------------------------------------------------------------------------- ;
; clear joystick move up_down
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #LR_JoystickMove_None       ; get no move
                            stx LR_JoystickMoveDirY         ; ini move up_down
                            beq ChkMoves_Left_Right         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Up          ldx #LR_JoystickMoveDirY_Up     ; get move up
                            stx LR_JoystickMoveDirY         ; set move up
                            bne ChkMoves_Left_Right         ; always
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Down        ldx #LR_JoystickMoveDirY_Do     ; get move down
                            stx LR_JoystickMoveDirY         ; set move down
; --------------------------------------------------------------------------------------------------------------------- ;
ChkMoves_Left_Right         lda LRZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_RI              ; Bit 3: Joystick 2 - Right 0=pressed
                            beq GetJoystickMove_Right       ; check: right - yes: set right
                            
                            lda LRZ_WorkJoystickMove        ; get saved CIA value
                            and #CIAPRA_JOY_LE              ; Bit 2: Joystick 2 - Left  0=pressed
                            beq GetJoystickMove_Left        ; check: left - yes: set left
; --------------------------------------------------------------------------------------------------------------------- ;
; clear joystick move left_right and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #LR_JoystickMove_None       ; get move none
                            stx LR_JoystickMoveDirX         ; set move none
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Right       ldx #LR_JoystickMoveDirX_Ri     ; get move right
                            stx LR_JoystickMoveDirX         ; set move right
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GetJoystickMove_Left        ldx #LR_JoystickMoveDirX_Le     ; get move left
                            stx LR_JoystickMoveDirX         ; set move left
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; in game commands
; --------------------------------------------------------------------------------------------------------------------- ;
TabIGC_CmdChar              = *       ; 
                            .byte $9e ; U        - next level
                            .byte $95 ; F        - increase lives
                            .byte $3f ; RUN/STOP - pause
                            .byte $91 ; R        - resign
                            .byte $8a ; A        - restart
                            .byte $a2 ; J        - joystick control
                            .byte $a5 ; K        - keyboard control
                            .byte $2b ; +        - inc game speed
                            .byte $28 ; -        - dec game speed
                            .byte $8c ; Z        - toggle start cycle
                            .byte $92 ; D        - toggle shoot mode
                            
                            .byte $00 ; end of game command table
; --------------------------------------------------------------------------------------------------------------------- ;
TabIGC_CmdAddress           .word IGC_LevelNext   - $01 ; U        - try Next Level
                            .word IGC_IncNumLife  - $01 ; F        - increase number of lives
                            .word IGC_Pause       - $01 ; RUN/STOP - pause the game
                            .word IGC_Resign      - $01 ; R        - resign the game
                            .word IGC_Suicide     - $01 ; A        - commit suizide
                            .word IGC_SetJoystick - $01 ; J        - set joystick control
                            .word IGC_SetKeyboard - $01 ; K        - set keyboard control
                            .word IGC_IncSpeed    - $01 ; +        - inc game speed
                            .word IGC_DecSpeed    - $01 ; -        - dec game speed
                            .word IGC_Cycle       - $01 ; Z        - toggle level start cycle
                            .word IGC_ShootMode   - $01 ; D        - toggle shoot mode
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetImageAndPosXY    Does   : get loderunner image number and PosXY
;                           Expects : 
;                           Returns : .A=loderunner image number
;                                   : .X=loderunner PosX
;                                   : .Y=loderunner PosY
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetImageAndPosXY     .block                           ; 
                            ldx LRZ_LodeRuCol               ; get actual col loderunner
                            ldy LRZ_LodeRuOnImgPosX         ; get loderunner pos on image left/right
                            jsr ScreenAddGfxOnImagePosX     ; add horizontal gfx screen image offset
                            
                            stx LRZ_WorkImgOffsetPosX       ; save horizontal offset
                            
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            ldx LRZ_LodeRuOnImgPosY         ; get loderunner vertical pos on image
                            jsr ScreenAddGfxOnImagePosY     ; add vertical gfx screen image offset
                            
                            ldx LRZ_LodeRuSprtNum           ; get loderunner sprite number
                            lda TabNumSpriteLodeRu,x        ; get loderunner image number
                            
                            ldx LRZ_WorkImgOffsetPosX       ; restore horizontal offset
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuGetGold             Does    : let loderunner pick up a piece of gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuGetGold               .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check center PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_LodeRuOnImgPosX         ; get loderunner on image PosX
                            cmp #LRZ_LodeRuOnImgPosX_Mid    ; test centered
                            bne LodeRuGetGoldX              ; check: centered - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check center PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_LodeRuOnImgPosY         ; get loderunner on image PosY
                            cmp #LRZ_LodeRuOnImgPosY_Mid    ; test centered
                            bne LodeRuGetGoldX              ; check: centered - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; lode runner is PosX/PosY centered
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile under loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if ctrl data tile under loderunner is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Gold            ; test gold
                            bne LodeRuGetGoldX              ; check: EQ - no: exit
                            
                            lsr LR_LodeRuGetGold            ; set flag lodrunner just gets gold
; --------------------------------------------------------------------------------------------------------------------- ;
; prepare a randomized got gold jingle
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #$10                        ; get bottom limit
                            ldy #$20                        ; get upper limit
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            
                            sta TabGoldJinglePart_01 + $01  ; set 1st tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_02 + $01  ; set 2nd tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_03 + $01  ; set 3rd tune data pointer voice 2
                            
                            lda #$04                        ; get lower limit
                            jsr LodeRuGetGoldJingleVal      ; return RND raster beam position within given limits
                            sta TabGoldJinglePart_04 + $01  ; set 4th tune data pointer voice 2
                            
                            jsr LodeRuSetGetGoldJingle      ; jingle data must follow directly
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart           = *       ; 
TabGoldJinglePart_01        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $b0 ; tune s/r/volume  (not used)
TabGoldJinglePart_Len       = * - TabGoldJinglePart ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_02        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $a0 ; tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_03        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $90 ; tune s/r/volume  (not used)
; --------------------------------------------------------------------------------------------------------------------- ;
TabGoldJinglePart_04        = *       ; 
                            .byte $04 ; tune time
                            .byte $00 ; tune data pointer voice 2
                            .byte $ff ; tune data pointer voice 3
                            .byte $a0 ; tune s/r/volume  (not used)
                            
                            .byte $00 ; end of tune marker
; --------------------------------------------------------------------------------------------------------------------- ;
; discount picked up gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LR_GoldToCollect            ; discount gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen row/col to loderunner row/col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy LRZ_LodeRuCol               ; get actual col loderunner
                            sty LRZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Empty           ; get empty space
                            sta (LRZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx LRZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #LR_TileNum_Gold            ; get gold
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; score gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #>LR_Score_Gold             ; score add value HI - gold scores 250 points
                            lda #<LR_Score_Gold             ; score add value LO
                            jsr StatusOutScore              ; score and update status row
                            
LodeRuGetGoldX              rts                             ; exit
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuMoveSpriteNumRotate Does    : rotate loderunner sprite number between minimum and maximum values
;                           Expects : .A=sprite number min
;                                   : .X=sprite number max
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuMoveSpriteNumRotate  .block                           ; 
                            inc LRZ_LodeRuSprtNum           ; inc sprite number to next phase
                            
                            cmp LRZ_LodeRuSprtNum           ; test lower limit
                            bcc ChkUpperLimit               ; check: LT - yes: check max
                            
SetToMinValue               sta LRZ_LodeRuSprtNum           ; reset to min value
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkUpperLimit               cpx LRZ_LodeRuSprtNum           ; test upper limit
                            bcc SetToMinValue               ; check: LT - yes: reset to lower limit
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCaughtHandler       Does    : control loderunner caught by an enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCaughtHandler        .block                           ; 
                            jsr LodeRuGetImageAndPosXY      ; get loderunner image number and PosXY
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            lda LRZ_LodeRuEnemyCollision    ; get sprite collision  $01=lr caught
                            beq LodeRuCaughtHandlerX        ; check: caught - no: exit
                            
                            lda LR_LodeRuGetGold            ; get flag gold  $00=just gets it
                            beq LodeRuCaughtHandlerX        ; check: just picking up gold - yes
                            
                            lsr LR_LodeRuState              ; set LR_LodeRuState_Death
                            
LodeRuCaughtHandlerX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCenterImagePosX     Does    : center loderunnner on screen image horizontally
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosX      .block                           ; 
                            lda LRZ_LodeRuOnImgPosX         ; get loderunner PosX on image
                            cmp #LRZ_LodeRuOnImgPosX_Mid    ; test center
                            bcc IncPosX                     ; check: LT - yes: left of center
                            beq LodeRuCenterImagePosXX      ; check: EQ - yes: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; right of tile image center
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_LodeRuOnImgPosX         ; GT - dec loderunner PosX on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; left of tile image center
; --------------------------------------------------------------------------------------------------------------------- ;
IncPosX                     inc LRZ_LodeRuOnImgPosX         ; inc loderunner PosX on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosXX      rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuCenterImagePosY     Does    : center loderunnner on screen image vertically
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosY      .block                           ; 
                            lda LRZ_LodeRuOnImgPosY         ; get loderunner PosY on image
                            cmp #LRZ_LodeRuOnImgPosY_Mid    ; test center
                            bcc IncPosY                     ; check: LT - yes: above center
                            beq LodeRuCenterImagePosYX      ; check: EQ - yes: exit - nothing to do
; --------------------------------------------------------------------------------------------------------------------- ;
; below center
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_LodeRuOnImgPosY         ; GT - dec loderunner PosY on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
; above center
; --------------------------------------------------------------------------------------------------------------------- ;
IncPosY                     inc LRZ_LodeRuOnImgPosY         ; lower - inc loderunner PosY on image
                            jmp LodeRuGetGold               ; wait for center and pic up/score the gold
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuCenterImagePosYX      rts                             ; equal - nothing to do
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LodeRuShootFinish         Does    : open a hole in shoot direction - shoot finished successfully
;                           Expects : .X=colum number
;                           Returns : .C=1 - success
;                                   : .C=0 - failed
; --------------------------------------------------------------------------------------------------------------------- ;
LodeRuShootFinish          .block                           ; 
                            lda #LR_LodeRuShoot_No          ; get initial value
                            sta LR_LodeRuShoot              ; ini shoot to off
                            
                            ldy LRZ_LodeRuRow               ; get actual row loderunner
                            iny                             ; step to row below loderunner
                            
                            stx LRZ_ScreenCol               ; set screen col ($00-$1b)
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new row below loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; store an empty level tile below loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Empty           ; get empty
                            ldy LRZ_ScreenCol               ; get screen col ($00-$1b)
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #LR_TileNum_Empty           ; get emtpy tile
                            jsr ScreenImageOutToPrepare     ; clear tile under loderunner
                            
                            dec LRZ_ScreenRow               ; set screen row above hole
                            lda #LR_TileNum_Empty           ; get empty tile
                            jsr ScreenImageOutToDisplay     ; clear tile above hole
                            inc LRZ_ScreenRow               ; restore screen row to hole
                            
                            ldx #$ff                        ; preset WA offset to -1 to allow next inx
; --------------------------------------------------------------------------------------------------------------------- ;
; search a free slot in open hole time work area
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextHoleOpenTimeOff      inx                             ; inc WA offset
                            cpx #LR_WA_HoleMax              ; test max WA length
                            beq LodeRuOpenShootHoleX        ; check: EQ - yes: max slots reached - exit fault
                            
                            lda LR_WA_HoleOpenTime,x        ; get hole open time tab
                            bne SetNextHoleOpenTimeOff      ; check: already used - yes: continue search
; --------------------------------------------------------------------------------------------------------------------- ;
; a free slot found - occupy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_ScreenRow               ; get screen row ($00-$0f)
                            sta LR_WA_HoleRow,x             ; save in hole row tab
                            
                            lda LRZ_ScreenCol               ; get screen col ($00-$1b)
                            sta LR_WA_HoleCol,x             ; save in hole column tab
                            
                            lda #LR_WA_HoleOpenTime_Ini     ; get initial value
                            sta LR_WA_HoleOpenTime,x        ; ini hole open time tab entry
                            
                            sec                             ; set flag success
                            
LodeRuOpenShootHoleX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveHandler          Does    : control all enemy moves
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveHandler           .block                           ; 
                            ldx LR_EnemyCount               ; get number of enemies ($00-$05)
                            beq EnemyMoveHandlerX           ; check: is there any enemy to move - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; handle enemy zero page move control tab offset - values were calculated from game speed/enemy count in MainLoopInit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_EnemyMoveCycleOff       ; inc offset actual enemy move cycle values
                            
                            ldy LRZ_EnemyMoveCycleOff       ; get offset actual enemy move cycle values
                            cpy #LRZ_EnemyMoveCycleOff_Max  ; test max
                            bcc GetNextMoveCycle            ; check: LT - yes: try a move
                            
                            ldy #LRZ_EnemyMoveCycleOff_Min  ; get initial value
                            sty LRZ_EnemyMoveCycleOff       ; ini offset enemy move cycle values
; --------------------------------------------------------------------------------------------------------------------- ;
; get an enemy move control table value
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextMoveCycle            lda LRZ_EnemyMoveCycle,y        ; get enemy move cycle value
                            sta LRZ_EnemyMoveCycleWork      ; set enemy move cycle work
                            
ShiftNextMoveEnableBit      lsr LRZ_EnemyMoveCycleWork      ; shift out an enemy move control bit
                            bcc GetEnemyMoveCtrlFlags       ; check: was move bit set - no: check if finished
                            
                            jsr EnemyMove                   ; move an enemy if move bit was set
                            
                            lda LR_LodeRuState              ; get loderunner heartbeat
                            beq EnemyMoveHandlerX           ; check: still alive - no: was caught - exit
                            
GetEnemyMoveCtrlFlags       lda LRZ_EnemyMoveCycleWork      ; get enemy move cycle work
                            bne ShiftNextMoveEnableBit      ; check: still move bits available - yes: continue
                            
EnemyMoveHandlerX           rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; offset to table values calculated in MainLoopInit: LR_GameSpeedCtrl + LR_EnemyCount
; actual values store in zero page LRZ_EnemyMoveCycle
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCycles          = *             ; 
TabEnemyMoveCycle_01        = * + $00       ; 
TabEnemyMoveCycle_02        = * + $01       ; 
TabEnemyMoveCycle_03        = * + $02       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_00  = *             ; 
                            .byte %00000000 ; 
                            .byte %00000000 ; 
                            .byte %00000000 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_01  = *             ; values for default speed and max 5 enemies
                            .byte %00000000 ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_02  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_03  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000011 ; 
                            .byte %00000001 ; 
TabEnemyMoveCyclesBlock_04  = *             ; 
                            .byte %00000001 ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
TabEnemyMoveCyclesBlock_05  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_06  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000011 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_07  = *             ; 
                            .byte %00000011 ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_08  = *             ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
TabEnemyMoveCyclesBlock_09  = *             ; 
                            .byte %00000111 ; 
                            .byte %00000111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0a  = *             ; max game speed
                            .byte %00000111 ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0b  = *             ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
TabEnemyMoveCyclesBlock_0c  = *             ; 
                            .byte %00001111 ; 
                            .byte %00001111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0d  = *             ; 
                            .byte %00001111 ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0e  = *             ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
                            .byte %00011111 ; 
TabEnemyMoveCyclesBlock_0f  = *             ; max game speed + max enemy number
                            .byte %00011111 ; 
                            .byte %00011111 ; 
                            .byte %00111111 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveCyclesBlock_10  = *             ; 
                            .byte %00011111 ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
TabEnemyMoveCyclesBlock_11  = *             ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
TabEnemyMoveCyclesBlock_12  = *             ; 
                            .byte %00111111 ; 
                            .byte %00111111 ; 
                            .byte %01111111 ; 
TabEnemyMoveCyclesBlock_13  = *             ; 
                            .byte %00111111 ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
TabEnemyMoveCyclesBlock_14  = *             ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
                            .byte %01111111 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; convert a sprite image number into a sprite count number
; --------------------------------------------------------------------------------------------------------------------- ;
TabNumSpriteEnemy           = *       ; 
                            .byte $08 ; $00 - Run  Le 00 = Level Tile Enemy
                            .byte $2b ; $01 - Run  Le 01
                            .byte $2c ; $02 - Run  Le 02
                            .byte $30 ; $03 - Pole Le 00
                            .byte $31 ; $04 - Pole Le 01
                            .byte $32 ; $05 - Pole Le 02
                            .byte $36 ; $06 - Fall Le
                            .byte $28 ; $07 - Run  Ri 00
                            .byte $29 ; $08 - Run  Ri 01
                            .byte $2a ; $09 - Run  Ri 02
                            .byte $2d ; $0a - Pole Ri 00
                            .byte $2e ; $0b - Pole Ri 01
                            .byte $2f ; $0c - Pole Ri 02
                            .byte $35 ; $0d - Fall Ri
                            .byte $33 ; $0e - Ladder 00
                            .byte $34 ; $0f - Ladder 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMove                 Does    : select and move the next enemy
;                           Expects : 
;                           Returns : 
;                           Remark  : 1st: check if enemy is still locked up in a hole
;                                   :      continue getting him out
;                                   : 2nd: check the tile under enemy
;                                   :      Ladder/Pole                      --> EnemyMoveDispatcher
;                                   : 3rd: check the tile below enemy
;                                   :      Empty/Pole/Trap/Gold/LodeRunner  --> EnemyFallDownHandler
;                                   :      BrickSoft/BrickHard/Ladder/Enemy --> EnemyMoveDispatcher
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMove                  .block                           ; 
                            inc LR_EnemyToMoveNum           ; inc count to next enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; rotate the enemy to move number
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LR_EnemyCount               ; get number of enemies ($00-$05)
                            cpx LR_EnemyToMoveNum           ; test with number of enemy to move
                            bcs RestoreEnemyStatus          ; check: GE - no: max not reached - bypass reset
                            
                            ldx #LR_EnemyToMoveNum_Min      ; get reset to first enemy
                            stx LR_EnemyToMoveNum           ; init enemy to move number
; --------------------------------------------------------------------------------------------------------------------- ;
; reactivate the selected enemy
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreEnemyStatus          jsr EnemyMoveStatusRestore      ; restore enemy status from save area
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy is still captured in a hole or still carries gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyHoleGoldTime       ; get either has gold or locked in a hole time
                            bmi EnemyMovable                ; check: still carries gold - yes
                            beq EnemyMovable                ; check: gold/hole time up - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; positive - enemy is still trapped in a hole - reduce the in hole time
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_EnemyHoleGoldTime       ; discount enemy is locked in a hole time
; --------------------------------------------------------------------------------------------------------------------- ;
; test in hole time final seconds - eventually shiver/get him out
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            cpy #LRZ_EnemyHoleGoldTime_Shake; test 1st mark - start shaking out of hole
                            bcs ChkEnemyRebirthTime         ; check: GE - yes: bring him back to live
                            
                            jmp EnemyShiverOutOfHole        ; exit - shiver enemy out of hole
; --------------------------------------------------------------------------------------------------------------------- ;
; test enemy rebirth time - eventually continue waiting for rebirth
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyRebirthTime         ldx LR_EnemyToMoveNum           ; get number of enemy to move
                            lda LR_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            beq GoEnemyDisplayAndDisable    ; check: did rebirth time ran out - yes: display and disable him
                            
                            jmp EnemyMoveStatusSave         ; store his status to save area again
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyDisplayAndDisable    jmp EnemyDisplayAndDisable      ; display enemy and disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy not locked up in a hole
;           actual row: Ladder/Pole                      --> EnemyMoveDispatcher - on a pole enemy must be centerd first
; row below actual row: Empty/Pole/Trap/Gold/LodeRunner  --> EnemyFallDownHandler
;                       BrickSoft/BrickHard/Ladder/Enemy --> EnemyMoveDispatcher
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovable                ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile this enemy is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> dispatch next enemy move
; Pole   --> fall down to image center - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a ladder - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him immediately
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a pole - wait for image center - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            bne ChkEnemyOnImageCenter       ; check: EQ - no: test image center position for a fall
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a pole - wait for image center - dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #LRZ_EnemyOnImgPosY_Mid     ; test center
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try move him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check enemy tile position - let him fall further down if not
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyOnImageCenter       lda LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #LRZ_EnemyOnImgPosY_Mid     ; test center
                            bcc EnemyFallDownHandler        ; check: LT - yes: still above center so let him fall
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is below the image center - check if on last row - end of fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            cpy #LRZ_ScreenRow_Max          ; test enemy on max row already
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: end of fall - try to move him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data ptr LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data ptr LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer HI
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data ptr HI
                            
                            lda TabGameLevelDataRow_Hi + $01,y ; get expanded level data row pointer HI
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty      --> let enemy fall down
; LodeRunner --> let enemy fall down
; Enemy      --> dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is empty - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Empty           ; test empty space
                            beq EnemyFallDownHandler        ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a loderunner - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_LodeRunner      ; test loderunner
                            beq EnemyFallDownHandler        ; check: EQ - yes: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is an enemy - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Enemy           ; test enemy
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> dispatch next enemy move
; SolidBrick  --> dispatch next enemy move
; Ladder      --> dispatch next enemy move
; All other   --> let enemy fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a normal brick - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a solid brick - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq GoEnemyMoveDispatcher       ; check: EQ - yes: try to move him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row below enemy row is a ladder - yes: dispatch next enemy move
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne EnemyFallDownHandler        ; check: EQ - no: let him fall down
; --------------------------------------------------------------------------------------------------------------------- ;
; dispatch next enemy move if he stands on a BrickSoft/BrickHard/Ladder/Enemy
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyMoveDispatcher       jmp EnemyMoveDispatcher         ; try to move this enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyFallDownHandler      Does    : control enemy fall down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyFallDownHandler       .block                           ; 
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
                            
                            lda #LRZ_EnemySprtNum_Fall_Le   ; preset sprite number fall left
                            
                            ldy LRZ_EnemyViewDir            ; get actual enemy view dir right/left  $ff=left  $01=right
                            bmi SetEnemySprtNum             ; check: left - yes
                            
                            lda #LRZ_EnemySprtNum_Fall_Ri   ; get sprite number fall right
; --------------------------------------------------------------------------------------------------------------------- ;
; set the view dir dependend sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemySprtNum             sta LRZ_EnemySprtNum            ; set actual enemy sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; step enemy on screen image down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_EnemyOnImgPosY          ; step actual enemy on image down
; --------------------------------------------------------------------------------------------------------------------- ;
; test if enemy has left the screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #LRZ_EnemyOnImgPosY_Max + $01 ; test max
                            bcs EnemyFallDown               ; check: GE - yes: enemy has left this screen image downwards
; --------------------------------------------------------------------------------------------------------------------- ;
; test if enemy is in the center of the screen image
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #LRZ_EnemyOnImgPosY_Mid     ; test center
                            bne EnemyDisplayAndDisable      ; check: EQ - no: wait - display and disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; try to pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy has fallen into a hole
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> captured in a hole - init timer - score digging in
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is a normal brick - yes: captured in a hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne EnemyDisplayAndDisable      ; check: EQ - no: display and disable him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy sitting in a hole still has gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            bpl IniEnemyHoleTime            ; check: still carries gold - no
; --------------------------------------------------------------------------------------------------------------------- ;
; timer is negative - enemy still has gold for some reason
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LR_GoldToCollect            ; some gold has vanished - discount gold to collect
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy in hole time value
; --------------------------------------------------------------------------------------------------------------------- ;
IniEnemyHoleTime            lda LR_EnemyInHoleTime          ; get initial time value taken from TabEnemyInHoleTime
                            sta LRZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
; --------------------------------------------------------------------------------------------------------------------- ;
; a digged in enemy scores 75 points
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #>LR_Score_EnemyDigIn       ; score add value HI
                            lda #<LR_Score_EnemyDigIn       ; score add value LO
                            jsr StatusOutScore              ; score and update status row
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyDisplayAndDisable    Does    : display enemy and deactivate enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyDisplayAndDisable     .block                           ; 
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyFallDown             Does    : let an enemy fall down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyFallDown              .block                           ; 
                            lda #LRZ_EnemyOnImgPosY_Min     ; get intial value 
                            sta LRZ_EnemyOnImgPosY          ; ini actual enemy pos on image up/down
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> empty it in ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on enemy row is a normal brick - yes: empty it in ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne CopyCtrlTileToGameTile      ; check: NE - yes: skip replacemanet
; --------------------------------------------------------------------------------------------------------------------- ;
; replace ctrl normal brick tile by empty tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Empty           ; get empty tile substitution
                            
CopyCtrlTileToGameTile      sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; let enemy fall down - step enemy row one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_EnemyRow                ; let enemy fall down a row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to new row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on new row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> caught - set loderunner death flag
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on new row below enemy row is loderunner - yes: caught - kill him
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_LodeRunner      ; test loderunner
                            bne GetCtrlDataTile             ; check: NE - yes: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - kill him
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr LR_LodeRuState              ; loderunner caught - set LR_LodeRuState_Death
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
GetCtrlDataTile             lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; NormalBrick --> locked up in a hole - try to drop a possible gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a normal brick - yes: locked up in a hole - drop gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne InsEnemyTileIntoGameData    ; check: NE - yes: not in hole - deactivate him
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; if an enemy is directly on a normal brick in ctrl data - captured in a hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            bpl InsEnemyTileIntoGameData    ; check: still locked in hole - yes: deactivate him
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy has fallen into a hole - try to drop a possible gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen row to row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            dey                             ; step one row up
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; set screen col to enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            sty LRZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; the tile directly above an enemy must be empty - otherwise his gold cannot be dropped
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> drop the gold he carries
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is empty - yes: drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Empty           ; test empty space
                            beq EnemyDropsHisGold           ; check: EQ - yes: drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
; loose this piece of gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LR_GoldToCollect            ; a piece of gold was lost
                            jmp ResetLevelDataPointer       ; 
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; drop gold directly above enemy 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyDropsHisGold           lda #LR_TileNum_Gold            ; get gold
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (LRZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx LRZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #LR_TileNum_Gold            ; get gold
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl/game data row pointers to new row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
ResetLevelDataPointer       ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; initialize enemy in hole timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyHoleGoldTime_None ; get initial value
                            sta LRZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; insert enemy tile number to game data - deactivate him
; --------------------------------------------------------------------------------------------------------------------- ;
InsEnemyTileIntoGameData    lda #LR_TileNum_Enemy           ; get enemy 
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyShiverOutOfHole      Does    : shiver the enemy in a hole just before he leaves
;                           Expects : .Y=enemy in hole time (here: $0c-$07 - counted down)
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyShiverOutOfHole       .block                           ; 
                            cpy #LRZ_EnemyHoleGoldTime_Shake_X ; test shake out of hole phase end
                            bcc EnemyMoveDispatcher         ; check: lower - yes: get him out
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
; use the remaining LRZ_EnemyHoleGoldTime ($0c-$07) value as offset for TabEnemyShake
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            lda TabEnemyShake - LRZ_EnemyHoleGoldTime_Shake_X,y ; get shiver out of hole value
                            sta LRZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyShake               = *       ; let enemy shiver from left to right before leaving a hole
                            .byte $02 ; $05 - $07 - offset exit value - LRZ_EnemyHoleGoldTime_Shake_X
                            .byte $01 ; $04 - $08
                            .byte $02 ; $03 - $09
                            .byte $03 ; $02 - $0a
                            .byte $02 ; $01 - $0b
                            .byte $01 ; $00 - $0c
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDispatcher       Does    : get an enemy move direction proposal and call the approriate move handler
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDispatcher        .block                           ; 
                            ldx LRZ_EnemyCol                ; get actual enemy col
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            
                            jsr EnemyMoveGetDirProposal     ; get a possible enemy move direction
                            
                            asl a                           ; move dir *2
                            tay                             ; set as table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; push enemy move dir routine to the stack
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabEnemyMoveDir + $01,y     ; get address move routine HI
                            pha                             ; push as return address to stack
                            lda TabEnemyMoveDir + $00,y     ; get address move routine LO 
                            pha                             ; push as return address to stack
                            
                            rts                             ; dispatch enemy move routine
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemyMoveDir             = *                             ; 
                            .word EnemyMoveStatusSave  -1   ; $00 - LR_EnemyMoveDir_None - save enemy status to save area
                            
                            .word EnemyMoveLeftHandler  -1  ; $01 - LR_EnemyMoveDir_Le
                            .word EnemyMoveRightHandler -1  ; $02 - LR_EnemyMoveDir_Ri
                            .word EnemyMoveUpHandler    -1  ; $03 - LR_EnemyMoveDir_Up
                            .word EnemyMoveDownHandler  -1  ; $04 - LR_EnemyMoveDir_Do
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpBlocked        Does    : deactivate this enemy - eventually count up enemy locked in a hole time
;                                   : enemy does not move anymore and is fixed in this positions
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpBlocked         .block                           ; 
                            lda LRZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            beq EnemyMoveUpBlockedX         ; check: in hole time up - yes
                            bmi EnemyMoveUpBlockedX         ; check: still carries gold - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; correct enemy in hole time to LRZ_EnemyHoleGoldTime_Shake_X ($07) again
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_EnemyHoleGoldTime       ; count up enemy locked in a hole time
                            
EnemyMoveUpBlockedX         jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpHandler        Does    : try to move enemy up
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpHandler         .block                           ; 
                            ldy LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cpy #LRZ_EnemyOnImgPosY_Mid + $01 ; test beyond center
                            bcs MoveUpPrepare               ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy can be moved up a row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check if already on top row
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq EnemyMoveUpBlocked          ; check: top row - yes: care for timer - disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row above enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; step one row up
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of enemy col on row above enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> path up blocked - move up impssible
; BrickHard  --> path up blocked - move up impssible
; BrickTrap  --> path up blocked - move up impssible
; BrickEnemy --> path up blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is anormal brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is a solid brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is a trap door - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickTrap       ; test trap door
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on row above enemy row is an enemy - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Enemy           ; test enemy
                            beq EnemyMoveUpBlocked          ; check: EQ - yes: blocked - care for timer
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile above enemy is suitable for a move up
; --------------------------------------------------------------------------------------------------------------------- ;
MoveUpPrepare               jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image position up a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_EnemyOnImgPosY          ; actual enemy pos on image up/down
                            bpl EnemyMoveUpPickGold         ; check: max up: no: eventually pick up gold - handle sprite images
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let the enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #LR_TileNum_Empty           ; get empty space substitution
                            
SetGameDataTile             sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new row number one row up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_EnemyRow                ; dec actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get data tile on enemy col of new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr LR_LodeRuState              ; set LR_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy tile in level game data
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyImageNum            lda #LR_TileNum_Enemy           ; get enemy
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image to max PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyOnImgPosY_Max     ; get max PosY
                            sta LRZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            bne EnemyMoveSpriteUpDo         ; always - handle enemy sprite images for move up or down
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveUpPickGold       Does    : eventually let the enemy pick up gold - enemy move up/down exit point
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveUpPickGold        .block                           ; 
                            jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveSpriteUpDo       Does    : handle enemy sprite images for move up or down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveSpriteUpDo        .block                           ; 
                            lda #LRZ_EnemySprtNum_Ladder_00 ; get sprite num min
                            ldx #LRZ_EnemySprtNum_Ladder_01 ; get sprite num max
                            jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDownHandler      Does    : try to move enemy down
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDownHandler       .block                           ; 
                            ldy LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cpy #LRZ_EnemyOnImgPosY_Mid     ; test beyond center
                            bcc MoveDownPrepare             ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy can be moved down a row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on bottom row - yes: disable him
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #LRZ_ScreenRow_Max          ; test bottom row
                            bcs EnemyMoveDownDisable        ; check: GE - yes: exit - disable hime
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to row below enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; step one row down
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on col directly below enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickHard  --> path down blocked - exit - move down impssible
; BrickEnemy --> path down blocked - exit - move down impssible
; BrickSoft  --> path down blocked - exit - move down impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a solid brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveDownDisable        ; check: EQ - yes: blocked - exit - disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is an enemy - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Enemy           ; test enemy
                            beq EnemyMoveDownDisable        ; check: EQ - yes: blocked - exit - disable him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of enemy col on row below enemy row is a normal brick - yes: blocked - move up impssible
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne MoveDownPrepare             ; check: EQ - no: not blocked - try to move down
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDownDisable        jmp EnemyMoveStatusSave         ; exit - save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile above enemy is suitable for a move down
; --------------------------------------------------------------------------------------------------------------------- ;
MoveDownPrepare             jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosX    ; step the enemy towards the center of the image horizontally
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos down a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_EnemyOnImgPosY          ; actual enemy pos on image up/down
                            
                            lda LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #LRZ_EnemyOnImgPosY_Max + $01 ; test max down
                            bcc GoEnemyMoveUpPickGold       ; check: LT - yes: eventualy pick up gold - handle sprite images
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let the enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #LR_TileNum_Empty           ; get brick substitution
                            
SetGameDataTile             sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new row number one row down
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_EnemyRow                ; inc actual enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game data row pointer to new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on col of new enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr LR_LodeRuState              ; set LR_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy tile in level game data
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyImageNum            lda #LR_TileNum_Enemy           ; get enemy
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on image to min PosY
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyOnImgPosY_Min     ; get min PosY
                            sta LRZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            jmp EnemyMoveSpriteUpDo         ; handle enemy sprite images for move up or down
; --------------------------------------------------------------------------------------------------------------------- ;
GoEnemyMoveUpPickGold       jmp EnemyMoveUpPickGold         ; eventually pick up gold - handle sprite images
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveLeftHandler      Does    : try to move enemy left
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveLeftHandler       .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy in center of the tile image
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cpx #LRZ_EnemyOnImgPosX_Mid + $01 ; test beyond center
                            bcs MoveLeftPrepare             ; check: GE - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on max col left - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            beq EnemyMoveLeftDisable        ; check: already max left - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set col pointer one col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of new col left of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Enemy      --> path left blocked - move left impssible
; BrickSoft  --> path left blocked - move left impssible
; BrickHard  --> path left blocked - move left impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is an enemy - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Enemy           ; test enemy
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col left of enemy col on enemy row is a solid brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col left of enemy col on enemy row is a normal brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveLeftDisable        ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of new col left of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Trap --> not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is a trap door - yes: not willing to move left - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickTrap       ; test trap door
                            bne MoveLeftPrepare             ; check: EQ - no: all free - try to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveLeftDisable        jmp EnemyMoveStatusSave         ; save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile left of enemy is suitable for a move left
; --------------------------------------------------------------------------------------------------------------------- ;
MoveLeftPrepare             jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosY    ; step the enemy towards the center of the image vertically
                            
                            lda #LRZ_EnemyViewDir_Le        ; get view dir left
                            sta LRZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos left a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_EnemyOnImgPosX          ; actual enemy pos on image left/right
                            bpl EnemyMoveLeftWithGold       ; check: max left: no
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let this enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #LR_TileNum_Empty           ; get empty space substitution
                            
SetGameDataTile             sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new col number one col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_EnemyCol                ; dec actual enemy col
                            dey                             ; dec row tile offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on new enemy col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy new col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr LR_LodeRuState              ; set LR_LodeRuState_Death
                            
SetEnemyImageNum            lda #LR_TileNum_Enemy           ; get enemy
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image max PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyOnImgPosX_Max     ; get 
                            sta LRZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            bne EnemyMoveLeftWithoutGold    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyMoveLeftWithGold       jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile on new enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveLeftWithoutGold    ldy LRZ_EnemyCol                ; get actual enemy col
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is pole - yes: get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq GetSpriteNumPole            ; check: EQ - yes
                            
                            lda #LRZ_EnemySprtNum_Run_Le_00 ; get run sprite num min
                            ldx #LRZ_EnemySprtNum_Run_Le_02 ; get run sprite num max
                            bne EnemyMoveSpriteLeft         ; always
                            
GetSpriteNumPole            lda #LRZ_EnemySprtNum_Pole_Le_00; get pole sprite num min
                            ldx #LRZ_EnemySprtNum_Pole_Le_02; get pole sprite num max
                            
EnemyMoveSpriteLeft         jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveRightHandler     Does    : try to move enemy right
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightHandler      .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy in center of the tile image
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cpx #LRZ_EnemyOnImgPosX_Mid     ; test beyond center
                            bcc MoveRightPrepare            ; check: LT - yes: bypass checks
; --------------------------------------------------------------------------------------------------------------------- ;
; check: already on max col right - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            cpy #LRZ_ScreenCol_Max          ; test max right
                            beq EnemyMoveRightDisable       ; check: already max right - yes: disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set col pointer one col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile of new col right of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Enemy      --> path right blocked - move right impssible
; BrickSoft  --> path right blocked - move right impssible
; BrickHard  --> path right blocked - move right impssible
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is an enemy - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Enemy           ; test enemy
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is a solid brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new col right of enemy col on enemy row is a normal brick - yes: blocked - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveRightDisable       ; check: EQ - yes: blocked - disable this enemy - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of new col right of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Trap --> not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of col left of enemy col on enemy row is a trap door - yes: not willing to move right - exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickTrap       ; test trap door
                            bne MoveRightPrepare            ; check: EQ - no: all free - try to move right
; --------------------------------------------------------------------------------------------------------------------- ;
; exit - disable this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightDisable       jmp EnemyMoveStatusSave         ; save enemy status to save area
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; tile right of enemy is suitable for a move right
; --------------------------------------------------------------------------------------------------------------------- ;
MoveRightPrepare            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            jsr EnemyMoveCenterImagePosY    ; step the enemy towards the center of the image vertically
                            
                            lda #LRZ_EnemyMoveDir_Le        ; get move dir left
                            sta LRZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
; --------------------------------------------------------------------------------------------------------------------- ;
; step the enemy on image pos right a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_EnemyOnImgPosX          ; actual enemy pos on image left/right
                            lda LRZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #LRZ_EnemyOnImgPosX_Max + $01 ; test max right
                            bcc EnemyMoveRightWithGold      ; check: LT - no
; --------------------------------------------------------------------------------------------------------------------- ;
; possibly let this enemy drop his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveDropGold           ; eventually let enemy drop his gold
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft  --> set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of enemy col on enemy row is normal brick - yes: set game data to empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne SetGameDataTile             ; check: EQ - no: bypass substitution
                            
                            lda #LR_TileNum_Empty           ; get brick substitution
                            
SetGameDataTile             sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; set new col number one col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_EnemyCol                ; inc actual enemy col
                            iny                             ; inc row tile offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get the data tile on new enemy col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; LodeRunner --> kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is loderuner - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_LodeRunner      ; test loderunner
                            bne SetEnemyImageNum            ; check: EQ - no: bypass death
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner caught - flag death
; --------------------------------------------------------------------------------------------------------------------- ;
                            lsr LR_LodeRuState              ; set LR_LodeRuState_Death
                            
SetEnemyImageNum            lda #LR_TileNum_Enemy           ; get enemy
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; init enemy on new image min PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyOnImgPosX_Min     ; get 
                            sta LRZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            beq EnemyMoveRightWithoutGold   ; always
                            
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyMoveRightWithGold      jsr EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile on new enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveRightWithoutGold   ldy LRZ_EnemyCol                ; get actual enemy col
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game ctrl tile of new enemy col on enemy row is pole - yes: get the appropriate sprite num
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq GetSpriteNumPole            ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; get run sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemySprtNum_Run_Ri_00 ; get run sprite num min
                            ldx #LRZ_EnemySprtNum_Run_Ri_02 ; get run sprite num max
                            bne EnemyMoveSpriteRight        ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; get hang sprite
; --------------------------------------------------------------------------------------------------------------------- ;
GetSpriteNumPole            lda #LRZ_EnemySprtNum_Pole_Ri_00; get pole sprite num min
                            ldx #LRZ_EnemySprtNum_Pole_Ri_02; get pole sprite num max
                            
EnemyMoveSpriteRight        jsr EnemyMoveSpriteNumRotate    ; rotate enemy sprite numbers between min and max values
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp EnemyMoveStatusSave         ; save enemy status to save area
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetDirProposal   Does    : return an enemy move direction for the move dispatcher
;                           Expects : .X=actual enemy col number (from LRZ_EnemyCol)
;                                   : .Y=actual enemy row number (from LRZ_EnemyRow)
;                           Returns : .A=enemy move direction
;                           Remark  : 1st - test if the enemy is locked up in a hole
;                                           --> Return move dir up
;                                   : 2nd - test if enemy/loderunner rows are same
;                                   :       test on which side of the loderunner this enemy is located
;                                   :       loop until scan col left/right EQ loderunner col
;                                   :         if loderunner col is reached    <-- return move dir left/right
;                                   :         if col is without a Ladder/Pole
;                                   :           check col on row below enemy row
;                                   :           if col is Empty/BrickTrap     <-- exit to enemy/loderunner rows differ
;                                   :             no move le/ri if an Empty/BrickTrap uncovered by a Ladder/Pole is in his way
;                                   : 3rd - enemy/loderunner rows differ
;                                   :       --> EnemyMoveGetMaxColLeRi - game data: col before BrickSoft/BrickSolid  OR   (cares for holes)
;                                                                        ctrl data: 1st col pair without top Ladder/Pole  AND  bottom BrickSoft/BrickSolid/Ladder  OR
;                                                                                   LR_ScreenCols_Min/LR_ScreenCols_Max
;                                   :       --> EnemyMoveScanGoal      - see if enemy can be moved down or right
;                                   :       --> EnemyMoveScanWingLeft  - scan left  side of enemy for a possible move left
;                                   :       --> EnemyMoveScanWingRight - scan right side of enemy for a possible move up
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetDirProposal    .block                           ; 
                            stx LRZ_EnemyMoveColStart       ; set fix actual enemy col - copied from LRZ_EnemyCol
                            sty LRZ_EnemyMoveRowStart       ; set fix actual enemy row - copied from LRZ_EnemyRow
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 1st: look if the enemy is locked up in a hole
;        game data tile under the enemy is empty
;        ctrl data tile under the enemy is normal brick - captured in a hole then
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveColStart       ; get fix actual enemy col - copied from LRZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile this enemy is directly on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile under the enemy is normal brick - captured in a hole then
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            bne ChkEnemyAndLodeRuRowSame    ; check: EQ - no: test if this enemy is on loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is locked up in a hole - check: enemy carries gold/locked in a hole timer is expired
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            beq ChkEnemyAndLodeRuRowSame    ; check: still in hole  - no : check if on loderunner row
                            bmi ChkEnemyAndLodeRuRowSame    ; check: still has gold - yes: check if on loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; positive: exit with move_up - get this enemy up out of the hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_EnemyMoveDir_Up         ; get move up - step enemy climb out of hole
                            rts                             ; 
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 2nd: look if loderunner and enemy are on the same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
ChkEnemyAndLodeRuRowSame    ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            cpy LRZ_LodeRuRow               ; test actual row loderunner
                            beq EnemyAndLodeRuRowSame       ; check: EQ - yes: both on same row
                            
                            jmp EnemyAndLodeRuRowDiffer     ; loderunner and enemy are not on the same row
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner and enemy are on the same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyAndLodeRuRowSame       ldy LRZ_EnemyMoveColStart       ; get fix actual enemy col - copied from LRZ_EnemyCol
                            sty LRZ_EnemyMoveLodeRuColGap   ; ini col gap between enemy and loderunner
                            
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; test on which side of the loderunner the enemy is located
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
                            cpy LRZ_LodeRuCol               ; test actual col loderunner
                            bcs ScanNextEnemyColLeft        ; check: loderunner left of enemy - no: right
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is on the left side of loderunner - check if it is possible to move him right
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl data tiles right from enemy col towards loderunner col for Ladder/Pole
;   an enemy does not move right if an Empty/BrickTrap is in his way which is not covered by a Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
ScanNextEnemyColRight       inc LRZ_EnemyMoveLodeRuColGap   ; decrease col gap between enemy and loderunner from right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile right on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col right - skip scan of row below actual row
; Pole   --> continue with next col right - skip scan of row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next ctrl tile right on enemy is a ladder - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile right of enemy is a pole - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row already - yes: skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            cpy #LRZ_ScreenRow_Max          ; test max row
                            beq ChkReachedLodeRuColRight    ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col of enemy row  AND  not on bottom row - scan next ctrl data tile right of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles right below enemy row from enemy col to loderunner col
;   an enemy does not move right if a hole/trap is in his way
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile right on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> exit to EnemyAndLodeRuRowDiffer
; Trap  --> exit to EnemyAndLodeRuRowDiffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right below enemy is Empty - yes: enemy is not willing to move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Empty           ; test empty space
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move right - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right below enemy is BrickTrap - yes: enemy is not willing to move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickTrap       ; test trap door
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move right - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan right has reached loderunner col - exit with enemy move_right
; --------------------------------------------------------------------------------------------------------------------- ;
ChkReachedLodeRuColRight    ldy LRZ_EnemyMoveLodeRuColGap   ; get right end of col gap between enemy and loderunner
                            cpy LRZ_LodeRuCol               ; test with actual col loderunner
                            bne ScanNextEnemyColRight       ; check: NE - yes: continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; scan right towards loderunner col finished - return move right
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_EnemyMoveDir_Ri         ; get enemy move_right
                            rts                             ; exit
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is on the right side of loderunner - check if it is possible to move him left
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles left from enemy col towards loderunner col for Ladder/Pole
;   an enemy is not willing to move left if an Empty/BrickTrap is in his way which is not covered by a Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
ScanNextEnemyColLeft        dec LRZ_EnemyMoveLodeRuColGap   ; decrease col gap between enemy and loderunner from left
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile left on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col left - skip scan of row below actual row
; Pole   --> continue with next col left - skip scan of row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile left of enemy is a ladder - skip scan below - check if loderunner column is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: skip scan below - check loderuner col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: next game ctrl tile left of enemy is a pole - skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: skip scan below - check loderuner col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row already - skip scan below - check if loderunner col is reached
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            cpy #LRZ_ScreenRow_Max          ; test max row
                            beq ChkReachedLodeRuColLeft     ; check: EQ - yes: bottom reached - move left is possible 
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col of enemy row  AND  not on bottom row - scan next ctrl data tile left of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; scan the ctrl tiles left below of enemy from enemy col to loderunner col
;   an enemy is not willing to move left if an Empty/BrickTrap is in his way
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> exit to EnemyAndLodeRuRowDiffer
; Trap  --> exit to EnemyAndLodeRuRowDiffer
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left below enemy is Empty - enemy is not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Empty           ; test empty space
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move left - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left below enemy is BrickTrap - enemy is not willing to move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickTrap       ; test trap door
                            beq EnemyAndLodeRuRowDiffer     ; check: EQ - yes: not willing to move left - exit scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan left has reached loderunner col - exit with enemy move_left
; --------------------------------------------------------------------------------------------------------------------- ;
ChkReachedLodeRuColLeft     ldy LRZ_EnemyMoveLodeRuColGap   ; get left end of col gap between enemy and loderunner
                            cpy LRZ_LodeRuCol               ; test with actual col loderunner
                            bne ScanNextEnemyColLeft        ; check: NE - yes: continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; scan left towards loderunner col finished - exit with enemy move_left
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_EnemyMoveDir_Le         ; get enemy move_left
                            rts                             ; exit
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 3rd: loderunner and enemy are not on same row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
EnemyAndLodeRuRowDiffer     lda #LRZ_EnemyMoveDir_Ini       ; get initial value
                            sta LRZ_EnemyMoveDir            ; ini actual enemy move direction
                            
                            lda #LRZ_EnemyMoveDistMin_Ini   ; get initial value - guarantees a successful 1st check
                            sta LRZ_EnemyMoveDistMin        ; ini enemy move target max distance
                            
                            ldx LRZ_EnemyMoveColStart       ; get fix actual enemy col - copied from LRZ_EnemyCol
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; Set      : LRZ_EnemyMoveMaxCol_Le = max col left  for 
;          : LRZ_EnemyMoveMaxCol_Ri = max col right for 
;          : 
; which is : col before blocking BrickSoft/BrickSolid  OR
;          : col pair without (top Ladder/Pole  AND  bottom BrickSoft/BrickSolid/Ladder)  OR
;          : min screen col/max screen col
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveGetMaxColLeRi      ; scan game/ctrl data for enemy max left/right move columns
; --------------------------------------------------------------------------------------------------------------------- ;
; for this enemy the playfield is now split into three parts
;   goal       - scan one enemy col position
;   left  wing - scan cols from enemy max col left  towards enemy col
;   right wing - scan cols from enemy max col right towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr EnemyMoveScanGoal           ; scan row/col pos of enemy for a possible move down or right
                            jsr EnemyMoveScanWingLeft       ; scan left  side  of enemy for a possible move left
                            jsr EnemyMoveScanWingRight      ; scan right side  of enemy for a possible move up
                            
                            lda LRZ_EnemyMoveDir            ; return the enemy move direction found
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingLeftX    Does    : exit point of EnemyMoveScanWingLeft
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingLeftX     .block                           ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingLeft     Does    : scan left side of enemy for a possible move left
;                           Expects : 
;                           Returns : 
;                           Remark  : loop until EnemyMoveMaxCol_Le EQ enemy col
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_left
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_left
;                                   : step EnemyMoveMaxCol_Le towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingLeft      .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; scan columns from max col left towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextScanColLeft          ldy LRZ_EnemyMoveMaxCol_Le      ; get actual enemy scan col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy col reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy LRZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from LRZ_EnemyCol
                            beq EnemyMoveScanWingLeftX      ; check: enemy col reached - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            cpy #LRZ_ScreenRow_Max          ; test bottom row
                            beq CheckOnRow_Top              ; check: EQ - yes: skip scan of row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveMaxCol_Le      ; get actual enemy scan col left
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip evaluation move left - continue with top row handling
; BrickHard --> skip evaluation move left - continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq CheckOnRow_Top              ; check: EQ - yes: skip move left evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a solid brick - yes: continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq CheckOnRow_Top              ; check: EQ - yes: skip move left evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx LRZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp LRZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckOnRow_Top              ; check: GE - yes: skip set move left
                            
                            sta LRZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_left for the new minimum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyMoveDir_Le        ; get move dir left
                            sta LRZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - advance col position left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CheckOnRow_Top              ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            beq AdvanceEnemyMaxCol_Le       ; check: top row - yes: step scan col to the right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile of scan col left on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move left - move enemy max col left towards actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col left on enemy row is a ladder - yes: evaluate a new move left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne AdvanceEnemyMaxCol_Le       ; check: EQ - no: skip move evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max top row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            ldx LRZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx LRZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp LRZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs AdvanceEnemyMaxCol_Le       ; check: GE - yes: advance col position from left towards enemy
                            
                            sta LRZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_left for the new min
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyMoveDir_Le        ; get move dir left
                            sta LRZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; step max col one position from left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMaxCol_Le       inc LRZ_EnemyMoveMaxCol_Le      ; step scan col to the next column right
                            
                            jmp GetNextScanColLeft          ; continue scan from max col left to actual enemy col
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingRightX   Does    : exit point of EnemyMoveScanWingRight
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingRightX    .block                           ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanWingRight    Does    : scan right side of enemy for a possible move up
;                           Expects : 
;                           Returns : 
;                           Remark  : loop until EnemyMoveMaxCol_Ri EQ enemy col
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_up
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_up
;                                   : step EnemyMoveMaxCol_Ri towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanWingRight     .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; scan columns from max col right towards enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextScanColRight         ldy LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy col reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy LRZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from LRZ_EnemyCol
                            beq EnemyMoveScanWingRightX     ; check: enemy col reached - yes: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            cpy #LRZ_ScreenRow_Max          ; test max row
                            beq CheckOnRow_Top              ; check: EQ - yes: bottom reached - check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip evaluation move up - continue with top row handling
; BrickHard --> skip evaluation move up - continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq CheckOnRow_Top              ; check: EQ - yes: check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of actual scan col on row below enemy row is a solid brick - yes: continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq CheckOnRow_Top              ; check: EQ - yes: check if on top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp LRZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckOnRow_Top              ; check: GE - yes: check if on top row
                            
                            sta LRZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_up for the new maximum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyMoveDir_Up        ; get move dir up
                            sta LRZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - advance col position left towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CheckOnRow_Top              ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            beq AdvanceEnemyMaxCol_Ri       ; check: max up reached - yes: reduce scan col to next pos right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; get next ctrl data tile of scan col right on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move up - move enemy max col left towards actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col right on enemy row is a ladder - yes: evaluate a new move up
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne AdvanceEnemyMaxCol_Ri       ; check: EQ - no: reduce scan col to next pos right
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max top row of the actual scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            ldx LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if this scan col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp LRZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs AdvanceEnemyMaxCol_Ri       ; check: GE - yes: reduce scan col to next pos right
                            
                            sta LRZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_up for the new min
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyMoveDir_Up        ; get move dir up
                            sta LRZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; step max col one position from right towards enemy
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMaxCol_Ri       dec LRZ_EnemyMoveMaxCol_Ri      ; dec enemy possible max col right
                            jmp GetNextScanColRight         ; continue scan right
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveScanGoal         Does    : scan enemy col position on enemy row for a possible move down or right
;                           Expects : 
;                           Returns : 
;                           Remark  : scan tile of enemy col on enemy row
;                                   :   skip BOTTOM row evaluation
;                                   :   skip TOP    row evaluation
;                                   :   tile of row below enemy row is NOT BrickSoft/BrickHard --> evaluate a move_down
;                                   :   tile of           enemy row is a   Ladder              --> evaluate a move_right
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanGoal          .block                           ; 
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on bottom row - yes: completely skip row evaluation for a new move - continue with top row evaluation
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #LRZ_ScreenRow_Max          ; test bottom row
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: further down impossible - check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveColStart       ; test with fix actual enemy col - copied from LRZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> skip scan down - continue with scan up
; BrickHard --> skip scan down - continue with scan up
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on row below enemy row is a normal brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on row below enemy row is a solid brick - yes: continue with top row handling
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq CheckEnemyOnRow_Top         ; check: EQ - yes: check top row
; --------------------------------------------------------------------------------------------------------------------- ;
; scan for max bottom row of enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_EnemyMoveColStart       ; get fix actual enemy col - copied from LRZ_EnemyCol
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            jsr EnemyMoveGetMaxRowBot       ; set .A to the max bottom row for this col
                            
                            ldx LRZ_EnemyMoveColStart       ; get fix actual enemy col - copied from LRZ_EnemyCol
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if enemy col has a new min distance from actual scan col  OR  from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp LRZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs CheckEnemyOnRow_Top         ; check: GE - yes: check if on top row
                            
                            sta LRZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_down for the new minimum
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyMoveDir_Do        ; get enemy move down
                            sta LRZ_EnemyMoveDir            ; set actual enemy move direction
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; check: enemy on top row - yes: completely skip row evaluation for a new move - exit routine
; --------------------------------------------------------------------------------------------------------------------- ;
CheckEnemyOnRow_Top         ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            beq EnemyMoveScanGoalX          ; check: top row - yes: skip row test - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveColStart       ; get fix actual enemy col - copied from LRZ_EnemyCol
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of enemy col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> evaluate new move right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of enemy col on enemy row is a ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne EnemyMoveScanGoalX          ; check: EQ - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get max top row for enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_EnemyMoveColStart       ; get fix actual enemy col - copied from LRZ_EnemyCol
                            ldy LRZ_EnemyMoveRowStart       ; get fix actual enemy row - copied from LRZ_EnemyRow
                            jsr EnemyMoveGetMaxRowTop       ; get the top scan row in .A
                            
                            ldx LRZ_EnemyMoveColStart       ; get fix actual enemy col - copied from LRZ_EnemyCol
                            jsr EnemyMoveGetDistance        ; get enemy shortest distance of free path to loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; see if enemy col has a new min distance from target col or from loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp LRZ_EnemyMoveDistMin        ; test with old enemy move target min distance
                            bcs EnemyMoveScanGoalX          ; check: GE - yes: skip set new move dir
                            
                            sta LRZ_EnemyMoveDistMin        ; set new enemy move target min distance
; --------------------------------------------------------------------------------------------------------------------- ;
; set move dir_right for the new min distance
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyMoveDir_Ri        ; get move dir right
                            sta LRZ_EnemyMoveDir            ; set actual enemy move direction
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveScanGoalX          rts                             ; 
                            
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetDistance      Does    : get enemy distance from target col or loderunner row
;                           Expects : .A=enemy target row - max is the actual loderunner row
;                                   : .X=enemy target col
;                           Returns : enemy target row and loderunner row same  : .A=distance enemy col from enemy max col le/ri
;                                   : enemy target row and loderunner row differ: .A=distance enemy row from loderunner row with up/do marker added
;                           Remark  : called from EnemyMoveScanGoal      with .A=EnemyMoveGetMaxRowBot .X=LRZ_EnemyMoveColStart
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=LRZ_EnemyMoveColStart
;                                   : called from EnemyMoveScanWingLeft  with .A=EnemyMoveGetMaxRowBot .X=LRZ_EnemyMoveMaxCol_Le
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=LRZ_EnemyMoveMaxCol_Le
;                                   : called from EnemyMoveScanWingRight with .A=EnemyMoveGetMaxRowBot .X=LRZ_EnemyMoveMaxCol_Ri
;                                   :                                    with .A=EnemyMoveGetMaxRowTop .X=LRZ_EnemyMoveMaxCol_Ri
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetDistance       .block                           ; 
                            sta LRZ_WorkEnemyParmSave       ; save a possible row subtraction value
                            
                            cmp LRZ_LodeRuRow               ; test enemy target row with actual loderunner row
                            bne ChkTargRowBelowLodeRuRow    ; check: EQ - no: check if higher/lower loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy max target row is same as loderunner row - choose direction le/ri
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpx LRZ_EnemyCol                ; test enemy target col with actual enemy col
                            bcc EnemyIsRightOfTargetCol     ; check: taget col LT - yes: 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is left of target col - subtract actual enemy col from target col - gives distance from target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; get enemy target col
                            sec                             ; 
                            sbc LRZ_EnemyCol                ; sub actual enemy col
; --------------------------------------------------------------------------------------------------------------------- ;
; return enemy distance from enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy is right of target col - subtract target col from actual enemy col - gives distance from target col
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyIsRightOfTargetCol     stx LRZ_WorkEnemyParmSave       ; save enemy target col for subtraction
                            
                            lda LRZ_EnemyCol                ; get actual enemy col
                            sec                             ; 
                            sbc LRZ_WorkEnemyParmSave       ; sub enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
; return enemy distance from enemy target col
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy max row and actual loderunner row differ - choose direction up/do
; --------------------------------------------------------------------------------------------------------------------- ;
ChkTargRowBelowLodeRuRow    bcc EnemyTargRowAboveLodeRuRow  ; check: enemy target row LT actual loderunner row - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy target row is below actual loderunner row - subtract loderunner row from target row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            sec                             ; 
                            sbc LRZ_LodeRuRow               ; sub actual row loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
; mark enemy target row is below actual loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$64 * $02                  ; add move up marker
; --------------------------------------------------------------------------------------------------------------------- ;
; return distance enemy row from loderunner row with up value
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy target row is above actual loderunner row - subtract target row from loderunner row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyTargRowAboveLodeRuRow  lda LRZ_LodeRuRow               ; get actual row loderunner
                            sec                             ; 
                            sbc LRZ_WorkEnemyParmSave       ; sub enemy target row - gives distance to loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
; mark enemy target row is above actual loderunner row
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; 
                            adc #$64 * $01                  ; add move down marker
; --------------------------------------------------------------------------------------------------------------------- ;
; return distance enemy row from loderunner row with down value
; --------------------------------------------------------------------------------------------------------------------- ;
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowTopX    Does    : exit point - return enemy row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowTopX     .block                           ; 
                            lda LRZ_EnemyMoveScanRow        ; get actual scan row
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowTop     Does    : return the maximum top row for a given column
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : .A=enemy max possible row up
;                           Remark  : entered if this enemy has reached a ladder on his way up
;                                   : --------------------------------------------------------------------------------- ;
;                                   : called from EnemyMoveScanGoal      with .X=LRZ_EnemyMoveColStart  .Y=LRZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingLeft  with .X=LRZ_EnemyMoveMaxCol_Le .Y=LRZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingRight with .X=LRZ_EnemyMoveMaxCol_Ri .Y=LRZ_EnemyMoveRowStart
;                                   : --------------------------------------------------------------------------------- ;
;                                   : scan row up at the given enemy col
;                                   :   loop until scan row LT top row
;                                   :     tile of scan row is NOT a Ladder                    --> exit with actual scan row
;                                   :     tile of scan row is     a Ladder
;                                   :       step scan row one up
;                                   : 
;                                   :     tile left of scan col on scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   :     tile left of scan col on decreased scan row is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   : 
;                                   :     tile right of scan col on row below decreased scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
;                                   :     tile right of decreased scan row is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if actual scan row LE loderunner row             --> exit with max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowTop      .block                           ; 
                            sty LRZ_EnemyMoveScanRow        ; ini scan row to enemy row
                            stx LRZ_EnemyMoveScanCol        ; ini scan col from enemy col or max col left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to actual row
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextCtrlDataPtr          lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> step actual scan row up
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col on actual row is Ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne EnemyMoveGetMaxRowTopX      ; check: EQ - no: exit with actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; step scan row one row up
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_EnemyMoveScanRow        ; step actual scan row up
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile left of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max left - yes: skip check left - continue with check right
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
                            beq ScanTargetCol_Ri            ; check: already max left - yes: start check right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForTop_Le     ; check: EQ - yes: set scan row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to decreased scan row - row above actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveScanRow        ; get new actual scan row
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on decreased row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col left on decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check: LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left of scan col on decreased row is Pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            bne ScanTargetCol_Ri            ; check: EQ - no: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForTop_Le     ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            sty LRZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is LE loderunner row - yes: exit with .A=LRZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy LRZ_LodeRuRow               ; test actual row loderunner
                            bcc ReturnMoveTargetRowMax      ; check: loderunner row LT max row - yes: exit with max row
                            beq ReturnMoveTargetRowMax      ; check: loderunner row EQ max row - yes: exit with max row
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; actual scan row is GT enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max right - yes: check bottom row - return max row then
; --------------------------------------------------------------------------------------------------------------------- ;
ScanTargetCol_Ri            ldy LRZ_EnemyMoveScanCol        ; get scan col
                            cpy #LRZ_ScreenCol_Max          ; test already max right
                            beq ChkEndOfScanTop             ; check: EQ - yes: end of scan right - check top row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveScanRow        ; get decreased scan row
                            
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right on row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right on row below decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: max scan row LE loderunner row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on row below decreased scan row is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForTop_Ri     ; check: EQ - yes: set targ row max - check LR row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to decreased scan row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right of actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check: max scan row LE LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            bne ChkEndOfScanTop             ; check: EQ - no: skip LR exit check - check top row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForTop_Ri     ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            sty LRZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is LE loderunner row - yes: exit with .A=LRZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy LRZ_LodeRuRow               ; test actual row loderunner
                            bcc ReturnMoveTargetRowMax      ; check: loderunner row LT max row - yes: exit with max row
                            beq ReturnMoveTargetRowMax      ; check: loderunner row EQ max row - yes: exit with max row
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner row is below enemy row right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: top row reached - end of scan - exit with .A=LRZ_EnemyMoveScanRow
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEndOfScanTop             ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            cpy #LRZ_ScreenRow_Min + $01    ; test top row
                            bcc ReturnMoveTargetRowTop      ; check: LT - yes: exit
                            
                            jmp SetNextCtrlDataPtr          ; continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowTop      tya                             ; return top row
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowMax      lda LRZ_EnemyMoveScanRowMax     ; get max scan row found
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; return point for EnemyMoveGetMaxRowBot if scan below reveals a BrickSoft/BrickHard
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveScanRow           lda LRZ_EnemyMoveScanRow        ; get actual scan row
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxRowBot     Does    : return the maximum bottom row for a given column
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : .A=enemy max possible row down
;                           Remark  : entered if this enemy has reached a pole or a ladder on his way down
;                                   : --------------------------------------------------------------------------------- ;
;                                   : called from EnemyMoveScanGoal      with .X=LRZ_EnemyMoveColStart  .Y=LRZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingLeft  with .X=LRZ_EnemyMoveMaxCol_Le .Y=LRZ_EnemyMoveRowStart
;                                   : called from EnemyMoveScanWingRight with .X=LRZ_EnemyMoveMaxCol_Ri .Y=LRZ_EnemyMoveRowStart
;                                   : --------------------------------------------------------------------------------- ;
;                                   : scan row down at the given enemy col
;                                   :   loop until scan row GT bottom row
;                                   :     tile of row below scan row is a BrickSoft/BrickHard --> exit with scan row  
;                                   :     tile of scan row is Empty
;                                   :       step scan row one down -       if max row reached --> exit with bottom row
;                                   : 
;                                   :     tile left of scan row col is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   :     tile left of row below scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   : 
;                                   :     tile right of scan row col is a Pole
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
;                                   :     tile right of row below scan row is a BrickSoft/BrickHard/Ladder
;                                   :        set max scan row to actual scan row
;                                   :        if  max scan row GE loderuner row                --> exit with max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxRowBot      .block                           ; 
                            sty LRZ_EnemyMoveScanRow        ; ini scan row from enemy row
                            stx LRZ_EnemyMoveScanCol        ; ini scan col from enemy col or max col left/right
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
ChkNextTargetCtrlDataRowPos lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> exit with actual scan row
; BrickHard --> exit with actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col below actual is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveGetMaxRowTop.ReturnMoveScanRow ; check: EQ - yes: return actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col below actual is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveGetMaxRowTop.ReturnMoveScanRow ; check: EQ - yes: return actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3Q
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Empty --> advance actual scan row - check: bottom row reached - yes: exit with ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile of scan col on actual row is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Empty           ; test empty space
                            beq AdvanceEnemyMoveTargetRow   ; check: EQ - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile left of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max left - yes: skip check left - continue with check right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy #LRZ_ScreenCol_Min          ; test max col left
                            beq ScanTargetCol_Ri            ; check: EQ - yes: check scan col max right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check if LR row is reached - return max scan row then
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of scan col on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col left on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq SetEnemyRowMaxForBot_Le     ; check: EQ - yes: set scan row max - check if LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile left below scan col enemy is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne ScanTargetCol_Ri            ; check: EQ - no: start scan col right of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForBot_Le     ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            sty LRZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is GE loderunner row - yes: exit with .A=LRZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy LRZ_LodeRuRow               ; test actual row loderunner
                            bcs ReturnMoveTargetRowMax      ; check: GE loderunner row - yes: return .A=LRZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; pole check right done with TabCtrlLevelDataRow_Hi and TabCtrlLevelDataRow_Hi + $01
; --------------------------------------------------------------------------------------------------------------------- ;
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; scan ctrl data tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; check: scan col is max right - yes: advance scan row - check bottom row - return max row then
; --------------------------------------------------------------------------------------------------------------------- ;
ScanTargetCol_Ri            ldy LRZ_EnemyMoveScanCol        ; get scan col
                            cpy #LRZ_ScreenCol_Max          ; test max right
                            bcs AdvanceEnemyMoveTargetRow   ; check: GE - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to next tile right of scan col
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc enemy move scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile right of scan col on actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; Pole --> set max scan row to actual scan row - check if LR row is reached - return max scan row then
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of scan col on actual row is pole
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveScanCol        ; get scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; inc enemy move scan col
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile of col right on row below actual row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; Ladder    --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; BrickHard --> set max scan row to actual scan row - check: on LR row - yes: return max scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is normal brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is ladder
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq SetEnemyRowMaxForBot_Ri     ; check: EQ - yes: set targ row max - check LR row reached
; --------------------------------------------------------------------------------------------------------------------- ;
; check: tile right below scan col enemy is solid brick
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            bne AdvanceEnemyMoveTargetRow   ; check: NE - yes: step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; set max scan row to actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
SetEnemyRowMaxForBot_Ri     ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            sty LRZ_EnemyMoveScanRowMax     ; set max scan row found from actual scan row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: actual scan row is GE loderunner row - yes: exit with .A=LRZ_EnemyMoveScanRowMax
; --------------------------------------------------------------------------------------------------------------------- ;
                            cpy LRZ_LodeRuRow               ; test actual row loderunner
                            bcs ReturnMoveTargetRowMax      ; check: GE loderunner row - yes: return .A=LRZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
; actual scan row is LT loderunner row - step scan row further down
; --------------------------------------------------------------------------------------------------------------------- ;
AdvanceEnemyMoveTargetRow   inc LRZ_EnemyMoveScanRow        ; step scan row down - check max
; --------------------------------------------------------------------------------------------------------------------- ;
; check: bottom row reached - end of scan - exit with .A=LRZ_ScreenRow_Max
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveScanRow        ; get actual scan row
                            cpy #LRZ_ScreenRow_Max + $01    ; test max row passed
                            bcs ReturnMoveTargetRowBottom   ; check: GE - yes: get max row and exit
                            
                            jmp ChkNextTargetCtrlDataRowPos ; continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowBottom   lda #LRZ_ScreenRow_Max          ; get bottom scan row
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ReturnMoveTargetRowMax      lda LRZ_EnemyMoveScanRowMax     ; get max scan row found
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetMaxColLeRi    Does    : scan game/ctrl data of enemy col on enemy row for the max left/right move col
;                                   : 
;                                   ;   scan game data: return col before BrickSoft/BrickSolid  OR   (game data cares for holes)
;                                   ;   scan ctrl data: return 1st col pair without top Ladder/Pole  AND  without bottom BrickSoft/BrickSolid/Ladder
;                                   ;   none of these : return LR_ScreenCols_Min/LR_ScreenCols_Max
;                           Expects : .X=enemy col
;                                   : .Y=enemy row
;                           Returns : LRZ_EnemyMoveMaxCol_Le = max col left
;                                   : LRZ_EnemyMoveMaxCol_Ri = max col right
;                           Remark  : loop until scan col EQ max col left
;                                   :   if game data BrickSoft/BrickHard              <-- stop scan - start scan right
;                                   :   if game data NOT Ladder/Pole                  <--             scan row below actual row
;                                   :     if ctrl data NOT BrickSoft/BrickHard/Ladder <-- stop scan - start scan right
;                                   :   dec LRZ_EnemyMoveMaxCol_Le
;                                   : 
;                                   : loop until scan col EQ max col right
;                                   :   if game data BrickSoft/BrickHard              <-- stop scan - exit routine
;                                   :   if game data NOT Ladder/Pole                  <--             scan row below actual row
;                                   :     if ctrl data NOT BrickSoft/BrickHard/Ladder <-- stop scan - exit routine
;                                   :   inc LRZ_EnemyMoveMaxCol_Ri
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetMaxColLeRi     .block                           ; 
                            stx LRZ_EnemyMoveMaxCol_Le      ; ini enemy max col left  to actual col of this enemy
                            stx LRZ_EnemyMoveMaxCol_Ri      ; ini enemy max col right to actual col of this enemy
                            sty LRZ_EnemyMoveMaxRow         ; ini enemy max row       to actual row of this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; start column scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: max col left reached - yes: exit scan left - start looking for max col right
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyScanColLeft     lda LRZ_EnemyMoveMaxCol_Le      ; get actual scan max col left
                            beq GetNextEnemyScanColRight    ; check: max screen col left reached - yes: start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; set game data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveMaxRow         ; get actual enemy max row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy LRZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; set col to next position left of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile left of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> stop scan left - start scan right
; BrickHard --> stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col left of actual scan col on enemy row is a normal brick - yes: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq GetNextEnemyScanColRight    ; check: EQ - yes: blocked - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col left of actual scan col on enemy row is a solid brick - yes: stop scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq GetNextEnemyScanColRight    ; check: EQ - yes: blocked - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft/BrickHard blocker not found on col left of actual scan col on enemy row - scan for Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col left - skip scan row below enemy row
; Pole   --> continue with next col left - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col left of actual scan col on enemy row is a ladder - continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col left of actual scan col on enemy row is a pole - continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row - yes: continue with next col left - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveMaxRow         ; get actual enemy max row
                            cpy #LRZ_ScreenRow_Max          ; test max row
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: skip scan below - continue scan left
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col postion  AND  not on bottom row - scan ctrl data tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveMaxCol_Le      ; get actual enemy possible col left
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col left of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            dey                             ; set col to tile one left below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile left of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; BrickHard --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; Ladder    --> check max col left - no: continue with next col left - yes: finalize scan left - start scan right
; All other --> finalize scan left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a normal brick - yes: continue with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a solid brick - yes: continue with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq SetNextEnemyMaxCol_Le       ; check: EQ - yes: continue scan with next col left
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile left of actual scan col on row below enemy row is a ladder - yes: continue with next col left - else: exit scan left
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne EndScanMaxCol_Le            ; check: EQ - no: done - adapt scan left max - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; step to next col position left - check: max left reached - no: continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyMaxCol_Le       dec LRZ_EnemyMoveMaxCol_Le      ; step actual enemy max col to the left
                            bpl GetNextEnemyScanColLeft     ; always - never gets negative
; --------------------------------------------------------------------------------------------------------------------- ;
; end of scan left - set final column left - start scan right
; --------------------------------------------------------------------------------------------------------------------- ;
EndScanMaxCol_Le            dec LRZ_EnemyMoveMaxCol_Le      ; set final possible enemy max col left
                            
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; start column scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: max col right reached - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyScanColRight    lda LRZ_EnemyMoveMaxCol_Ri      ; get actual scan max col right
                            cmp #LRZ_ScreenCol_Max          ; test max screen col right reached
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; set game data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveMaxRow         ; get actual enemy max row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            ldy LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; set col to next position right of enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile right of actual scan col on enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> stop scan right - exit scan routine
; BrickHard --> stop scan right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col right of actual scan col on enemy row is a normal brick - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: blocked - stop col scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data of col right of actual scan col on enemy row is a solid brick - yes: exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq EnemyMoveGetMaxColLeRiX     ; check: EQ - yes: blocked - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft/BrickHard blocker not found on col right of actual scan col on enemy row - scan for Ladder/Pole
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder --> continue with next col right - skip scan row below enemy row
; Pole   --> continue with next col right - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col right of actual scan col on enemy row is a ladder - continue scan with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: game data tile of col right of actual scan col on enemy row is a pole - continue scan with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Pole            ; test pole
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; check: on bottom row - yes: continue with next col right - skip scan row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyMoveMaxRow         ; get actual enemy max row
                            cpy #LRZ_ScreenRow_Max          ; test max row
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: skip scan below - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
; Ladder/Pole not found on this col postion  AND  not on bottom row - scan ctrl data tile on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; set ctrl data pointer to row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo + $01,y  ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi + $01,y ; get expanded level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            ldy LRZ_EnemyMoveMaxCol_Ri      ; get actual enemy possible col right
; --------------------------------------------------------------------------------------------------------------------- ;
; set pointer to col right of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            iny                             ; set col to tile one right below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
; get ctrl data tile right of actual scan col on row below enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; BrickSoft --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; BrickHard --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; Ladder    --> check max col RIGHT - no: continue with next col right - yes: finalize scan right - exit scan routine
; Other     --> finalize scan right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a normal brick - yes: continue with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickSoft       ; test normal brick
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: normal - continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a solid brick - yes: continue with next col right
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_BrickHard       ; test solid brick
                            beq SetNextEnemyMaxCol_Ri       ; check: EQ - yes: solid - continue scan
; --------------------------------------------------------------------------------------------------------------------- ;
; check: ctrl data tile right of actual scan col on row below enemy row is a ladder - yes: continue with next col right - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Ladder          ; test ladder
                            bne EndScanMaxCol_Ri            ; check: EQ - no: mark scan right max - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
; set next col position right - continue scan right
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyMaxCol_Ri       inc LRZ_EnemyMoveMaxCol_Ri      ; inc actual enemy max col right
                            bpl GetNextEnemyScanColRight    ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; end of scan right - set final col right - exit scan routine
; --------------------------------------------------------------------------------------------------------------------- ;
EndScanMaxCol_Ri            inc LRZ_EnemyMoveMaxCol_Ri      ; actual enemy possible col right
                            
EnemyMoveGetMaxColLeRiX     rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveGetScrnGfxPosXY  Does    : get the enemy image gfx screen position
;                           Expects : 
;                           Returns : .A=enemy image number
;                                   : .X=enemy image gfx screen horizontal offset
;                                   : .Y=enemy image gfx screen vertical offset
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveGetScrnGfxPosXY   .block                           ; 
                            ldx LRZ_EnemyCol                ; get actual enemy col
                            ldy LRZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            jsr ScreenAddGfxOnImagePosX     ; add horizontal gfx screen image offset
                            
                            stx LRZ_WorkImgOffsetPosX       ; save horizontal offset
                            
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            ldx LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            jsr ScreenAddGfxOnImagePosY     ; add vertical gfx screen image offset
                            
                            ldx LRZ_EnemySprtNum            ; get actual enemy sprite number
                            lda TabNumSpriteEnemy,x         ; get image number
                            ldx LRZ_WorkImgOffsetPosX       ; restore horizontal offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMovePickUpGold       Does    : eventually let enemy pick up gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovePickUpGold        .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy is centered completely
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #LRZ_EnemyOnImgPosX_Mid     ; test centered already
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: exit
                            
                            lda LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #LRZ_EnemyOnImgPosY_Mid     ; test  centered already
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get the ctrl data tile directly under this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if tile under enemy is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Gold            ; test gold
                            bne EnemyMovePickUpGoldX        ; check: EQ - no: level tile is not gold
; --------------------------------------------------------------------------------------------------------------------- ;
; check enemy has gold timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_EnemyHoleGoldTime       ; get enemy has gold time - counted up to $00
                            bmi EnemyMovePickUpGoldX        ; check: already carries gold - yes: do not pick up another
; --------------------------------------------------------------------------------------------------------------------- ;
; let this enemy get a piece of gold
; --------------------------------------------------------------------------------------------------------------------- ;
; randomly init enemy carries gold timer with last rebirth column value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_EnemyHoleGoldTime_Ini  ; ini enemy has gold time - preset to -1
                            sec                             ; 
                            sbc LR_EnemyBirthCol            ; sub enemy rebirth column - make it even more negative
                            sta LRZ_EnemyHoleGoldTime       ; set enemy has gold time - counted up to $00
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold in level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Empty           ; get clear gold
                            sta (LRZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear gold on hires screen and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            sty LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx LRZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #LR_TileNum_Gold            ; get gold
                            jmp ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMovePickUpGoldX        rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveDropGold         Does    : eventually let enemy drop his gold
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveDropGold          .block                           ; 
                            lda LRZ_EnemyHoleGoldTime       ; get enemy carries gold time - counted up to $00
                            bpl EnemyMoveDropGoldX          ; check: carries gold - no: already dropped or none
                            
                            inc LRZ_EnemyHoleGoldTime       ; inc enemy carries gold time - counted up to $00
                            bne EnemyMoveDropGoldX          ; check: hold gold time up - no: exit
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy has grown tired of carrying around his gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyRow                ; get actual enemy row
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data pointer to enemy row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; drop the gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_EnemyCol                ; get actual enemy col
                            sty LRZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if designated place is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
                            cmp #LR_TileNum_Empty           ; test empty space
                            bne RestoreEnemyHasGoldTime     ; check: EQ - no: drop impossible - restore timer and exit
; --------------------------------------------------------------------------------------------------------------------- ;
; store gold in level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Gold            ; get gold
                            sta (LRZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; store gold on hires screen and exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx LRZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
; --------------------------------------------------------------------------------------------------------------------- ;
; display dropped gold                            
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Gold            ; get tile number gold
                            jmp ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; revert previous inc of enemy carries gold timer - is only discounted if the gold is droppable
; --------------------------------------------------------------------------------------------------------------------- ;
RestoreEnemyHasGoldTime     dec LRZ_EnemyHoleGoldTime       ; restore enemy has gold time - counted up to $00
                            
EnemyMoveDropGoldX          rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveSpriteNumRotate  Does    : rotate enemy sprite numbers between minimum and maximum values
;                           Expects : .A=test sprite range number min
;                                   : .X=test sprite range number max
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveSpriteNumRotate   .block                           ; 
                            inc LRZ_EnemySprtNum            ; inc enemy sprite number to next phase
                            
                            cmp LRZ_EnemySprtNum            ; test actual enemy sprite number min
                            bcc ChkSpriteNumberMax          ; check: LT - yes: out of min range
                            
SetSpriteNumber             sta LRZ_EnemySprtNum            ; set min enemy sprite number
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChkSpriteNumberMax          cpx LRZ_EnemySprtNum            ; test actual enemy sprite number max
                            bcc SetSpriteNumber             ; check: LT - yes
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveCenterImagePosX  Does    : eventually step the enemy towards the center of the image horizontally
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosX   .block                           ; 
                            lda LRZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            cmp #LRZ_EnemyOnImgPosX_Mid     ; test center
                            bcc StepEnemyRight              ; check: LT - yes: step right to center
                            beq EnemyMoveCenterImagePosXX   ; check: EQ - yes: exit
                            
                            dec LRZ_EnemyOnImgPosX          ; enemy is right of center - step him left
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
StepEnemyRight              inc LRZ_EnemyOnImgPosX          ; enemy is left of center - step him right
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosXX   rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveCenterImagePosY  Does    : eventually step the enemy towards the center of the image vertically
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosY   .block                           ; 
                            lda LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            cmp #LRZ_EnemyOnImgPosY_Mid     ; test center
                            bcc StepEnemyDown               ; check: LT - yes: step down to center
                            beq EnemyMoveCenterImagePosYX   ; check: EQ - yes: exit
                            
                            dec LRZ_EnemyOnImgPosY          ; enemy is below the center - step him up
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
StepEnemyDown               inc LRZ_EnemyOnImgPosY          ; enemy is above the center - step him down
                            jmp EnemyMovePickUpGold         ; eventually let enemy pick up gold
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveCenterImagePosYX   rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveStatusSave       Does    : save enemy status to save area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveStatusSave        .block
                            ldx LR_EnemyToMoveNum           ; get active enemy number
                            
                            lda LRZ_EnemyCol                ; get actual enemy col
                            sta LR_SA_EnemyCol,x            ; save actual enemy col
                            
                            lda LRZ_EnemyRow                ; get actual enemy row
                            sta LR_SA_EnemyRow,x            ; save actual enemy row
                            
                            lda LRZ_EnemyOnImgPosX          ; get actual enemy pos on image left/right
                            sta LR_SA_EnemyPosOnImgPosX,x   ; save enemy pos on image left/right tab
                            
                            lda LRZ_EnemyOnImgPosY          ; get actual enemy pos on image up/down
                            sta LR_SA_EnemyPosOnImgPosY,x   ; save enemy pos on image up/down tab
                            
                            lda LRZ_EnemyHoleGoldTime       ; get enemy either has gold or locked in a hole time
                            sta LR_SA_EnemyHoleGoldTime,x   ; save enemy either has gold or locked in a hole time
                            
                            lda LRZ_EnemyViewDir            ; get actual enemy view dir right/left  $ff=left  $01=right
                            sta LR_SA_EnemyViewDir,x        ; save enemy move dir 
                            
                            lda LRZ_EnemySprtNum            ; get actual enemy sprite number
                            sta LR_SA_EnemySprtNum,x        ; save actual enemy sprite number
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyMoveStatusRestore    Does    : restore enemy status from save area
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyMoveStatusRestore     .block                           ; 
                            ldx LR_EnemyToMoveNum           ; get activation enemy number
                            
                            lda LR_SA_EnemyCol,x            ; get enemy save area column
                            sta LRZ_EnemyCol                ; set actual enemy col
                            
                            lda LR_SA_EnemyRow,x            ; get saved adr row enemy
                            sta LRZ_EnemyRow                ; set actual enemy row
                            
                            lda LR_SA_EnemyPosOnImgPosX,x   ; get saved  pos on image left/right tab
                            sta LRZ_EnemyOnImgPosX          ; set actual enemy pos on image left/right
                            
                            lda LR_SA_EnemyPosOnImgPosY,x   ; get saved  pos on image up/down tab
                            sta LRZ_EnemyOnImgPosY          ; set actual enemy pos on image up/down
                            
                            lda LR_SA_EnemySprtNum,x        ; get saved  enemy sprite number
                            sta LRZ_EnemySprtNum            ; set actual enemy sprite number
                            
                            lda LR_SA_EnemyViewDir,x        ; get saved enemy move dir
                            sta LRZ_EnemyViewDir            ; set actual enemy view dir right/left  $ff=left  $01=right
                            
                            lda LR_SA_EnemyHoleGoldTime,x   ; get enemy either has gold or locked in a hole time
                            sta LRZ_EnemyHoleGoldTime       ; set enemy either has gold or locked in a hole time
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameCloseHoles            Does    : close open holes and eventually kill a trapped loderunner/enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHoles             .block                           ; 
                            jsr EnemyRebirth                ; step an enemy back to life
; --------------------------------------------------------------------------------------------------------------------- ;
; advance enemmy birth column
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LR_EnemyBirthCol            ; inc enemy rebirth column
                            lda LR_EnemyBirthCol            ; get enemy rebirth column
                            cmp #LR_EnemyBirthCol_Max       ; test max column number
                            bcc GetOpenHolesMaxOff          ; check: LT - yes
                            
                            lda #LR_EnemyBirthCol_Min       ; get initial value
                            sta LR_EnemyBirthCol            ; ini enemy rebirth column
; --------------------------------------------------------------------------------------------------------------------- ;
; scan open hole times work area
; --------------------------------------------------------------------------------------------------------------------- ;
GetOpenHolesMaxOff          ldx #LR_WA_HoleMax              ; get max number of open holes
GetNextOpenHoleTime         lda LR_WA_HoleOpenTime,x        ; get next hole open time tab entry
                            
                            stx LRZ_HoleOpenTimeTabOff      ; save open holes time tab offset
                            
                            bne DecCloseHoleOpenTime        ; check: closed already - no: tick time down
                            
                            jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; tick open hole times down
; --------------------------------------------------------------------------------------------------------------------- ;
DecCloseHoleOpenTime        dec LR_WA_HoleOpenTime,x        ; dec open hole time count
                            beq CloseHoleComplete           ; check: open time out - yes: complete close
; --------------------------------------------------------------------------------------------------------------------- ;
; set open hole column and row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_WA_HoleCol,x             ; get hole column tab entry
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda LR_WA_HoleRow,x             ; get hole row tab entry
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; check hole step 01 finished
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_WA_HoleOpenTime,x        ; get open hole time count
                            cmp #LR_WA_HoleOpenTimeStep_01  ; test 1st step close already passed
                            bne ChkCloseSecondStep          ; check: NE - yes: passed
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole step 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_ImageNumber_Hole_Close ; get image close hole 1st step
                            
CloseHoleNextStep           jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldx LRZ_ScreenCol               ; get screen col ($00-$1b)
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #LR_TileNum_Empty           ; get empty tile
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
GoSetNextOpenHoleTabPtr     jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; check hole step 02 finished
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCloseSecondStep          cmp #LR_WA_HoleOpenTimeStep_02  ; test 2nd step close already passed
                            bne GoSetNextOpenHoleTabPtr     ; check: NE - yes: passed
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole step 02
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_ImageNumber_Hole_Close + $01 ; get image close hole 2nd step
                            bne CloseHoleNextStep           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; close hole complete - check if occupied by loderunner or an enemy
; --------------------------------------------------------------------------------------------------------------------- ;
CloseHoleComplete           ldx LRZ_HoleOpenTimeTabOff      ; get open holes time tab offset
                            ldy LR_WA_HoleRow,x             ; get hole row tab entry
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/ctrl data row pointers to row of open hole
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LR_WA_HoleCol,x             ; get hole column tab
                            sty LRZ_ScreenCol               ; set screen col ($00-$1b)
; --------------------------------------------------------------------------------------------------------------------- ;
; get game data tile on closed hole row
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Empty           ; test empty space
                            bne ChkLodeRuInHole             ; check: EQ - no: contains loderunner or an enemy
                            
                            jmp GameCloseHolesFinish        ; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
ChkLodeRuInHole             cmp #LR_TileNum_LodeRunner      ; test loderunner
                            bne ChkEnemyInHole              ; check: EQ - no: test enemy
                            
                            lsr LR_LodeRuState              ; trapped in hole - set LR_LodeRuState_Death
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is loderunner
; --------------------------------------------------------------------------------------------------------------------- ;
ChkEnemyInHole              cmp #LR_TileNum_Enemy           ; test enemy
                            beq EnemyKill                   ; check: EQ - yes: kill him
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the data tile on closed hole row is gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Gold            ; test gold
                            bne GoGameCloseHolesFinish      ; check: EQ - no
                            
                            dec LR_GoldToCollect            ; some gold was lost - dec gold to collect
                            
GoGameCloseHolesFinish      jmp GameCloseHolesFinish        ; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
; kill an enemy trapped in the closed hole
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyKill                   lda #LR_TileNum_BrickSoft       ; get normal brick
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            sta (LRZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #LR_TileNum_BrickSoft       ; get normal brick
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldx LR_EnemyCount               ; get number of enemies ($00-$05)
GetNextEnemyCol             lda LR_SA_EnemyCol,x            ; get enemy save area column
                            cmp LRZ_ScreenCol               ; test screen col ($00-$1b)
                            beq GetNextEnemyRow             ; check: enemy hole column found - yes
                            
                            jmp SetNextEnemyNum             ; set next enemy to check
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextEnemyRow             lda LR_SA_EnemyRow,x            ; get enemy save area row
                            cmp LRZ_ScreenRow               ; test screen row ($00-$0f)
                            bne SetNextEnemyNum             ; check: enemy hole row found - no: set next enemy to check
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy hole column and row found - disable enemy sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabEnemySpriteDisable,x     ; get disable enemy sprite tab
                            and SPENA                       ; VIC($D015) Sprite Enable Register
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
; --------------------------------------------------------------------------------------------------------------------- ;
; check if enemy still carries gold
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_SA_EnemyHoleGoldTime,x   ; get enemy either has gold or locked in a hole time
                            bpl EnemyHasGoldReset           ; check: enemy had gold: no
                            
                            dec LR_GoldToCollect            ; enemy still had gold - discount
                            
EnemyHasGoldReset           lda #LR_SA_EnemyHoleGoldTime_Ini; get intitial value
                            sta LR_SA_EnemyHoleGoldTime,x   ; set enemy either has gold or locked in a hole time
                            
                            stx LR_EnemyToMoveNum           ; set number of enemy to move
                            
                            jsr EnemyMoveStatusRestore      ; restore enemy status from save area
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            jsr ScreenImageUpdate           ; process steps for shoot/close holes/clear collected gold
                            
                            ldx LR_EnemyToMoveNum           ; get number of enemy to move
; --------------------------------------------------------------------------------------------------------------------- ;
; find a place for enemy rebirth
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$01                        ; get start with 2nd row
                            sty LRZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level ctrl data row pointer to next rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextRebirthRow           ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get next level ctrl data tile on rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LR_EnemyBirthCol            ; get enemy rebirth column
GetNextLevelCtrlTile        lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; check if the ctrl data tile is empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #LR_TileNum_Empty           ; test empty space
                            beq EnemyRevivePosSave          ; check: EQ - yes: success - found a place - revive this enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; advance to next col
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LR_EnemyBirthCol            ; inc enemy rebirth column
                            
                            ldy LR_EnemyBirthCol            ; get enemy rebirth column
                            cpy #LR_EnemyBirthCol_Max       ; test max column number
                            bcc GetNextLevelCtrlTile        ; check: LT - yes: get next level ctrl tile
; --------------------------------------------------------------------------------------------------------------------- ;
; all columns for this row are checked unsuccessfully - restart with the next row
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda #LR_EnemyBirthCol_Min       ; get start column number
                            sta LR_EnemyBirthCol            ; ini enemy rebirth column
                            
                            beq GetNextRebirthRow           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; save revive position
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyRevivePosSave          tya                             ; get rebirth column number
                            sta LR_SA_EnemyCol,x            ; set enemy save area column
                            
                            lda LRZ_ScreenRow               ; get rebirth screen row ($00-$0f)
                            sta LR_SA_EnemyRow,x            ; set enemy save area row
; --------------------------------------------------------------------------------------------------------------------- ;
; init and score enemy resurrection
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_WA_EnemyBirthStep_Ini   ; get rebirth start value
                            sta LR_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
                            
                            lda #LR_PosOnImage_Center       ; get centered position
                            sta LR_SA_EnemyPosOnImgPosY,x   ; ini enemy pos on image up/down tab
                            sta LR_SA_EnemyPosOnImgPosX,x   ; ini enemy pos on image left/right tab
                            
                            lda #LRZ_EnemySprtNum_Run_Le_00 ; get initial value
                            sta LR_SA_EnemySprtNum,x        ; set actual enemy sprite number
                            
                            ldy #>LR_Score_EnemyRebirth     ; score add value LO - a reborn enemy scores 75 points
                            lda #<LR_Score_EnemyRebirth     ; score add value HI
                            jsr StatusOutScore              ; score and update status row
                            jmp SetNextOpenHoleTabPtr       ; set next hole time tab pointer
; --------------------------------------------------------------------------------------------------------------------- ;
; count down enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextEnemyNum             dex                             ; number of enemies
                            beq GameCloseHolesFinish        ; check: all processed - yes: finish close hole
                            
                            jmp GetNextEnemyCol             ; continue resurrection
; --------------------------------------------------------------------------------------------------------------------- ;
; finish close hole
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHolesFinish        lda #LR_TileNum_BrickSoft       ; get normal brick
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #LR_TileNum_BrickSoft       ; get normal brick
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
; --------------------------------------------------------------------------------------------------------------------- ;
; check if all open holes are processed
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextOpenHoleTabPtr       ldx LRZ_HoleOpenTimeTabOff      ; get open holes time tab offset
                            dex                             ; dec open holes time tab offset
                            bmi GameCloseHolesX             ; check: all open holes processed - yes: exit
                            
                            jmp GetNextOpenHoleTime         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
GameCloseHolesX             rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyRebirth              Does    : step an enemy back to life
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyRebirth               .block                           ; 
                            ldx LR_EnemyCount               ; get number of enemies ($00-$05)
                            beq GameCloseHoles.GameCloseHolesX ; check: none - yes: exit
                            
                            lda LR_EnemyToMoveNum           ; get number of enemy to move
                            pha                             ; save number of enemy to move
                            
GetNextEnemyRebirthTime     lda LR_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            beq DecNumberOfEnemyToMove      ; check: rebirth time up - yes
                            
                            stx LR_EnemyToMoveNum           ; set number of enemy to move
                            
                            jsr EnemyMoveStatusRestore      ; restore enemy status from save area
                            
                            lda #LR_SA_EnemyHoleGoldTime_Ini; get initial value
                            sta LR_SA_EnemyHoleGoldTime,x   ; set enemy either has gold or locked in a hole time
                            
                            lda LR_SA_EnemyCol,x            ; get enemy save area column
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda LR_SA_EnemyRow,x            ; get enemy save area row
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            dec LR_WA_EnemyBirthTime,x      ; dec enemy rebirth step time
                            beq EnemyResurrection           ; check: min - yes: reactivate resurrected enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy rebirth step 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_WA_EnemyBirthTime,x      ; get enemy rebirth step time
                            cmp #LR_WA_EnemyBirthStep_01    ; test first step rebirth
                            bne ChkRebirthStepTwo           ; check: already passed - no
                            
                            lda #LRZ_ImageNumber_Rebirth    ; get first step rebirth
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            
                            lda #LRZ_ImageNumber_Rebirth    ; get first step rebirth
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
                            jmp GetNumberOfEnemyToMove      ; try next enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; enemy rebirth step 02
; --------------------------------------------------------------------------------------------------------------------- ;
ChkRebirthStepTwo           cmp #LR_WA_EnemyBirthStep_02    ; test time second step rebirth
                            bne DecNumberOfEnemyToMove      ; check: already passed - no
                            
                            lda #LRZ_ImageNumber_Rebirth + $01 ; get second step rebirth
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            jsr EnemyMoveGetScrnGfxPosXY    ; get the enemy image gfx screen position
                            
                            lda #LRZ_ImageNumber_Rebirth + $01 ; get second step rebirth
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
GetNumberOfEnemyToMove      ldx LR_EnemyToMoveNum           ; get number of enemy to move
                            
DecNumberOfEnemyToMove      dex                             ; count down enemy number
                            bne GetNextEnemyRebirthTime     ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; exit
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; restore number of enemy to move
                            sta LR_EnemyToMoveNum           ; set number of enemy to move
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EnemyResurrection         Does    : reactivate a reborn enemy
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EnemyResurrection          .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; get resurrection position from EnemyRevivePosSave - set game data row pointer to screen row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; increase enemy rebirth time directly in work area
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LR_EnemyToMoveNum           ; get number of enemy to move
                            inc LR_WA_EnemyBirthTime,x      ; enemy rebirth step time
; --------------------------------------------------------------------------------------------------------------------- ;
; get level game tile on rebirth row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScreenCol               ; get screen col ($00-$1b)
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; test if this tile in level game data is still empty - should be
; --------------------------------------------------------------------------------------------------------------------- ;
                            bne EnemyRebirth.DecNumberOfEnemyToMove ; check: empty - no: process next enemy
; --------------------------------------------------------------------------------------------------------------------- ;
; a free rebirth place was found - insert reborn enemy to game level data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Enemy           ; get enemy
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; clear enemy image on both hires screens
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            lda #LR_TileNum_Empty           ; get empty space
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; init reborn enemy
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get initial value 
                            ldx LR_EnemyToMoveNum           ; get number of enemy to move
                            sta LR_SA_EnemyHoleGoldTime,x   ; ini enemy either has gold or locked in a hole time
                            sta LR_WA_EnemyBirthTime,x      ; ini enemy rebirth step time
; --------------------------------------------------------------------------------------------------------------------- ;
; display reborn enemy tile
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Enemy           ; get enemy tile number
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
; --------------------------------------------------------------------------------------------------------------------- ;
; enable reborn enemy sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LR_EnemyToMoveNum           ; get number of enemy to move
                            lda TabEnemySpriteEnable,x      ; get enable enemy sprite tab
                            ora SPENA                       ; VIC($D015) Sprite Enable Register
                            sta SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            jmp EnemyRebirth.DecNumberOfEnemyToMove ; go set next enemy
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteEnable        = *       ; 
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $10 ; ...#....
                            .byte $40 ; .#......
                            .byte $80 ; #.......
; --------------------------------------------------------------------------------------------------------------------- ;
TabEnemySpriteDisable       = *       ; 
                            .byte $00 ; ........
                            .byte $fb ; #####.##
                            .byte $f7 ; ####.###
                            .byte $ef ; ###.####
                            .byte $bf ; #.######
                            .byte $7f ; .#######
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenClearBoth           Does    : clear the display and prepare screen hires screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenClearBoth            .block                           ; 
                            jsr ScreenDisplayClear          ; clear display grafic screen
                            jsr ScreenPrepareClear          ; clear prepare grafic screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusAreaSetup           Does    : display the status row with separator and text
;                           Expects : 
;                           Returns : 
;                           Remark  : calculate a game checksum inbetween
;                                   : protects the copy protection routine
;                                   : destroy gfx data pointer on wrong result
; --------------------------------------------------------------------------------------------------------------------- ;
StatusAreaSetup            .block                           ; 
                            ldx #$22                        ; get length of status row separator line
; --------------------------------------------------------------------------------------------------------------------- ;
; ChecksumBuild: init build checksum data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>CopyProtectionHandler     ; protect the copy protection routine from changes
                            sta ChecksumBuild.smCheckSumDataPtr_Hi ; set checksum data pointer
                            
                            lda LRZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cmp #>LR_ScreenGfxPrepare       ; test gfx prepare screen
                            beq SeperatorOutToPrepScreen    ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separater line left and right end
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$0a                        ; get grafic byte for separator line left end
                            sta LR_StatusRowSepDisp_Le_00   ; set left end 0
                            sta LR_StatusRowSepDisp_Le_01   ; set left end 1
                            sta LR_StatusRowSepDisp_Le_02   ; set left end 2
                            sta LR_StatusRowSepDisp_Le_03   ; set left end 3
                            
                            lda #$a0                        ; get grafic byte for separator line right end
                            sta LR_StatusRowSepDisp_Ri_00   ; set right end 0
                            sta LR_StatusRowSepDisp_Ri_01   ; set right end 1
                            sta LR_StatusRowSepDisp_Ri_02   ; set right end 2
                            sta LR_StatusRowSepDisp_Ri_03   ; set right end 3
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separater line middle part
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextStatusDispMidCount   ldy #$03                        ; get separator line offset
                            lda #$aa                        ; get grafic byte for separator line middle part
smAdrStatusSepDispMid_Lo    = * + $01                       ; 
smAdrStatusSepDispMid_Hi    = * + $02                       ; 
SetNextStatusDispMidPart    sta LR_StatusRowSepDisp_Mi_00,y ; set next middle part 0-3
                            
                            dey                             ; dec separator line offset
                            bpl SetNextStatusDispMidPart    ; check min - no: store next middle part byte 0-3
; --------------------------------------------------------------------------------------------------------------------- ;
; advance display screen middle part gfx pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda smAdrStatusSepDispMid_Lo    ; get gfx pointer for status row mid part LO
                            clc                             ; 
                            adc #$08                        ; advance to next gfx pos
                            sta smAdrStatusSepDispMid_Lo    ; set gfx pointer for status row mid part LO
                            bcc DecStatusDispMidCount       ; check: overflow - no
                            inc smAdrStatusSepDispMid_Hi    ; set gfx pointer for status row mid part HI
                            
DecStatusDispMidCount       dex                             ; dec length of status row separator line
                            bne GetNextStatusDispMidCount   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset status row mid part pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>LR_StatusRowSepDisp_Mi_00 ; restore old values
                            sta smAdrStatusSepDispMid_Hi    ; set start address HI
                            lda #<LR_StatusRowSepDisp_Mi_00 ; restore old values
                            sta smAdrStatusSepDispMid_Lo    ; set start address LO
                            bne StatusLineTextOut           ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; output prepare screen status row separater line left and right end
; --------------------------------------------------------------------------------------------------------------------- ;
SeperatorOutToPrepScreen    lda #$0a                        ; get grafic byte for separator line left end
                            sta LR_StatusRowSepPrep_Le_00   ; set left end 0
                            sta LR_StatusRowSepPrep_Le_01   ; set left end 1
                            sta LR_StatusRowSepPrep_Le_02   ; set left end 2
                            sta LR_StatusRowSepPrep_Le_03   ; set left end 3
                            
                            lda #$a0                        ; get grafic byte for separator line right end
                            sta LR_StatusRowSepPrep_Ri_00   ; set right end 0
                            sta LR_StatusRowSepPrep_Ri_01   ; set right end 1
                            sta LR_StatusRowSepPrep_Ri_02   ; set right end 2
                            sta LR_StatusRowSepPrep_Ri_03   ; set right end 3
; --------------------------------------------------------------------------------------------------------------------- ;
; output display screen status row separater line middle part
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextStatusPrepMidCount   ldy #$03                        ; get separator line offset
                            lda #$aa                        ; get grafic byte for separator line middle part
smAdrStatusSepPrepMid_Lo    = * + $01                       ; 
smAdrStatusSepPrepMid_Hi    = * + $02                       ; 
SetNextStatusPrepMidPart    sta LR_StatusRowSepPrep_Mi_00,y ; set next middle part 0-3
                            
                            dey                             ; dec separator line offset
                            bpl SetNextStatusPrepMidPart    ; check min - no: store next middle part byte 0-3
; --------------------------------------------------------------------------------------------------------------------- ;
; advance preparation screen middle part gfx pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda smAdrStatusSepPrepMid_Lo    ; get gfx pointer for status row mid part LO
                            clc                             ; 
                            adc #$08                        ; advance to next gfx pos
                            sta smAdrStatusSepPrepMid_Lo    ; set gfx pointer for status row mid part LO
                            bcc DecStatusPrepMidCount       ; check: overflow - no
                            inc smAdrStatusSepPrepMid_Hi    ; set gfx pointer for status row mid part HI
                            
DecStatusPrepMidCount       dex                             ; dec length of status row separator line
                            bne GetNextStatusPrepMidCount   ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; reset status row mid part pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>LR_StatusRowSepPrep_Mi_00 ; restore old value HI
                            sta smAdrStatusSepPrepMid_Hi    ; 
                            
                            lda #<LR_StatusRowSepPrep_Mi_00 ; restore old value LO
                            sta smAdrStatusSepPrepMid_Lo    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; write out the status row text
; --------------------------------------------------------------------------------------------------------------------- ;
StatusLineTextOut           lda #LR_StatusRowNumber         ; get status row row number
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda #LRZ_ScreenCol_Min          ; get initial value
                            sta LRZ_ScreenCol               ; ini screen col ($00-$1b)
                            
                            jsr TextOutHandler              ; output a $00 terminated text string
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte "s" | $80 ;               ; SCORE        MEN    LEVEL
                            .byte "c" | $80 ;               ; 
                            .byte "o" | $80 ;               ; 
                            .byte "r" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "m" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "n" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte "l" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "v" | $80 ;               ; 
                            .byte "e" | $80 ;               ; 
                            .byte "l" | $80 ;               ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            .byte " " | $80 ; <SHIFT_SPACE> ; 
                            
                            .byte $00 ; EndOfText
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ChecksumBuild             Does    : build a checksum over a selected game binary part to prevent game modifications
;                           Expects : 
;                           Returns : destroyed grafic pointer on bad checksum
; --------------------------------------------------------------------------------------------------------------------- ;
ChecksumBuild              .block                           ; 
                            ldy #CopyProtection.ChecksumBuild_End - CopyProtectionHandler.ChecksumBuild_Start ; init checksum byte count
                            lda #LR_ChecksumCalc_Start      ; ini checksum start value
AddNextChecksumValue        clc                             ; 
smCheckSumDataPtr_Lo        = * + $01                       ; was set in CopyProtection
smCheckSumDataPtr_Hi        = * + $02                       ; 
                            adc TabImageDataOff,y           ; add image data to checksum
                            eor #LR_ChecksumCalc_Flip       ; flip selected bit
                            
                            dey                             ; dec checksum count
                            bpl AddNextChecksumValue        ; check: checksum count min - no: continue
                            
                            cmp #LR_ChecksumCalc_Result     ; test the good checksum
                            beq SetGoodDataPointer          ; check: was checksum good - yes: bypass pointer destruction
; --------------------------------------------------------------------------------------------------------------------- ;
; destroy grafic pointer on bad checksum
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc ScreenImageGetBytes.smTileDataPtr ; destroy pointer to graphic pointer data in ScreenImageGetBytes
                            
SetGoodDataPointer          lda #>TabImageDataOff           ; get restore pointer to $a811
                            sta smCheckSumDataPtr_Hi        ; sset checksum data pointer HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusValuesOut           Does    : output actual level/lives/score to the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusValuesOut            .block                           ; 
                            jsr StatusOutLives              ; write out actual lives and level numbers
                            jsr StatusOutLevel              ; write out level number
; --------------------------------------------------------------------------------------------------------------------- ;
; add zero to score and output the score
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; score add value LO - no score to add
                            tay                             ; score add value HI
                            jmp StatusOutScore              ; output actual score
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutLives            Does    : write out number of lives to the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutLives             .block                           ; 
                            lda LR_NumLives                 ; get value to be converted
                            
                            ldx #LRZ_ScreenCol_Status_Lives ; get screen output col
; --------------------------------------------------------------------------------------------------------------------- ;
; entered from StatusOutLevel
; --------------------------------------------------------------------------------------------------------------------- ;
StatusRowOut                stx LRZ_ScreenCol               ; set screen output col (00-1b)
                            
                            jsr ConvertHexToDec             ; result in LR_Digit_100/LR_Digit_10/LR_Digit_1
                            
                            lda #LRZ_ScreenRow_Status_Sep   ; get status separator row number
                            sta LRZ_ScreenRow               ; set screen row (00-0f)
                            
                            lda LR_Digit_100                ; get digit 100 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jmp StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutLevel            Does    : write out the level number to the status row
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutLevel             .block                           ; 
                            lda LR_LevelNumGame             ; get game level number 001-150
                            ldx #LRZ_ScreenCol_Status_Level ; get output column
                            
                            bne StatusOutLives.StatusRowOut ; always write out number of lives
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutScore            Does    : update the status row with the actual score
;                           Expects : .A=score add value LO
;                                   : .Y=score add value HI
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutScore             .block                           ; 
                            clc                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; decimal add the new score
; --------------------------------------------------------------------------------------------------------------------- ;
                            sed                             ; 
                            adc LR_Score_Lo                 ; .A has 10th
                            sta LR_Score_Lo                 ; set score 
                            
                            tya                             ; .Y has 100th
                            adc LR_Score_MidLo              ; 
                            sta LR_Score_MidLo              ; set score
                            
                            lda #$00                        ; add carry
                            adc LR_Score_MidHi              ; 
                            sta LR_Score_MidHi              ; set score
                            
                            lda #$00                        ; add carry
                            adc LR_Score_Hi                 ; 
                            sta LR_Score_Hi                 ; set score
                            cld                             ; 
                            
                            lda #LRZ_ScreenCol_Status_Score ; get score output column
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda #LRZ_ScreenRow_Status_Sep   ; get status separator row number
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
                            
                            lda LR_Score_Hi                 ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda LR_Digit_1                  ; get digit 1 part - use only right nibble discard left nibble
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Score_MidHi              ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Score_MidLo              ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Score_Lo                 ; get score byte
                            jsr ScoreSplitDigit             ; split BCD number in 10 an 1 part for output
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            jsr StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                            
                            lda LR_Digit_1                  ; get digit 1 part
                            jmp StatusOutDigitHandler       ; output a digit to the status row of the selected gfx screen
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScoreSplitDigit           Does    : split a byte compressed decimal into two bytes
;                           Expects : .A=BCD coded digit
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScoreSplitDigit            .block                           ; 
                            sta LR_Digit_10                 ; set store score byte - digit 10 part
                            
                            and #$0f                        ; isolate right nibble
                            sta LR_Digit_1                  ; set digit 1 part
                            
                            lda LR_Digit_10                 ; get digit 10 part
                            lsr a                           ; isolate left  nibble
                            lsr a                           ; 
                            lsr a                           ; 
                            lsr a                           ; 
                            sta LR_Digit_10                 ; set digit 10 part
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ConvertHexToDec           Does    : set up a three char decimal value from a hex digit
;                           Expects : .A=hex value
;                           Returns : result in LR_Digit_100/LR_Digit_10/LR_Digit_1
; --------------------------------------------------------------------------------------------------------------------- ;
ConvertHexToDec            .block                           ; 
                            ldx #$00                        ; get init value
                            stx LR_Digit_10                 ; ini digit 10 part
                            stx LR_Digit_100                ; ini digit 100 part
                            
Count_100s                  cmp #$64                        ; test 100
                            bcc Count_10s                   ; check: underflow - yes: stop counting 100s
                            
                            inc LR_Digit_100                ; count digit 100 part
                            
                            sbc #$64                        ; sub 100
                            bne Count_100s                  ; always
                            
Count_10s                   cmp #$0a                        ; test 10
                            bcc Count_1s                    ; check: underflow - yes: stop counting 10s
                            
                            inc LR_Digit_10                 ; count digit 10 part
                            
                            sbc #$0a                        ; sub 10
                            bne Count_10s                   ; always
                            
Count_1s                    sta LR_Digit_1                  ; set remaining digit 1 count
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StatusOutDigitHandler     Does    : output a digit to the status row of the selected gfx screen
;                           Expects : .A=decimal value
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StatusOutDigitHandler      .block                           ; 
                            clc                             ; 
                            adc #LRZ_ImageNumber_Digit      ; make it a digit image
                            
                            ldx LRZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cpx #>LR_ScreenGfxPrepare       ; test gfx prepare screen
                            beq OutToScreenPrepare          ; check: EQ - yes
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
OutToScreenPrepare          jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextCharPrepare           Does    : prepare a text char for output
;                                   : the loderunner char values are slightly higher than the PETSCII ones
;                           Expects : .A=char to check
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextCharPrepare            .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check range A-Z
; --------------------------------------------------------------------------------------------------------------------- ;
                            cmp #"a" | $80                  ; test <SHIFT> + A
                            bcc ChkCharSubstitution         ; check: LT - yes: not in range A-Z
                            
                            cmp #"z" | $80 + $01            ; test <SHIFT + Z + 1
                            bcc SubCorrectionValue          ; check: LT - yes: char in range A-Z
; --------------------------------------------------------------------------------------------------------------------- ;
; substitute non A-Z chars
; --------------------------------------------------------------------------------------------------------------------- ;
ChkCharSubstitution         ldx #$7c                        ; get dislocation value of LR "A" and PETSCII "A"
                            
                            cmp #" " | $80                  ; test <SHIFT_SPACE>
                            beq SetSubstitutionValue        ; check: EQ - yes: substitute from .X
; --------------------------------------------------------------------------------------------------------------------- ;
; get initial substitution value of 'Z' + 1
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #"z" | $80 + $01            ; get substitution start value
                            
                            cmp #">" | $80                  ; test <SHIFT> + ">"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"." | $80                  ; test <SHIFT> + "."
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"(" | $80                  ; test <SHIFT> + "("
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #")" | $80                  ; test <SHIFT> + ")"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"/" | $80                  ; test <SHIFT> + "/"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"-" | $80                  ; test <SHIFT> + "-"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
                            
                            inx                             ; inc substitution value
                            cmp #"<" | $80                  ; test <SHIFT> + "<"
                            beq SetSubstitutionValue        ; check: EQ - yes: substitue from .X
; --------------------------------------------------------------------------------------------------------------------- ;
; replace all undefined characters with a blank - but the value of $10 is wrong (Loderunner image run right 01)
; --------------------------------------------------------------------------------------------------------------------- ;
;                           lda #$00                        ; get substitution value for all others
                            lda #$10                        ; get substitution value for all others
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetSubstitutionValue        txa                             ; set selected substitution value
                            
SubCorrectionValue          sec                             ; 
                            sbc #$7c                        ; sub dislocation value of LR "A" and PETSCII "A"
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextOutCharHandler        Does    : control the output of a single char
;                           Expects : .A=output char
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextOutCharHandler         .block                           ; 
                            cmp #$8d                        ; test <NEWLINE>
                            beq TextCharOutNewLine          ; check: EQ - yes
                            
                            jsr TextCharPrepare             ; prepare and substitute char for output
                            
                            ldx LRZ_TargetGfxOutput         ; get target output indicator - $20=$2000 $40=$4000
                            cpx #>LR_ScreenGfxPrepare       ; test gfx prepare screen
                            beq CharOutToScreenPrep         ; check: EQ - yes
                            
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CharOutToScreenPrep         jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            inc LRZ_ScreenCol               ; inc screen col ($00-$1b)
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextCharOutNewLine        Does    : set text cursor to start of a new line
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
TextCharOutNewLine         .block                           ; 
                            inc LRZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            lda #LRZ_ScreenCol_Min          ; get initial value
                            sta LRZ_ScreenCol               ; ini screen col ($00-$1b)
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; TextOutHandler            Does    : control the output of a $00 terminated text string
;                           Expects : 
;                           Returns : 
;                           Remark  : returns to the statement directly behind the EoT marker $00
; --------------------------------------------------------------------------------------------------------------------- ;
TextOutHandler             .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; start with the text directly following the subroutine call
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; pull the text start address LO from stack
                            sta LRZ_InputTextOutPtr_Lo      ; set input text pointer LO
                            
                            pla                             ; pull the text start address HI from stack
                            sta LRZ_InputTextOutPtr_Hi      ; set input text pointer HI
                            bne IncTextPointer              ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; output the text bytes until EoT
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextTextByte             ldy #$00                        ; get offset
                            lda (LRZ_InputTextOutPtr),y     ; get text byte
                            beq PrepareReturn               ; check: EoT - yes: end of text
                            
                            jsr TextOutCharHandler          ; control the output of a single char
                            
IncTextPointer              inc LRZ_InputTextOutPtr_Lo      ; inc input text pointer LO
                            bne GetNextTextByte             ; check: overflow - no 
                            inc LRZ_InputTextOutPtr_Hi      ; inc input text pointer HI
                            bne GetNextTextByte             ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; push actual text pointer as new return address to the stack
; --------------------------------------------------------------------------------------------------------------------- ;
PrepareReturn               lda LRZ_InputTextOutPtr_Hi      ; get input text end pointer HI
                            pha                             ; push the text end address HI to the stack
                            
                            lda LRZ_InputTextOutPtr_Lo      ; get input text end pointer LO
                            pha                             ; push the text end address LO to the stack
                            
                            rts                             ; return behind the input text EoT marker
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; EditorErrorBeep           Does    : all editors output of an error beep signal
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
EditorErrorBeep            .block                           ; 
                            sei                             ; disable interrupts
; --------------------------------------------------------------------------------------------------------------------- ;
; turn beep on
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$60                        ; get beep
                            sta FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
; --------------------------------------------------------------------------------------------------------------------- ;
; set beep output timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$38                        ; get wait time HI
                            ldx #$00                        ; get wait time LO
DecNextBeepTime             dex                             ; dec wait time LO
                            bne DecNextBeepTime             ; check: min - no: continue
                            
                            dey                             ; dec wait time HI
                            bne DecNextBeepTime             ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; turn beep off
; --------------------------------------------------------------------------------------------------------------------- ;
                            sty FREHI1                      ; SID($D401) Oscillator 1 Freq Ctrl (HI byte)
                            
                            cli                             ; ensable interrupts
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; BED_CursorBlink           Does    : board editor: blink the input cursor while waiting for player input
;                           Expects : .A=character to blink
;                           Returns : .A=player input key
; --------------------------------------------------------------------------------------------------------------------- ;
BED_CursorBlink            .block                           ; 
                            sta LR_DisplayChr               ; save char under cursor
                            
GetNextWaitTimeInitValue    lda #$00                        ; get intitial value
                            sta LR_WaitTime_Lo              ; set wait timer LO
                            
                            lda #$0a                        ; get initial value
                            sta LR_WaitTime_Hi              ; set wait timer HI
                            
                            lda #LRZ_ImageNumber_Blank      ; preset clear blank
                            
                            ldx LR_DisplayChr               ; restore char under cursor
                            bne CharImageOutToScreen        ; check: char - yes: bypass substitution
                            
                            lda #LRZ_ImageNumber_Blank_Rev  ; get char substitution reversed blank
; --------------------------------------------------------------------------------------------------------------------- ;
; cursor blink phase 01 - display blank
; --------------------------------------------------------------------------------------------------------------------- ;
CharImageOutToScreen        jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
ChkNextPlayerAction_Blank   jsr PlayerCheckInput            ; look for player input
                            bcs SavePlayerInput             ; check: player action - yes
                            
                            dec LR_WaitTime_Lo              ; dec wait time LO
                            bne ChkNextPlayerAction_Blank   ; check: min - no: continue waiting for player action
                            
                            dec LR_WaitTime_Hi              ; dec wait time HI
                            bne ChkNextPlayerAction_Blank   ; check: min - no: continue waiting for player action
; --------------------------------------------------------------------------------------------------------------------- ;
; cursor blink phase 02 - display char under cursor
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_DisplayChr               ; get byte under cursor
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            lda #$00                        ; get initial value
                            sta LR_WaitTime_Lo              ; ini wait timer LO
                            
                            lda #$0a                        ; get initial value
                            sta LR_WaitTime_Hi              ; ini wait timer HI
                            
ChkNextPlayerAction         jsr PlayerCheckInput            ; look for player input
                            bcs SavePlayerInput             ; check: player action - yes
                            
                            dec LR_WaitTime_Lo              ; dec timer LO
                            bne ChkNextPlayerAction         ; check: underflow - no: continue
                            
                            dec LR_WaitTime_Hi              ; dec timer HI
                            bne ChkNextPlayerAction         ; check: underflow - no: continue
                            
                            jmp GetNextWaitTimeInitValue    ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SavePlayerInput             pha                             ; save player input key
; --------------------------------------------------------------------------------------------------------------------- ;
; redisplay character under cursor in case of a player input in the blank blink phase
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_DisplayChr               ; get redisplay chr under cursor
                            jsr ScreenImageOutToDisplay     ; direct output to display screen
                            
                            pla                             ; restore player input key
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; PlayerCheckInput          Does    : look for player input
;                           Expects : 
;                           Returns : .C=0 - flag no player action
;                                   : .C=1 - flag player action
; --------------------------------------------------------------------------------------------------------------------- ;
PlayerCheckInput           .block                           ; 
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick moves
; --------------------------------------------------------------------------------------------------------------------- ;
                            and #CIAPRA_JOY_MOVE            ; isolate joystick move bits: bit3=right  bit2=left  bit1=down  bit0=up
                            eor #CIAPRA_JOY_MOVE            ; reverse move bits - now 1=pressed
                            bne SetFlagPlayerReacted        ; check: pressed move - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check joystick fire
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            beq SetFlagPlayerReacted        ; check: pressed fire - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check keyboard
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_KeyNew                   ; get actual key
                            bne SetFlagPlayerReacted        ; check: new key - yes
; --------------------------------------------------------------------------------------------------------------------- ;
                            clc                             ; flag no player action
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
SetFlagPlayerReacted        sec                             ; flag player action
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutToDisplay   Does    : set screen display as target
;                           Expects : .A=image number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutToDisplay    .block                           ; 
                            sta LRZ_ImageNumber             ; set image number - level input tile $00-$09/sprite number
                            
                            lda #>LR_ScreenGfxDisplay       ; get adr gfx display screen HI
                            bne ScreenImageOut              ; always
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutToPrepare   Does    : set screen prepare as target
;                           Expects : .A=image number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutToPrepare    .block                           ; 
                            sta LRZ_ImageNumber             ; set level input tile $00-$09
                            
                            lda #>LR_ScreenGfxPrepare       ; get adr gfx prepare screen HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOut            Does    : output an image byte to its correct grafic screen location
;                           Expects : .A=target output screen address HI
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOut             .block                           ; 
                            sta LRZ_ImageOutputScreen       ; set target output  $20=$2000 $40=$4000
                            
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            ldx LRZ_ScreenCol               ; get screen col ($00-$1b)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            sty LRZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            
                            jsr SpriteDisplayHandler        ; display sprites and get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return here if a sprite was displayed
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            stx LRZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of $4f substitution)
                            
                            lda TabGfxImageClearLeft,x      ; get insert image left tab  (4 different image positions)
                            sta LRZ_GfxImageClearLeft       ; set isolate right grafic part
                            
                            lda TabGfxImageClearRight,x     ; get insert image right tab (4 different image positions)
                            sta LRZ_GfxImageClearRight      ; set isolate left grafic part
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to LRZ_ImageBuffer
                            
                            lda #LR_ImageHeight             ; get height of each image
                            sta LRZ_ImageHeight             ; set image height
                            
                            ldx #$00                        ; ini offset to image buffer byte
                            
                            lda LRZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)
                            cmp #$05                        ; test row positions needs an additional offset of $08
                            bcs InsNextImageGfxByteLong     ; check: GE - yes: never true as LRZ_ScreenGfxPartPosY is $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
; insert image byte to its grafic screen location
; --------------------------------------------------------------------------------------------------------------------- ;
InsNextImageGfxByte         ldy LRZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetRowPointer         ; set grafic screen pointer to the output rows column
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - left part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get left part of gfx image
                            and LRZ_GfxImageClearLeft       ; clear the left gfx part
                            ora LRZ_ImageBufferRowPos_01,x  ; insert new image byte from pos_01
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set left part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $02 - right part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get grafic screen image byte
                            and LRZ_GfxImageClearRight      ; clear the right grafic part
                            ora LRZ_ImageBufferRowPos_01,x  ; insert image buffer byte part 01
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set write grafic screen image byte
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - always empty
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte of image buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc LRZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec LRZ_ImageHeight             ; dec image height
                            bne InsNextImageGfxByte         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as LRZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
InsNextImageGfxByteLong     ldy LRZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetRowPointer         ; set grafic screen pointer to the output rows column
; --------------------------------------------------------------------------------------------------------------------- ;
; position $01 - left part
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get left part of gfx image
                            and LRZ_GfxImageClearLeft       ; clear the left gfx part
                            ora LRZ_ImageBuffer,x           ; insert new image byte from pos_01
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set left part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $02 - middle part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda LRZ_ImageBuffer,x           ; get image buffer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set middle part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
; position $03 - right part
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; inc offset to offset image byte pos_03
                            
                            ldy #$10                        ; get offset image right part
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get right part of gfx image
                            and LRZ_GfxImageClearRight      ; clear the right image part
                            ora LRZ_ImageBuffer,x           ; insert new image byte from pos_03
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set right part of gfx image
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc LRZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec LRZ_ImageHeight             ; dec image height
                            bne InsNextImageGfxByteLong     ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabGfxImageClearLeft        = *       ; 
                            .byte $00 ; ........
                            .byte $c0 ; ##......
                            .byte $f0 ; ####....
                            .byte $fc ; ######..
; --------------------------------------------------------------------------------------------------------------------- ;
TabGfxImageClearRight       = *       ; 
                            .byte $3f ; ..######
                            .byte $0f ; ....####
                            .byte $03 ; ......##
                            .byte $00 ; ........
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageUpdate         Does    : process steps for shoot and close holes
;                                   : clear collected gold
;                           Expects : .A=image number
;                                   : .Y=image screen offset PosY
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageUpdate          .block                           ; 
                            sty LRZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            sta LRZ_ImageNumber             ; set level input tile $00-$09
                            
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            sta LRZ_WorkSpritePosX          ; 
                            stx LRZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of $4f substitution)
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to LRZ_ImageBuffer
                            
                            ldx #LR_ImageHeight             ; get image height
                            stx LRZ_ImageHeight             ; set image height
                            
                            ldx #$00                        ; ini image buffer offset
                            
                            lda LRZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)
                            cmp #$05                        ; test row positions needs an additional offset of $08
                            bcs UpdNextImageGfxByteLong     ; check: GE - yes: never true as LRZ_ScreenGfxPartPosY is $00-$03
                            
GetNextGfxRowOffset         ldy LRZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (LRZ_ScreenGfxDisplayPtr),y ; isolate screen display grafic byte
                            ora (LRZ_ScreenRowPreparePtr),y ; insert screen prepare grafic byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image right part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (LRZ_ScreenGfxDisplayPtr),y ; isolate screen display grafic byte
                            ora (LRZ_ScreenRowPreparePtr),y ; insert screen prepare grafic byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic byte
; --------------------------------------------------------------------------------------------------------------------- ;
; overread 3d image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc LRZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec LRZ_ImageHeight             ; dec image height
                            bne GetNextGfxRowOffset         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as LRZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
UpdNextImageGfxByteLong     ldy LRZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (LRZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            ora (LRZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (LRZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            ora (LRZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$10                        ; get offset image right part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            eor #$ff                        ; flip all bits
                            and (LRZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            ora (LRZ_ScreenRowPreparePtr),y ; hidden grafic pointer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc LRZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec LRZ_ImageHeight             ; dec image height
                            bne UpdNextImageGfxByteLong     ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageOutSpecial     Does    : show loderunner and enemy sprites
;                                   : show images for hidden ladders/shoot sparks/gold/enemy rebirth steps
;                           Expects : .A=image number
;                                   ; .Y=grafic screen column pos on row
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageOutSpecial      .block                           ; 
                            sty LRZ_ScreenGfxRowPosY        ; set gfx screen image row offset
                            sta LRZ_ImageNumber             ; set level input tile $00-$09
                            
                            jsr SpriteDisplayHandler        ; display sprites and get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return here if a sprite was displayed
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr ScreenRowByteColNumber      ; .X=rest of (screen image col offset) MOD 4
                            
                            sta LRZ_WorkSpritePosX          ; 
                            stx LRZ_ScreenGfxPartPosY       ; set image position number  (bits 0-1 of 4f substitution)
                            
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to LRZ_ImageBuffer
                            
                            lda #LR_ImageHeight             ; get image height
                            sta LRZ_ImageHeight             ; ini image height
                            
                            ldx #$00                        ; get initial value
                            stx LRZ_LodeRuEnemyCollision    ; ini loderunner-enemy sprite collision  $01=lr caught
                            
                            lda LRZ_ScreenGfxPartPosY       ; get image position number  (bits 0-1 of $4f substitution)
                            cmp #$05                        ; test row positions needs an additional offset of $08
                            bcs InsNextImageGfxByteLongSprt ; check: GE - yes: never true as LRZ_ScreenGfxPartPosY is $00-$03
                            
GetNextGfxRowOffset         ldy LRZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            ora (LRZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            ora (LRZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; overread 3d image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; discard 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc LRZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec LRZ_ImageHeight             ; dec image height
                            bne GetNextGfxRowOffset         ; check: min - no: continue
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; never reached as LRZ_ScreenGfxPartPosY contains only four values betweem $00-$03
; --------------------------------------------------------------------------------------------------------------------- ;
InsNextImageGfxByteLongSprt ldy LRZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            jsr ScreenSetGfxPtrBoth         ; set grafic pointers for display an prepare screens
; --------------------------------------------------------------------------------------------------------------------- ;
; output 1st image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #$00                        ; get offset image left part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            ora (LRZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 2nd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$08                        ; get offset image middle part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            ora (LRZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; output 3rd image byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer byte
                            
                            ldy #$10                        ; get offset image right part
                            lda LRZ_ImageBuffer,x           ; get image byte
                            ora (LRZ_ScreenGfxDisplayPtr),y ; screen grafic pointer byte
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; point to next image buffer triplet
                            
                            inc LRZ_ScreenGfxRowPosY        ; inc gfx screen image row offset
                            
                            dec LRZ_ImageHeight             ; dec image height
                            bne InsNextImageGfxByteLongSprt ; check: min - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenImageGetBytes       Does    : get the appropriate image byte from tabled data
;                           Expects : .X=values $00-$03 for the 4 different image types
;                           Returns : 
;                           Remark  : image data access
;                                   : ini pointer LRZ_ImageDataOffPtr to TabImageDataOff to start
;                                   : get the image data start address according to image pos-X
;                                   : do image height times
;                                   :   get the image number
;                                   :   get offset to image data with LRZ_ImageDataOffPtr and the image number as an offset
;                                   :   get image row byte 1 - from $a000/$a200/$a400/$a600 - at TabImageDataOff_Len
;                                   :   get image row byte 2 - from $a100/$a300/$a500/$a700 - at TabImageDataOff_Len       - part 1 - combined with part 2
;                                   :                        - from $a000/$a200/$a400/$a600 - at TabImageDataOff_Len * $02 - part 2
;                                   :   get image row byte 3 - from $a100/$a300/$a500/$a700 - at TabImageDataOff_Len * $02
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenImageGetBytes        .block                           ; 
                            lda #LRZ_ImageHeight_Max        ; get image 11 rows with 3 bytes each
                            sta LRZ_ImageHeight             ; ini image row count
                            
                            lda #$00                        ; get initial value
                            sta LRZ_ImageDataOffPtr_Lo      ; ini image data pointer LO
; --------------------------------------------------------------------------------------------------------------------- ;
; image data tab pointer will be destroyed in case of a bad checksum
; --------------------------------------------------------------------------------------------------------------------- ;
smTileDataPtr               = * + $01                       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; init self modified data image pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #>TabImageDataOff           ; get adr image data row pointer
                            sta LRZ_ImageDataOffPtr_Hi      ; ini image pointer HI to TabImageDataOff
; --------------------------------------------------------------------------------------------------------------------- ;
; four different images
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy TabImageDataAdr_Hi,x        ; get four different image pos tab HI
                            sty smGetImageDataByte_01       ; ini $00=$a000 $01=$a200 $02=$a400 $03=$a600
                            sty smGetImageDataByte_02_P_02  ; ini $00=$a000 $01=$a200 $02=$a400 $03=$a600
                            
                            iny                             ; inc image pos tab HI
                            sty smGetImageDataByte_02_P_01  ; ini $00=$a100 $01=$a300 $02=$a500 $03=$a700
                            sty smGetImageDataByte_03       ; ini $00=$a100 $01=$a300 $02=$a500 $03=$a700
                            
                            ldx #$00                        ; ini zero page image buffer storage offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get image data byte $01 from $a000/$a200/$a400/$a600
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextImageDataByteOff     ldy LRZ_ImageNumber             ; get image number as offset
                            lda (LRZ_ImageDataOffPtr),y     ; get the offset to the image data bytes
                            tay                             ; set as data offset
                            
smGetImageDataByte_01       = * + $02                       ; 
                            lda TabImageData,y              ; get 1st image byte from $a000/$a200/$a400/$a600 -  (1*off_len)
                            sta LRZ_ImageBuffer,x           ; set it to 1st buffer position
; --------------------------------------------------------------------------------------------------------------------- ;
; get image data byte $02 - from $a100/$a300/$a500/$a700 - part 01
; --------------------------------------------------------------------------------------------------------------------- ;
smGetImageDataByte_02_P_01  = * + $02                       ; 
                            lda TabImageData,y              ; get 2nd image byte from $a100/$a300/$a500/$a700 - 1st part (1*off_len) 
                            sta LRZ_ImageBufferRowPos_02,x  ; set it to 2nd position
; --------------------------------------------------------------------------------------------------------------------- ;
; advance image data pointer - point to the next image data byte offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_ImageDataOffPtr_Lo      ; get image data pointer LO
                            clc                             ; 
                            adc #TabImageDataOff_Len        ; add max number of offsets
                            sta LRZ_ImageDataOffPtr_Lo      ; set image data pointer LO
                            
                            lda LRZ_ImageDataOffPtr_Hi      ; get image data pointer HI
                            adc #$00                        ; add .C
                            sta LRZ_ImageDataOffPtr_Hi      ; set image data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get image data byte $02 - from $a000/$a200/$a400/$a600 - part 02 - combine with part 01
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ImageNumber             ; get image number
                            lda (LRZ_ImageDataOffPtr),y     ; get offset to the image data bytes
                            tay                             ; set offset to the image data bytes
                            
smGetImageDataByte_02_P_02  = * + $02                       ; 
                            lda TabImageData,y              ; get 2nd image byte from $a000/$a200/$a400/$a600 - 2nd part (2*off_len)
                            ora LRZ_ImageBufferRowPos_02,x  ; insert image buffer byte part 02
                            sta LRZ_ImageBufferRowPos_02,x  ; set it to 2nd buffer position
; --------------------------------------------------------------------------------------------------------------------- ;
; get image data byte $03 - from $a100/$a300/$a500/$a700
; --------------------------------------------------------------------------------------------------------------------- ;
smGetImageDataByte_03       = * + $02                       ; 
                            lda TabImageData,y              ; get 3rd image byte from $a100/$a300/$a500/$a700 -  (2*off_len)
                            sta LRZ_ImageBufferRowPos_03,x  ; set it to 3rd buffer position
; --------------------------------------------------------------------------------------------------------------------- ;
; advance image data pointer - point to the next image data byte offset - prepare for next round
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_ImageDataOffPtr_Lo      ; get image data pointer LO
                            clc                             ; 
                            adc #TabImageDataOff_Len        ; add max number of images
                            sta LRZ_ImageDataOffPtr_Lo      ; set image data pointer LO
                            
                            lda LRZ_ImageDataOffPtr_Hi      ; get image data pointe HI
                            adc #$00                        ; add .C
                            sta LRZ_ImageDataOffPtr_Hi      ; set image data pointe HI
; --------------------------------------------------------------------------------------------------------------------- ;
; advance image byte output buffer offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            inx                             ; inc zero page image buffer storage offset to next row
                            inx                             ; 
                            inx                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; dec imaage height and check end of copy
; --------------------------------------------------------------------------------------------------------------------- ;
                            dec LRZ_ImageHeight             ; image row count
                            bne GetNextImageDataByteOff     ; check: min - no: fill next zero page image buffer storage row
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataAdr_Hi          = *                               ; hi address of the 4 different image position types
                            .byte >TabImageDataPos_01_Part_01 ; $00 - from $A000
                            .byte >TabImageDataPos_02_Part_01 ; $01 - from $A200
                            .byte >TabImageDataPos_03_Part_01 ; $02 - from $A400
                            .byte >TabImageDataPos_04_Part_01 ; $03 - from $A600
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; SpriteDisplayHandler      Does    : eventually display sprites and get loderunner sprite/sprite collision value
;                           Expects : .X=screen image column offset
;                           Returns : 
;                           Remark  : does not return to caller if a sprite was set up
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDisplayHandler       .block                           ; 
                            lda LR_SpriteShow               ; get control sprite show - $05=no sprite display in edit mode
                            bne SpriteDisplayHandlerX       ; check: LR_SpriteShow_Off - yes: no sprite display - exit
; --------------------------------------------------------------------------------------------------------------------- ;
; get the images sprite number replacement value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_ImageNumber             ; get image number
                            cmp #LRZ_ImageNumber_Hole_Close + $02 ; test max image number
                            bcs SpriteDisplayHandlerX       ; check: GE - yes: no display - exit
                            
                            tay                             ; set image number as offset
                            lda TabImageToSpriteNumValue,y  ; get image is sprite flag
                            bmi SpriteDisplayHandlerX       ; check: flag no sprite - yes: no display - exit
                            beq SetSpriteColOff             ; check: flag loderunner - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; does not return to caller from here
; --------------------------------------------------------------------------------------------------------------------- ;
; store enemy sprite image number
; --------------------------------------------------------------------------------------------------------------------- ;
                            sta LRZ_ImageNumber             ; set enemy sprite image number
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite screen image column offset
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpriteColOff             stx LRZ_WorkSpritePosX          ; save grafic row column offset from ScreenGetGfxPosXY
                            jsr SpriteDataBufferFill        ; fill the appropriate sprite buffer with sprite image data
; --------------------------------------------------------------------------------------------------------------------- ;
; .X=VIC sprite SPnX register offset
; --------------------------------------------------------------------------------------------------------------------- ;
; calc sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_WorkSpritePosX          ; restore grafic PosX from ScreenGetGfxPosXY
                            clc                             ; 
                            adc #VICSCN_MINX_40 / $02       ; add half of screen border width
                            asl a                           ; *2 - expand TabScreenColOff value to real width
                            and #$f8                        ; #####... - $08 * INT(PosX / $08)
                            sta SP0X,x                      ; set VIC($D000) Sprite 0 X-Pos (Bits 0-7 - Bit 8 in MSIGX = $D010)
                            
                            bcc SpriteClearMSB              ; check: MSB PosX to be set - no: clear PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSprite_MSB_Set,x         ; get sprite set x pos msb tab
                            ora MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            sta MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            
                            jmp SetSpritePosY               ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; clear sprite PosX MSB
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteClearMSB              lda TabSprite_MSB_Clear,x       ; get sprite clear x pos msb tab
                            and MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
                            sta MSIGX                       ; VIC($D010) MSB X-Pos Sprites 0-7
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite PosY
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpritePosY               lda LRZ_ScreenGfxRowPosY        ; get gfx screen image row offset
                            clc                             ; 
                            adc #VICSCN_MINY_25 - $01       ; add screen border width
                            sta SP0Y,x                      ; VIC($D001) Sprite 0 Y-Pos (Bits 0-7)
; --------------------------------------------------------------------------------------------------------------------- ;
; get loderunner sprite/sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda SPSPCL                      ; VIC($D01E) Sprite-Sprite Collision - Cleared on read
                            and #SPSPCL_M0M                 ; .......# - isolate bit 0
                            sta LRZ_LodeRuEnemyCollision    ; set loderunner-enemy sprite collision value
; --------------------------------------------------------------------------------------------------------------------- ;
; do not return to caller
; --------------------------------------------------------------------------------------------------------------------- ;
                            pla                             ; discard the return address
                            pla                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; exit point for no sprite display
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDisplayHandlerX       rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSprite_MSB_Set           = * + $00 ; 
TabSprite_MSB_Clear         = * + $01 ; 
                            .byte %00000001 ; set   - sprite x pos msb tab
                            .byte %11111110 ; clear - sprite x pos msb tab
                            
                            .byte %00000010 ; set   - sprite x pos msb tab
                            .byte %11111101 ; clear - sprite x pos msb tab
                                  
                            .byte %00000100 ; set   - sprite x pos msb tab
                            .byte %11111011 ; clear - sprite x pos msb tab
                                  
                            .byte %00001000 ; set   - sprite x pos msb tab
                            .byte %11110111 ; clear - sprite x pos msb tab
                                  
                            .byte %00010000 ; set   - sprite x pos msb tab
                            .byte %11101111 ; clear - sprite x pos msb tab
                                  
                            .byte %00100000 ; set   - sprite x pos msb tab
                            .byte %11011111 ; clear - sprite x pos msb tab
                                  
                            .byte %01000000 ; set   - sprite x pos msb tab
                            .byte %10111111 ; clear - sprite x pos msb tab
                                  
                            .byte %10000000 ; set   - sprite x pos msb tab
                            .byte %01111111 ; clear - sprite x pos msb tab
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageToSpriteNumValue    = *       ; 
                            .byte $ff ; $00 - Level Tile Blank         - no sprite
                            .byte $ff ; $01 - Level Tile Wall Weak     - no sprite
                            .byte $ff ; $02 - Level Tile Wall Hard     - no sprite
                            .byte $ff ; $03 - Level Tile Ladder        - no sprite
                            .byte $ff ; $04 - Level Tile Pole          - no sprite
                            .byte $ff ; $05 - Level Tile Wall Trap     - no sprite
                            .byte $ff ; $06 - Level Tile Ladder Secret - no sprite
                            .byte $ff ; $07 - Level Tile Gold          - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $0b ; $08 - Level Tile Enemy      - Run Le  00
                            .byte $00 ; $09 - Level Tile Loderunner - Run Ri  00
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $0a - Blank Reverse             - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; $0b - Loderunner Run  Le 00    
                            .byte $00 ; $0c - Loderunner Run  Le 01    
                            .byte $00 ; $0d - Loderunner Run  Le 02    
                            .byte $00 ; $0e - Loderunner Ladder  00    
                            .byte $00 ; $0f - Loderunner Fire Le    
                            .byte $00 ; $10 - Loderunner Run  Ri 01
                            .byte $00 ; $11 - Loderunner Run  Ri 02
                            .byte $00 ; $12 - Loderunner Ladder  01
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02 
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $1b - Shoot Spark Le    00 - no sprite
                            .byte $ff ; $1c - Shoot Spark Le    01 - no sprite
                            .byte $ff ; $1d - Shoot Spark Le/Ri 02 - no sprite
                            .byte $ff ; $1e - Shoot Spark Le/Ri 03 - no sprite
                            .byte $ff ; $1f - Shoot Melt Ground 00 - no sprite
                            .byte $ff ; $20 - Shoot Melt Ground 01 - no sprite
                            .byte $ff ; $21 - Shoot Melt Ground 02 - no sprite
                            .byte $ff ; $22 - Shoot Melt Ground 03 - no sprite
                            .byte $ff ; $23 - Shoot Melt Ground 04 - no sprite
                            .byte $ff ; $24 - Shoot Melt Ground 05 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $00 ; $25 - Loderunner Fire Ri
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $26 - Shoot Spark Ri    00 - no sprite lr fire Ri
                            .byte $ff ; $27 - Shoot Spark Ri    01 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $09 ; $28 - Enemy Run  Ri 00
                            .byte $10 ; $29 - Enemy Run  Ri 01
                            .byte $11 ; $2a - Enemy Run  Ri 02
                            .byte $0c ; $2b - Enemy Run  Le 01
                            .byte $0d ; $2c - Enemy Run  Le 02
                            .byte $15 ; $2d - Enemy Pole Ri 00
                            .byte $16 ; $2e - Enemy Pole Ri 01
                            .byte $17 ; $2f - Enemy Pole Ri 02
                            .byte $18 ; $30 - Enemy Pole Le 00
                            .byte $19 ; $31 - Enemy Pole Le 01
                            .byte $1a ; $32 - Enemy Pole Le 02
                            .byte $0e ; $33 - Enemy Ladder  00
                            .byte $12 ; $34 - Enemy Ladder  01
                            .byte $14 ; $35 - Enemy Fall Ri
                            .byte $13 ; $36 - Enemy Fall Le
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $ff ; $37 - Close Hole Phase  00 - no sprite
                            .byte $ff ; $38 - Close Hole Phase  01 - no sprite
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; SpriteDataBufferFill      Does    : fill the appropriate sprite buffer with sprite image data
;                           Expects : .A=image number
;                           Returns : .X=VIC sprite SPnX register offset for sprite PosX
; --------------------------------------------------------------------------------------------------------------------- ;
SpriteDataBufferFill       .block                           ; 
                            pha                             ; save image id
                            
                            lda LRZ_WorkSpritePosX          ; get grafic xr offset from ScreenGetGfxPosXY
                            and #%00000011                  ; isolate bit 0-1 for the 4 different image types
                            tax                             ; set values $00-$03 for the 4 different image types
                            jsr ScreenImageGetBytes         ; get image bytes from tabled data to LRZ_ImageBuffer
                            
                            pla                             ; restore image id
; --------------------------------------------------------------------------------------------------------------------- ;
; loderunner always has number sprite number $00
; --------------------------------------------------------------------------------------------------------------------- ;
                            beq SetSpriteBufferTabIndex     ; check: loderunner - yes: bypass get enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
; get enemy number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LR_EnemyToMoveNum           ; get number of enemy to move - up to $05 enemies
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite number as sprite tables index
; --------------------------------------------------------------------------------------------------------------------- ;
SetSpriteBufferTabIndex     tax                             ; set as sprite buffer table index
; --------------------------------------------------------------------------------------------------------------------- ;
; set sprite data buffer pointer
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSpriteBuffer_Lo,x        ; get sprite data pos LO tab
                            sta smSpriteDataBuffer_Lo       ; set modify store address LO
                            
                            lda TabSpriteBuffer_Hi,x        ; get sprite data pos HI tab
                            sta smSpriteDataBuffer_Hi       ; set modify store address HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabSpriteNumber,x           ; get sprite number
                            tax                             ; save sprite number
; --------------------------------------------------------------------------------------------------------------------- ;
; copy sprite data to its data buffer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #LR_ImageHeight * $03 - $01 ; get $03 bytes per row image height times
GetNextSpiteDataBufferByte  lda LRZ_ImageBuffer_Long,y      ; get all 33 image bytes from image buffer
smSpriteDataBuffer_Lo       = * + $01                       ; 
smSpriteDataBuffer_Hi       = * + $02                       ; 
SetSpiteDataBufferByte      sta SetSpiteDataBufferByte,y    ; set image byte to correct sprite data storage  ($0c00-$0dff)
                            
                            dey                             ; dec image byte count
                            bpl GetNextSpiteDataBufferByte  ; check: min - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; calc offset VIC sprite 0-7 PosX registers
; --------------------------------------------------------------------------------------------------------------------- ;
                            txa                             ; restore sprite number
                            asl a                           ; *2 - gives VIC sprite SPnX offset
                            tax                             ; set sprite number
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteBuffer_Lo           = *                    ; 
                            .byte <LR_SpriteData_00 ; $00
                            .byte <LR_SpriteData_01 ; $40 
                            .byte <LR_SpriteData_02 ; $80 
                            .byte <LR_SpriteData_03 ; $c0 
                            .byte <LR_SpriteData_04 ; $00 
                            .byte <LR_SpriteData_05 ; $40 
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteBuffer_Hi          = *                     ; 
                            .byte >LR_SpriteData_00 ; $0c
                            .byte >LR_SpriteData_01 ; $0c
                            .byte >LR_SpriteData_02 ; $0c
                            .byte >LR_SpriteData_03 ; $0c
                            .byte >LR_SpriteData_04 ; $0d
                            .byte >LR_SpriteData_05 ; $0d
; --------------------------------------------------------------------------------------------------------------------- ;
TabSpriteNumber             = *       ; 
                            .byte $00 ; loderunner
                            
                            .byte $02 ; enemy $01
                            .byte $03 ; enemy $02
                            .byte $04 ; enemy $03
                            
                            .byte $06 ; enemy $04
                            .byte $07 ; enemy $05
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenGetGfxPosXY         Does    : get screen image offset in gfx screen
;                           Expects : .X=col number
;                                   : .Y=row number
;                           Returns : .X=screen image row column offset
;                                   : .Y=screen image row offset
;                           Remark  : game screen size is 40*25
;                                   : LR_ImageWidth will be expanded in ScreenRowByteColNumber and SpriteDisplayHandler
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenGetGfxPosXY          .block                           ; 
                            lda TabScreenRowOff,y           ; get screen image row offset
                            pha                             ; save screen image row offset
                            
                            lda TabScreenColOff,x           ; get screen image row column offset
                            tax                             ; set screen image row column offset
                            
                            pla                             ; restore screen image row offset
                            tay                             ; set screen image row offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabScreenRowOff             = * ; $0b rows per image - screen size is 25*40
                            .byte LR_ImageHeight * $00       ; 01 - $01 - $00
                            .byte LR_ImageHeight * $01       ; 02 - $02 - $0b
                            .byte LR_ImageHeight * $02       ; 03 - $03 - $16
                            .byte LR_ImageHeight * $03       ; 04 - $04 - $21
                            .byte LR_ImageHeight * $04       ; 05 - $05 - $2c
                            .byte LR_ImageHeight * $05       ; 06 - $06 - $37
                            .byte LR_ImageHeight * $06       ; 07 - $07 - $42
                            .byte LR_ImageHeight * $07       ; 08 - $08 - $4d
                            .byte LR_ImageHeight * $08       ; 09 - $09 - $58
                            .byte LR_ImageHeight * $09       ; 00 - $0a - $63
                            .byte LR_ImageHeight * $0a       ; 11 - $0b - $6e
                            .byte LR_ImageHeight * $0b       ; 12 - $0c - $79
                            .byte LR_ImageHeight * $0c       ; 13 - $0d - $84
                            .byte LR_ImageHeight * $0d       ; 14 - $0e - $8f
                            .byte LR_ImageHeight * $0e       ; 15 - $0f - $9a
                            .byte LR_ImageHeight * $0f       ; 16 - $10 - $a5
                            .byte LR_ImageHeight * $10 + $05 ; 17 - $11 - $b5 - status row starts beyond separator line
; --------------------------------------------------------------------------------------------------------------------- ;
TabScreenColOff             = * ; $1c columns per row - force column offset to one byte
                            .byte LR_ImageWidth * $02 / $02  ; 01 - $01 - $0a - 1st two screen columns unused
                            .byte LR_ImageWidth * $03 / $02  ; 02 - $02 - $0f
                            .byte LR_ImageWidth * $04 / $02  ; 03 - $03 - $14
                            .byte LR_ImageWidth * $05 / $02  ; 04 - $04 - $19
                            .byte LR_ImageWidth * $06 / $02  ; 05 - $05 - $1e
                            .byte LR_ImageWidth * $07 / $02  ; 06 - $06 - $23
                            .byte LR_ImageWidth * $08 / $02  ; 07 - $07 - $28
                            .byte LR_ImageWidth * $09 / $02  ; 08 - $08 - $2d
                            .byte LR_ImageWidth * $0a / $02  ; 09 - $09 - $32
                            .byte LR_ImageWidth * $0b / $02  ; 10 - $0a - $37
                            .byte LR_ImageWidth * $0c / $02  ; 11 - $0b - $3c
                            .byte LR_ImageWidth * $0d / $02  ; 12 - $0c - $41
                            .byte LR_ImageWidth * $0e / $02  ; 13 - $0d - $46
                            .byte LR_ImageWidth * $0f / $02  ; 14 - $0e - $4b
                            .byte LR_ImageWidth * $10 / $02  ; 15 - $0f - $50
                            .byte LR_ImageWidth * $11 / $02  ; 16 - $10 - $55
                            .byte LR_ImageWidth * $12 / $02  ; 17 - $11 - $5a
                            .byte LR_ImageWidth * $13 / $02  ; 18 - $12 - $5f
                            .byte LR_ImageWidth * $14 / $02  ; 19 - $13 - $64
                            .byte LR_ImageWidth * $15 / $02  ; 20 - $14 - $69
                            .byte LR_ImageWidth * $16 / $02  ; 21 - $15 - $6e
                            .byte LR_ImageWidth * $17 / $02  ; 22 - $16 - $73
                            .byte LR_ImageWidth * $18 / $02  ; 23 - $17 - $78
                            .byte LR_ImageWidth * $19 / $02  ; 24 - $18 - $7d
                            .byte LR_ImageWidth * $1a / $02  ; 25 - $19 - $82
                            .byte LR_ImageWidth * $1b / $02  ; 26 - $1a - $87
                            .byte LR_ImageWidth * $1c / $02  ; 27 - $1b - $8c
                            .byte LR_ImageWidth * $1d / $02  ; 28 - $1c - $91 - last two screen columns unused
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenAddGfxOnImagePosX   Does    : add horizontal gfx screen image offset
;                           Expects : .X=col number
;                                   : .Y=on image posX number
;                           Returns : .X=vertical position on image
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenAddGfxOnImagePosX    .block                           ; 
                            tya                             ; get on image posX number
                            pha                             ; save on image posX number
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            pla                             ; restore on image posX number
                            tay                             ; set on image posX number
                            
                            txa                             ; get image column offset
                            clc                             ; 
                            adc TabOnGfxImagePosX,y         ; add on image offset value
                            tax                             ; set image column offset
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabOnGfxImagePosX           = *       ; 
                            .byte $fe ; -2
                            .byte $ff ; -1
                            .byte $00 ;  0
                            .byte $01 ; +1
                            .byte $02 ; +2
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenAddGfxOnImagePosY   Does    : add vertical gfx screen image offset
;                           Expects : .Y=row number
;                                   : .X=on image posY number
;                           Returns : .Y=horizontal position on image
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenAddGfxOnImagePosY    .block                           ; 
                            txa                             ; get on image posY number
                            pha                             ; save on image posY number
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            pla                             ; 
                            tax                             ; restore on image posY number
                            
                            tya                             ; get image row offset
                            clc                             ; 
                            adc TabOnGfxImagePosY,x         ; add on image offset value
                            tay                             ; set horizontal position on image
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            

; ------------------------------------------------------------------------------------------------------------- ;
TabOnGfxImagePosY           = *       ; 
                            .byte $fb ; -4
                            .byte $fd ; -2
                            .byte $00 ;  0 - center
                            .byte $02 ; +2
                            .byte $04 ; +4
; ------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; S_8c92                    Does    : get table values - unused subroutine
;                           Expects : .X=table offset
;                           Returns : .A=TabNoUse_LO table value
;                                   : .X=TabNoUse_HI table value
; --------------------------------------------------------------------------------------------------------------------- ;
S_8c92                     .block                           ; 
                            lda TabNoUse_LO,x               ; get TabNoUse_LO value
                            pha                             ; save TabNoUse_LO value
                            
                            lda TabNoUse_HI,x               ; get TabNoUse_HI value
                            tax                             ; set TabNoUse_HI value
                            
                            pla                             ; set TabNoUse_LO value
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabNoUse_LO                 = *       ; 
                            .byte $02 ; $00
                            .byte $03 ; $01
                            
                            .byte $05 ; $02
                            .byte $06 ; $03
                            .byte $07 ; $04
                            .byte $08 ; $05
                            
                            .byte $0a ; $06
                            .byte $0b ; $07
                            .byte $0c ; $08
                            .byte $0d ; $09
                            
                            .byte $0f ; $0a
                            .byte $10 ; $0b
                            .byte $11 ; $0c
                            .byte $12 ; $0d
                            
                            .byte $14 ; $0e
                            .byte $15 ; $0f
                            .byte $16 ; $10
                            .byte $17 ; $11
                            
                            .byte $19 ; $12
                            .byte $1a ; $13
                            .byte $1b ; $14
                            .byte $1c ; $15
                            
                            .byte $1e ; $16
                            .byte $1f ; $17
                            .byte $20 ; $18
                            .byte $21 ; $19
                            
                            .byte $23 ; $1a
                            .byte $24 ; $1b
                            .byte $25 ; $1c
                            .byte $26 ; $1d
; --------------------------------------------------------------------------------------------------------------------- ;
TabNoUse_HI                 = *       ; 
                            .byte $02 ; $00
                            .byte $03 ; $01
                            
                            .byte $00 ; $02
                            .byte $01 ; $03
                            .byte $02 ; $04
                            .byte $03 ; $05
                            
                            .byte $00 ; $06
                            .byte $01 ; $07
                            .byte $02 ; $08
                            .byte $03 ; $09
                            
                            .byte $00 ; $0a
                            .byte $01 ; $0b
                            .byte $02 ; $0c
                            .byte $03 ; $0d
                            
                            .byte $00 ; $0e
                            .byte $01 ; $0f
                            .byte $02 ; $10
                            .byte $03 ; $11
                            
                            .byte $00 ; $12
                            .byte $01 ; $13
                            .byte $02 ; $14
                            .byte $03 ; $15
                            
                            .byte $00 ; $16
                            .byte $01 ; $17
                            .byte $02 ; $18
                            .byte $03 ; $19
                            
                            .byte $00 ; $1a
                            .byte $01 ; $1b
                            .byte $02 ; $1c
                            .byte $03 ; $1d
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenRowByteColNumber    Does    : calculate hires row column byte number
;                           Expects : .X=screen image col offset
;                           Returns : .A=number of bytes to be bypassed
;                                   : .X=rest of (screen image col offset) MOD 4
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenRowByteColNumber     .block                           ; 
                            lda #$00                        ; get initial value
                            sta LR_HiresRowColNumAdd_Hi     ; ini screen start of row column number HI
                            
                            txa                             ; get screen image col offset
                            pha                             ; save screen image col offset
                            
                            and #$03                        ; ......## - .X MOD 4
                            tax                             ; set the rest of division by 4
                            
                            pla                             ; restore screen image col offset
                            
                            asl a                           ; *2 - expand TabScreenColOff value to real width
                            rol LR_HiresRowColNumAdd_Hi     ; screen start of row column number HI
                            and #$f8                        ; #####... - $08 * INT(PosX / $08)
                            sta LR_HiresRowColNumAdd_Lo     ; set screen start of row column number LO
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameSetLevelDataPtrsToRow Does    : set level data pointers to start of selected row
;                           Expects : .Y=row number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameSetLevelDataPtrsToRow  .block                           ; 
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenSetRowPointerStart  Does    : set grafic screen pointer to row start
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetRowPointerStart   .block                           ; 
                            lda #$00                        ; get initial value
                            sta LR_HiresRowColNumAdd_Lo     ; ini screen start of row column number LO
                            sta LR_HiresRowColNumAdd_Hi     ; ini screen start of row column number HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenSetRowPointer       Does    : set grafic screen pointer to the output rows column
;                           Expects : .Y=screen grafic row PosY
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetRowPointer        .block                           ; 
                            lda LR_HiresRowStartPtrTab_Lo,y ; get tab grafic row start pointer LO
                            clc                             ; 
                            adc LR_HiresRowColNumAdd_Lo     ; add screen start of row column number LO
                            sta LRZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            
                            lda LR_HiresRowStartPtrTab_Hi,y ; get tab grafic row start pointer HI
                            adc LR_HiresRowColNumAdd_Hi     ; add screen start of row column number HI
                            ora LRZ_ImageOutputScreen       ; graphic output  (20=2000-2fff  40=4000-4fff)
                            sta LRZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CircleCalcHiresColByteOff Does    : calculate hires screen column byte offset from column number
;                           Expects : .X=column number
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleCalcHiresColByteOff  .block                           ; 
                            lda #$00                        ; get 
                            sta LR_HiresRowColNumAdd_Hi     ; set screen start of row column number HI
                            
                            txa                             ; 
                            asl a                           ; *2
                            asl a                           ; *4
                            asl a                           ; *8
                            rol LR_HiresRowColNumAdd_Hi     ; screen start of row column number HI
                            sta LR_HiresRowColNumAdd_Lo     ; set screen start of row column number LO
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenSetGfxPtrBoth       Does    : set grafic pointers for display an prepare screens
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenSetGfxPtrBoth        .block                           ; 
                            lda LR_HiresRowStartPtrTab_Lo,y ; get tab grafic row start pointer LO
                            clc                             ; 
                            adc LR_HiresRowColNumAdd_Lo     ; add screen start of row column number LO
                            sta LRZ_ScreenRowDisplayPtr_Lo  ; set screen display start of row pointer LO
                            sta LRZ_ScreenRowPreparePtr_Lo  ; set screen prepare start of row pointer LO
                            
                            lda LR_HiresRowStartPtrTab_Hi,y ; get tab grafic row start pointer HI
                            adc LR_HiresRowColNumAdd_Hi     ; add screen start of row column number HI
                            ora #>LR_ScreenGfxDisplay       ; ..#..... - point to $2000-$3fff  (display screen)
                            sta LRZ_ScreenRowDisplayPtr_Hi  ; set screen display start of row pointer LO
                            
                            eor #>(LR_ScreenGfxPrepare + LR_ScreenGfxDisplay) ; .##..... - point to $4000-$5fff  (prepare screen)
                            sta LRZ_ScreenRowPreparePtr_Hi  ; set screen prepare start of row pointer HI
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenDisplayClear        Does    : clear grafic display screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenDisplayClear         .block                           ; 
                            lda #>LR_ScreenGfxDisplay       ; get start hires gfx display screen HI ($2000-$3fff)
                            ldx #SPENA_ALL_OFF              ; get disable all sprites
                            stx SPENA                       ; VIC($D015) Sprite Enable Register
                            
                            ldx #>LR_ScreenGfxDisplayEnd + $01 ; get end hires gfx display screen HI
                            bne ScreenClearSelected         ; always
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenPrepareClear        Does    : clear grafic prepare screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenPrepareClear         .block                           ; 
                            lda #>LR_ScreenGfxPrepare       ; get start hires gfx prepare screen HI ($4000-$5fff)
                            ldx #>LR_ScreenGfxPrepareEnd + $01 ; get end hires gfx prepare screen HI
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;

; ´ ------------------------------------------------------------------------------------------------------------------- ;
; ScreenClearSelected       Does    : clear selected grafic screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
ScreenClearSelected        .block                           ; 
                            sta LRZ_ScreenGfxPtr_Hi         ; set screen grafic HI pointer
                            
                            ldy #$00                        ; get initial value
                            sty LRZ_ScreenGfxPtr_Lo         ; set screen grafic LO pointer
                            
                            tya                             ; get blank
ClrNextGraficScreenByte     sta (LRZ_ScreenGfxPtr),y        ; set screen grafic pointer byte
                            
                            iny                             ; inc byte offset
                            bne ClrNextGraficScreenByte     ; check: min - no: continue
                            
                            inc LRZ_ScreenGfxPtr_Hi         ; set next page
                            
                            cpx LRZ_ScreenGfxPtr_Hi         ; test upper border
                            bne ClrNextGraficScreenByte     ; check: EQ - no: continue
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabLevelDataRow_Lo          = * ; offset start of game/ctrl level data rows LO
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $00)       ; $00 - $0800
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $01)       ; $01 - $081c
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $02)       ; $02 - $0838
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $03)       ; $03 - $0854
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $04)       ; $04 - $0870
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $05)       ; $05 - $088c
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $06)       ; $06 - $08a8
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $07)       ; $07 - $08c4
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $08)       ; $08 - $08e0
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0900
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $091c
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0938
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0954
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0970
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $098c
                            .byte <LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $09a8
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameLevelDataRow_Hi      = * ; offset start of game level data rows pointer $0800-$09c3
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $00)       ; $00 - $0800
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $01)       ; $01 - $081c
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $02)       ; $02 - $0838
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $03)       ; $03 - $0854
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $04)       ; $04 - $0870
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $05)       ; $05 - $088c
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $06)       ; $06 - $08a8
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $07)       ; $07 - $08c4
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $08)       ; $08 - $08e0
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0900
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $091c
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0938
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0954
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0970
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $098c
                            .byte >LR_LevelGameData + ((LR_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $09a8
; --------------------------------------------------------------------------------------------------------------------- ;
TabCtrlLevelDataRow_Hi      = * ; offset start of ctrl level data rows pointer  $0a00-$0bc3
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $00)       ; $00 - $0a00
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $01)       ; $01 - $0a1c
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $02)       ; $02 - $0a38
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $03)       ; $03 - $0a54
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $04)       ; $04 - $0a70
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $05)       ; $05 - $0a8c
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $06)       ; $06 - $0aa8
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $07)       ; $07 - $0ac4
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $08)       ; $08 - $0ae0
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $09) + $04 ; $09 - $0b00
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $0a) + $04 ; $0a - $0b1c
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $0b) + $04 ; $0b - $0b38
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $0c) + $04 ; $0c - $0b54
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $0d) + $04 ; $0d - $0b70
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $0e) + $04 ; $0e - $0b8c
                            .byte >LR_LevelCtrlData + ((LR_ScreenCols_Max + $01) * $0f) + $04 ; $0f - $0ba8
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; LevelExitLadderShow       Does    : show the hidden exit ladders
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
LevelExitLadderShow        .block                           ; 
                            lda #LR_WA_ExitLadderMark_Free  ; get initial value
                            sta LR_WA_ExitLadderMark        ; ini no gold replaced by hidden ladder 
                            
                            ldx LR_ExitLadderCount          ; get number of hidden ladders
                            stx TabWorkExitLadderCount      ; set count of hidden ladders to display
                            
GetNextExitLadderCount      ldx TabWorkExitLadderCount      ; get count hidden ladders to display
                            beq LevelExitLadderShowFinish   ; check: min - yes: finished
                            
                            lda LR_WA_ExitLadderCol,x       ; get adr column hidden ladder tab
                            bmi DecExitLadderCount          ; check: already cleared - yes: try next hidden ladder
                            
                            sta LRZ_ScreenCol               ; set screen col ($00-$1b)
                            
                            lda LR_WA_ExitLadderRow,x       ; get adr row hidden ladders tab
                            sta LRZ_ScreenRow               ; set screen row ($00-$0f)
; --------------------------------------------------------------------------------------------------------------------- ;
; set level game/control data row pointer to hidden ladder row
; --------------------------------------------------------------------------------------------------------------------- ;
                            tay                             ; get row as index
                            lda TabLevelDataRow_Lo,y        ; get expanded level data row pointer LO
                            sta LRZ_LevelDataGamePtrRow_Lo  ; set level game data pointer LO
                            sta LRZ_LevelDataCtrlPtrRow_Lo  ; set level ctrl data pointer LO
                            
                            lda TabGameLevelDataRow_Hi,y    ; get expanded game level data row pointer $0800-$09c3
                            sta LRZ_LevelDataGamePtrRow_Hi  ; set level game data pointer HI
                            
                            lda TabCtrlLevelDataRow_Hi,y    ; get expanded control level data row pointer $0a00-$0bc3
                            sta LRZ_LevelDataCtrlPtrRow_Hi  ; set level ctrl data pointer HI
; --------------------------------------------------------------------------------------------------------------------- ;
; get tile on planned hidden ladder position in level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_ScreenCol               ; get screen col ($00-$1b)
                            lda (LRZ_LevelDataCtrlPtrRow),y ; get play level ctrl data ($0a00-$0bc3)
                            bne MarkDroppedGold             ; check: empty - no: can only be dropped gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set hidden ladder tile to level ctrl data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Ladder          ; get ladder
                            sta (LRZ_LevelDataCtrlPtrRow),y ; set play level ctrl data ($0a00-$0bc3)
; --------------------------------------------------------------------------------------------------------------------- ;
; get tile on planned hidden ladder position in level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda (LRZ_LevelDataGamePtrRow),y ; get unpacked level data ($0800-$09c3)
                            bne UncoverHiddenLadder         ; check: empty - no
; --------------------------------------------------------------------------------------------------------------------- ;
; set hidden ladder tile to level game data
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LR_TileNum_Ladder          ; get ladder
                            sta (LRZ_LevelDataGamePtrRow),y ; set unpacked level data ($0800-$09c3)
; --------------------------------------------------------------------------------------------------------------------- ;
; output ladder tile to grafic screen
; --------------------------------------------------------------------------------------------------------------------- ;
UncoverHiddenLadder         lda #LR_TileNum_Ladder          ; get ladder
                            jsr ScreenImageOutToPrepare     ; direct output to preparation screen
                            
                            ldx LRZ_ScreenCol               ; get screen col ($00-$1b)
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            jsr ScreenGetGfxPosXY           ; screen image offsets in .X=col offset .Y=row offset
                            
                            lda #LR_TileNum_Ladder          ; get ladder
                            jsr ScreenImageOutSpecial       ; show sprites/hidden ladders/shoot sparks/gold/rebirth steps
; --------------------------------------------------------------------------------------------------------------------- ;
; mark hidden ladder WA position as free
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWorkExitLadderCount      ; get count hidden ladders as offset
                            lda #LR_WA_ExitLadder_Free      ; get entry freed marker
                            sta LR_WA_ExitLadderCol,x       ; set clear adr column hidden ladder tab
                            bmi DecExitLadderCount          ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; flag a gold bar was dropped on a hidden ladder position
; --------------------------------------------------------------------------------------------------------------------- ;
MarkDroppedGold             lda #LR_WA_ExitLadderMark_Gold  ; get not empty marker
                            sta LR_WA_ExitLadderMark        ; set flag hidden ladder replaced dropped gold
; --------------------------------------------------------------------------------------------------------------------- ;
; set next iteration
; --------------------------------------------------------------------------------------------------------------------- ;
DecExitLadderCount          dec TabWorkExitLadderCount      ; dec number of hidden ladders
                            jmp GetNextExitLadderCount      ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; check dropped gold marker
; --------------------------------------------------------------------------------------------------------------------- ;
LevelExitLadderShowFinish   lda LR_WA_ExitLadderMark        ; get flag hidden ladder replaced dropped gold
                            bne LevelExitLadderShowX        ; check: dropped gold - no: not set
                            
                            dec LR_GoldToCollect            ; some gold was lost
                            
LevelExitLadderShowX        rts                             ; 
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWorkExitLadderCount      .byte $00                       ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GetNewKey                 Does    : wait for a input key set in IRQ
;                           Expects : 
;                           Returns : .A=key got
; --------------------------------------------------------------------------------------------------------------------- ;
GetNewKey                  .block                           ; 
WaitForNewKey               lda LR_KeyNew                   ; get a new key
                            beq WaitForNewKey               ; check: new gey got - no: continue waiting
                            
                            ldx #LR_KeyNew_None             ; get initial value
                            stx LR_KeyNew                   ; ini new key input
                            
                            rts                             ; 
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; CopyProtectionHandler     Does    : check for original disk in drive
;	                          Parms	  : 
;	                          Returns : filled copy protection value table
;                           Remarks : protected by ChecksumBuild
;                                   : A checksum is calculated from the contents between 
;                                   :     ChecksumBuild_Start and ChecksumBuild_End
;                                   : Any changes here (including the disk data bytes read)
;                                   : result in a bad checksum and a destryed graphic data pointer
;                                   : which makes the game unplayable
; --------------------------------------------------------------------------------------------------------------------- ;
CopyProtectionHandler      .block                           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
ChecksumBuild_Start         =   *                           ; start: checksum build byte block
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #"0"                        ; get track number HI
                            ldy #"2"                        ; get track number LO
                            lda #$00                        ; get offset copy protection value table
                            jsr CopyProtection              ; fill copy protection value table
                            beq CopyProtectionHandlerX      ; check: result EQ "0" - yes
                            
                            ldx #"0"                        ; get track number HI
                            ldy #"1"                        ; get track number LO
                            lda #$01                        ; get offset copy protection value table
                            jsr CopyProtection              ; fill copy protection value table
                            bne CopyProtectionHandlerX      ; check: result EQ "0" - no
                            
                            ldx #"3"                        ; get track number HI
                            ldy #"4"                        ; get track number LO
                            lda #$02                        ; get offset copy protection value table
                            jsr CopyProtection              ; fill copy protection value table
                            beq CopyProtectionHandlerX      ; check: result EQ "0" - yes
                            
                            ldx #"3"                        ; get track number HI
                            ldy #"5"                        ; get track number LO
                            lda #$03                        ; get offset copy protection value table
                            jsr CopyProtection              ; fill copy protection value table
                            
CopyProtectionHandlerX      rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; these two tables must contain the correct disk values otherwise 
; the checksum will be bad and the graphic data pointer will be destroyed
; --------------------------------------------------------------------------------------------------------------------- ;
TabCopyProtValues_01        = *       ; the original contains $08 binary $00 values which must be replaced correctly
                            .text "2" ; .byte $00 ; 
                            .text "0" ; .byte $00 ; 
                            .text "2" ; .byte $00 ; 
                            .text "0" ; .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabCopyProtValues_02        = *       ; otherwise the checksum will be bad and the graphic pointer is faulty
                            .text "3" ; .byte $00 ; 
                            .text "0" ; .byte $00 ; 
                            .text "7" ; .byte $00 ; 
                            .text "0" ; .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; CopyProtection            Does    : read and check copy protection values from selected disk blocks
;                           Expects : .A=offset copy protection value table
;                                   ; .X=track number HI
;                                   ; .Y=track number LO
;                           Returns : .Z=1 - result EQ "0"
;                                   : .Z=0 - result NE "0"
; --------------------------------------------------------------------------------------------------------------------- ;
CopyProtection             .block                           ; 
                            sta LRZ_WorkCopyProtTabOff      ; set offset to copy protection value table
                            stx TabDiskCmdProt_Trk_Hi      ; set track num in disk command
                            sty TabDiskCmdProt_Trk_Lo      ; set track num in disk command
; --------------------------------------------------------------------------------------------------------------------- ;
; set up disk channels
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$00                        ; get no data set name
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            
                            lda #SA_CHANNEL_CMD             ; get command channel number
                            ldx #FA_DISK                    ; get disk number (8)
                            tay                             ; set command channel number
; --------------------------------------------------------------------------------------------------------------------- ;
ChecksumBuild_End           =   *                           ; end: checksum build byte block
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            
                            lda #$01                        ; get name length
                            ldx #<TabDiskCmdProtFileName    ; get adr filename LO (#)
                            ldy #>TabDiskCmdProtFileName    ; get adr filename HI (#)
                            jsr SETNAM                      ; Kernal($FFBD) Set filename parameters ($FDF9)
                            
                            lda #$05                        ; get channel number
                            ldx #FA_DISK                    ; get disk number (8)
                            tay                             ; data channel
                            
                            jsr SETLFS                      ; Kernal($FFBA) Set logical file parameters ($FE00)
                            jsr OPEN                        ; Kernal($FFC0) Open a logical file (via $31A to $F34A)
                            jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #SA_CHANNEL_CMD             ; get command channel number
                            jsr CHKOUT                      ; Kernal($FFC9) Define an output channel (via $320 to $F250)
                            
                            ldy #$00                        ; get ini disk cmd string offset
GetNextDiskCmdChar          lda TabDiskCmdProt,y            ; get disk command string byte
                            beq GetDiskData                 ; check: EoT marker - yes: finished
                            
                            jsr CHROUT                      ; Kernal($FFD2) Output a character (via $326 to $F1CA)
                            
                            iny                             ; inc disk cmd string offset
                            bne GetNextDiskCmdChar          ; always (hopefully)
; --------------------------------------------------------------------------------------------------------------------- ;
; get and store copy protection data
; --------------------------------------------------------------------------------------------------------------------- ;
GetDiskData                 jsr CLRCHN                      ; Kernal($FFCC) Restore default devices (via $322 to $F333)
                            
                            ldx #SA_CHANNEL_CMD             ; get command channnel number
                            jsr CHKIN                       ; Kernal($FFC6) Define an input channel (via $31E to $F20E)
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            ldy LRZ_WorkCopyProtTabOff      ; get table offset
                            sta TabCopyProtValues_01,y      ; set store copy protection value 01
                            
                            jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            sta TabCopyProtValues_02,y      ; set store copy protection value 02
; --------------------------------------------------------------------------------------------------------------------- ;
; discard bytes from drive until CR
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextDiskDataByte         jsr CHRIN                       ; Kernal($FFCF) Input a character (via $324 to $F157)
                            cmp #CR                         ; test <ENTER>
                            bne GetNextDiskDataByte         ; check: EQ - no: continue
                            
                            jsr CLALL                       ; Kernal($FFE7) Close all files (via $32C to $F32F)
; --------------------------------------------------------------------------------------------------------------------- ;
; ChecksumBuild: init build checksum data pointer LO
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #<CopyProtectionHandler     ; protect the copy protection routine from changes
                            sta ChecksumBuild.smCheckSumDataPtr_Lo ; set chcksum data pointer LO
; --------------------------------------------------------------------------------------------------------------------- ;
; check copy protection values
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_WorkCopyProtTabOff      ; get table offset
                            lda TabCopyProtValues_01,y      ; get copy protection value 01
                            ora TabCopyProtValues_02,y      ; insert copy protection value 02
                            cmp #"0"                        ; test copy protection result - set .C
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmdProtFileName      .text "#" ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDiskCmdProt              = *       ; 
                            .text "u" ; user command id
                            .text "1" ; user command type - 1=read
                            .text ":" ; 
                            .text " " ; 
                            .text "5" ; channel number
                            .text " " ; 
                            .text "0" ; drive number
                            .text " " ; 
TabDiskCmdProt_Trk_Hi       .text "0" ; track number HI
TabDiskCmdProt_Trk_Lo       .text "1" ; track number LO
                            .text " " ; 
                            .text "2" ; sector number HI
                            .byte CR  ; <ENTER>
                            
                            .byte $00 ; EndOfText
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSign          Does    : spin game over billboard
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSign           .block                           ; 
                            lda #LR_SpinSignSpeed_Fast      ; get initial value
                            sta TabWrkGameOverSignSpinSpeed ; set init flip sign spin speed
                            
                            lda #>LR_ScreenGfxDisplay       ; get adr gfx display screen HI
                            sta LRZ_ImageOutputScreen       ; set graphic output  ($20=$2000-$2fff  $40=$4000-$4fff)
                            
GameOverSpinSignNextRound   jsr GameOverSpinSignPhase_05    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_00    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_05    ; 
                            
                            jsr GameOverSpinSignPhase_0a    ; 
                            jsr GameOverSpinSignPhase_09    ; 
                            jsr GameOverSpinSignPhase_08    ; 
                            jsr GameOverSpinSignPhase_07    ; 
                            jsr GameOverSpinSignPhase_06    ; 
                            jsr GameOverSpinSignPhase_07    ; 
                            jsr GameOverSpinSignPhase_08    ; 
                            jsr GameOverSpinSignPhase_09    ; 
                            jsr GameOverSpinSignPhase_0a    ; 
                            
                            lda TabWrkGameOverSignSpinSpeed ; get flip sign spin speed
                            cmp #LR_SpinSignSpeed_Slow      ; test slowest
                            bcc GameOverSpinSignNextRound   ; check: lower - yes: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set final phase
; --------------------------------------------------------------------------------------------------------------------- ;
                            jsr GameOverSpinSignPhase_05    ; 
                            jsr GameOverSpinSignPhase_04    ; 
                            jsr GameOverSpinSignPhase_03    ; 
                            jsr GameOverSpinSignPhase_02    ; 
                            jsr GameOverSpinSignPhase_01    ; 
                            jsr GameOverSpinSignPhase_00    ; 
                            
                            clc                             ; 
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_00  Does    : show game over sign spin phase 0
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_00   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
GameOverSpinSignParmTab     = *                             ; spin sign row data number tabele
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_01  ; $01
                            .byte TabGameOverSignRowNum_02  ; $02
                            .byte TabGameOverSignRowNum_03  ; $03
                            .byte TabGameOverSignRowNum_04  ; $04
                            .byte TabGameOverSignRowNum_05  ; $05
                            .byte TabGameOverSignRowNum_06  ; $06
                            .byte TabGameOverSignRowNum_07  ; $07
                            .byte TabGameOverSignRowNum_08  ; $08
                            .byte TabGameOverSignRowNum_09  ; $09
                            .byte TabGameOverSignRowNum_0a  ; $0a
                            .byte TabGameOverSignRowNum_02  ; $0b
                            .byte TabGameOverSignRowNum_01  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
GameOverSpinSignParmTab_Len = * - GameOverSpinSignParmTab   ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_01  Does    : show game over sign spin phase 1
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_01   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_01  ; $02
                            .byte TabGameOverSignRowNum_02  ; $03
                            .byte TabGameOverSignRowNum_03  ; $04
                            .byte TabGameOverSignRowNum_04  ; $05
                            .byte TabGameOverSignRowNum_05  ; $06
                            .byte TabGameOverSignRowNum_07  ; $07
                            .byte TabGameOverSignRowNum_09  ; $08
                            .byte TabGameOverSignRowNum_0a  ; $09
                            .byte TabGameOverSignRowNum_02  ; $0a
                            .byte TabGameOverSignRowNum_01  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_02  Does    : show game over sign spin phase 2
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_02   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_01  ; $03
                            .byte TabGameOverSignRowNum_02  ; $04
                            .byte TabGameOverSignRowNum_03  ; $05
                            .byte TabGameOverSignRowNum_04  ; $06
                            .byte TabGameOverSignRowNum_09  ; $07
                            .byte TabGameOverSignRowNum_0a  ; $08
                            .byte TabGameOverSignRowNum_02  ; $09
                            .byte TabGameOverSignRowNum_01  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_03  Does    : show game over sign spin phase 3
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_03   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_01  ; $04
                            .byte TabGameOverSignRowNum_02  ; $05
                            .byte TabGameOverSignRowNum_03  ; $06
                            .byte TabGameOverSignRowNum_0a  ; $07
                            .byte TabGameOverSignRowNum_02  ; $08
                            .byte TabGameOverSignRowNum_01  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_04  Does    : show game over sign spin phase 4
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_04   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_01  ; $05
                            .byte TabGameOverSignRowNum_03  ; $06
                            .byte TabGameOverSignRowNum_0a  ; $07
                            .byte TabGameOverSignRowNum_01  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_05  Does    : show game over sign spin phase 5
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_05   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_00  ; $05
                            .byte TabGameOverSignRowNum_01  ; $06
                            .byte TabGameOverSignRowNum_01  ; $07
                            .byte TabGameOverSignRowNum_00  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_06  Does    : show game over sign spin phase 6
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_06   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_01  ; $01
                            .byte TabGameOverSignRowNum_02  ; $02
                            .byte TabGameOverSignRowNum_0a  ; $03
                            .byte TabGameOverSignRowNum_09  ; $04
                            .byte TabGameOverSignRowNum_08  ; $05
                            .byte TabGameOverSignRowNum_07  ; $06
                            .byte TabGameOverSignRowNum_06  ; $07
                            .byte TabGameOverSignRowNum_05  ; $08
                            .byte TabGameOverSignRowNum_04  ; $09
                            .byte TabGameOverSignRowNum_03  ; $0a
                            .byte TabGameOverSignRowNum_02  ; $0b
                            .byte TabGameOverSignRowNum_01  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_07  Does    : show game over sign spin phase 7
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_07   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_01  ; $02
                            .byte TabGameOverSignRowNum_02  ; $03
                            .byte TabGameOverSignRowNum_0a  ; $04
                            .byte TabGameOverSignRowNum_09  ; $05
                            .byte TabGameOverSignRowNum_07  ; $06
                            .byte TabGameOverSignRowNum_05  ; $07
                            .byte TabGameOverSignRowNum_04  ; $08
                            .byte TabGameOverSignRowNum_03  ; $09
                            .byte TabGameOverSignRowNum_02  ; $0a
                            .byte TabGameOverSignRowNum_01  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_08  Does    : show game over sign spin phase 8
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_08   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_01  ; $03
                            .byte TabGameOverSignRowNum_02  ; $04
                            .byte TabGameOverSignRowNum_0a  ; $05
                            .byte TabGameOverSignRowNum_09  ; $06
                            .byte TabGameOverSignRowNum_04  ; $07
                            .byte TabGameOverSignRowNum_03  ; $08
                            .byte TabGameOverSignRowNum_02  ; $09
                            .byte TabGameOverSignRowNum_01  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_09  Does    : show game over sign spin phase 9
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_09   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_01  ; $04
                            .byte TabGameOverSignRowNum_02  ; $05
                            .byte TabGameOverSignRowNum_0a  ; $06
                            .byte TabGameOverSignRowNum_03  ; $07
                            .byte TabGameOverSignRowNum_02  ; $08
                            .byte TabGameOverSignRowNum_01  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhase_0a  Does    : show game over sign spin phase 10
;                           Expects : $0d phase numbers must directly follow the subroutine call
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhase_0a   .block                           ; 
                            jsr GameOverSpinSignPhases      ; display the different game over billboard pahases
                            .byte TabGameOverSignRowNum_00  ; $00
                            .byte TabGameOverSignRowNum_00  ; $01
                            .byte TabGameOverSignRowNum_00  ; $02
                            .byte TabGameOverSignRowNum_00  ; $03
                            .byte TabGameOverSignRowNum_00  ; $04
                            .byte TabGameOverSignRowNum_01  ; $05
                            .byte TabGameOverSignRowNum_0a  ; $06
                            .byte TabGameOverSignRowNum_03  ; $07
                            .byte TabGameOverSignRowNum_01  ; $08
                            .byte TabGameOverSignRowNum_00  ; $09
                            .byte TabGameOverSignRowNum_00  ; $0a
                            .byte TabGameOverSignRowNum_00  ; $0b
                            .byte TabGameOverSignRowNum_00  ; $0c
                            .byte TabGameOverSignRowNum_00  ; $0d
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
;                         Row_00  ................................................................................................ 
;                         Row_01  ....#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.#.......
;                         Row_02  ..#.......................................................................................#.....
;                         Row_03  ..#...#.#.#.#...#.#.#...#.#.#.#.#...#.#.#.#.......#.#.#.#...#.#...#...#.#.#.#...#.#.#.#...#.....
;                         Row_04  ..#...#.....#...#...#...#.#.#...#...#.#...........#...#.#...#.#...#...#.#.#.#...#.....#...#.....
;                         Row_05  ..#...#.........#...#...#...#...#...#.#...........#...#.#...#.#...#...#.#.......#.....#...#.....
;                         Row_06  ..#...#.........#...#...#...#...#...#.#.#.#.......#...#.#...#.#...#...#.#.#.....#.#.#.#...#.....
;                         Row_07  ..#...#...#.#...#.#.#...#...#...#...#.#.#.#.......#.....#...#.#...#...#.........#.#.#.....#.....
;                         Row_08  ..#...#.....#...#...#...#...#...#...#.............#.....#...#.#.#.#...#.........#.#.#.....#.....
;                         Row_09  ..#...#.....#...#...#...#...#...#...#.............#.....#.....#.#.....#.........#.#...#...#.....
;                         Row_0a  ..#...#.#.#.#...#...#...#...#...#...#.#.#.#.......#.#.#.#.....#.......#.#.#.#...#.....#...#.....
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverDataSignRow_00   .byte %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000 ; 
TabGameOverDataSignRow_01   .byte %00001010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10101010, %10000000 ; 
TabGameOverDataSignRow_02   .byte %00100000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00100000 ; 
TabGameOverDataSignRow_03   .byte %00100010, %10101000, %10101000, %10101010, %10001010, %10100000, %00101010, %10001010, %00100010, %10101000, %10101010, %00100000 ; 
TabGameOverDataSignRow_04   .byte %00100010, %00001000, %10001000, %10101000, %10001010, %00000000, %00100010, %10001010, %00100010, %10101000, %10000010, %00100000 ; 
TabGameOverDataSignRow_05   .byte %00100010, %00000000, %10001000, %10001000, %10001010, %00000000, %00100010, %10001010, %00100010, %10000000, %10000010, %00100000 ; 
TabGameOverDataSignRow_06   .byte %00100010, %00000000, %10001000, %10001000, %10001010, %10100000, %00100010, %10001010, %00100010, %10100000, %10101010, %00100000 ; 
TabGameOverDataSignRow_07   .byte %00100010, %00101000, %10101000, %10001000, %10001010, %10100000, %00100000, %10001010, %00100010, %00000000, %10101000, %00100000 ; 
TabGameOverDataSignRow_08   .byte %00100010, %00001000, %10001000, %10001000, %10001000, %00000000, %00100000, %10001010, %10100010, %00000000, %10101000, %00100000 ; 
TabGameOverDataSignRow_09   .byte %00100010, %00001000, %10001000, %10001000, %10001000, %00000000, %00100000, %10000010, %10000010, %00000000, %10100010, %00100000 ; 
TabGameOverDataSignRow_0a   .byte %00100010, %10101000, %10001000, %10001000, %10001010, %10100000, %00101010, %10000010, %00000010, %10101000, %10100010, %00100000 ; 
TabGameOverDataSignRow_Len  = * - TabGameOverDataSignRow_0a ; length data of each game over spin sign row
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverDataSignRowAdr   = * ; spin game over sign data address tab
                            .word TabGameOverDataSignRow_00 - TabGameOverDataSignRow_Len - $02 ; $8fd1
                            .word TabGameOverDataSignRow_01 - TabGameOverDataSignRow_Len - $02 ; $8fdd
                            .word TabGameOverDataSignRow_02 - TabGameOverDataSignRow_Len - $02 ; $8fe9
                            .word TabGameOverDataSignRow_03 - TabGameOverDataSignRow_Len - $02 ; $8ff5
                            .word TabGameOverDataSignRow_04 - TabGameOverDataSignRow_Len - $02 ; $9001
                            .word TabGameOverDataSignRow_05 - TabGameOverDataSignRow_Len - $02 ; $900d
                            .word TabGameOverDataSignRow_06 - TabGameOverDataSignRow_Len - $02 ; $9019
                            .word TabGameOverDataSignRow_07 - TabGameOverDataSignRow_Len - $02 ; $9025
                            .word TabGameOverDataSignRow_08 - TabGameOverDataSignRow_Len - $02 ; $9031
                            .word TabGameOverDataSignRow_09 - TabGameOverDataSignRow_Len - $02 ; $903d
                            .word TabGameOverDataSignRow_0a - TabGameOverDataSignRow_Len - $02 ; $9049
; --------------------------------------------------------------------------------------------------------------------- ;
TabGameOverSignRowNum       = * ;                 
TabGameOverSignRowNum_00    = (TabGameOverDataSignRow_00 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_01    = (TabGameOverDataSignRow_01 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_02    = (TabGameOverDataSignRow_02 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_03    = (TabGameOverDataSignRow_03 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_04    = (TabGameOverDataSignRow_04 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_05    = (TabGameOverDataSignRow_05 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_06    = (TabGameOverDataSignRow_06 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_07    = (TabGameOverDataSignRow_07 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_08    = (TabGameOverDataSignRow_08 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_09    = (TabGameOverDataSignRow_09 - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
TabGameOverSignRowNum_0a    = (TabGameOverDataSignRow_0a - TabGameOverDataSignRow_00) / TabGameOverDataSignRow_Len
; --------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignPhases    Does    : display the different game over billboard pahases
;                           Expects : pointer to $0d phase numbers on the stack
;                           Returns : 
;                           Remark  : checks player input to end spinning
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhases     .block                           ; 
                            pla                             ; get start address of data number array LO
                            sta LRZ_SignRowNumberTabPtr_Lo  ; set start address of data number array LO
                            pla                             ; get start address of data number array HI
                            sta LRZ_SignRowNumberTabPtr_Hi  ; set start address of data number array HI
; --------------------------------------------------------------------------------------------------------------------- ;
; init output row
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy #LRZ_ScreenRow_Spin         ; get grafic screen row offset
                            sty LRZ_ScreenRow               ; ini screen row ($00-$0f)
                            bne SetNextGameOverDataPtr      ; always
; --------------------------------------------------------------------------------------------------------------------- ;
; set next game over sign phase
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextSignScreenRow        jsr ScreenSetRowPointerStart    ; set grafic screen pointer to row start
                            
                            ldy #$00                        ; get offset
                            lda (LRZ_SignRowNumberTabPtr),y ; get next sign data number byte
                            asl a                           ; *2 - address length
                            tax                             ; set as table game over data sign row addresses offset
; --------------------------------------------------------------------------------------------------------------------- ;
; each entry is set to TabGameOverDataSignRow_00 - TabGameOverDataSignRow_Len - $02
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda TabGameOverDataSignRowAdr + $00,x ; get flip data address tab LO
                            sta smGetSignDataAdr_Lo         ; set get data address LO
                            
                            lda TabGameOverDataSignRowAdr + $01,x ; get flip data address tab HI
                            sta smGetSignDataAdr_Hi         ; set get data address HI
                            
                            ldy #LRZ_ScreenSpinColOff_Left  ; get grafic screen column offset
                            sty LRZ_ScreenSpinColOff        ; ini gfx screen image column offset
                            
                            ldy #GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len ; get spin sign row number parm table length
                            sty LRZ_WorkGameOverParmTabOff  ; set game over sign parm row number table offset
; --------------------------------------------------------------------------------------------------------------------- ;
; get offset to real address
; --------------------------------------------------------------------------------------------------------------------- ;
GetNextSignParmRowTabOff    ldy LRZ_WorkGameOverParmTabOff  ; get next game over sign parm row number table offset
                            inc LRZ_WorkGameOverParmTabOff  ; inc game over sign parm row number table offset
smGetSignDataAdr_Lo         = * + $01                       ; 
smGetSignDataAdr_Hi         = * + $02                       ; 
GetSignDataByte             lda GetSignDataByte,y           ; get sign data byte
                            lsr a                           ; /2
                            ldy LRZ_ScreenSpinColOff        ; get gfx screen image row offset
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen grafic pointer byte
; --------------------------------------------------------------------------------------------------------------------- ;
; advance output column offset
; --------------------------------------------------------------------------------------------------------------------- ;
                            tya                             ; 
                            clc                             ; 
                            adc #$08                        ; point to next screen column position
                            sta LRZ_ScreenSpinColOff        ; set gfx screen image column offset
; --------------------------------------------------------------------------------------------------------------------- ;
; check game over sign phase completeness
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_WorkGameOverParmTabOff  ; get sign data row length
                            cpy #GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len * $02 - $02 ; test  max
                            bcc GetNextSignParmRowTabOff    ; check: LT - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; set next game over sign phase
; --------------------------------------------------------------------------------------------------------------------- ;
SetNextGameOverDataPtr      jsr GameOverSpinSignIncTabPtr   ; inc pointer to game over sign number table
; --------------------------------------------------------------------------------------------------------------------- ;
; inc game over sign screen row and check game over sign phase completeness
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc LRZ_ScreenRow               ; inc screen row ($00-$0f)
                            
                            ldy LRZ_ScreenRow               ; get screen row ($00-$0f)
                            cpy #LRZ_ScreenRow_Spin + GameOverSpinSignPhase_00.GameOverSpinSignParmTab_Len + $01 ; test max
                            bcc SetNextSignScreenRow        ; check: LT - no: continue with next row
; --------------------------------------------------------------------------------------------------------------------- ;
; handle spin timer
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx TabWrkGameOverSignSpinSpeed ; get flip sign spin speed timer HI value
                            ldy #$ff                        ; ini wait timer LO
DecNextWaitTimerCount       dey                             ; dec wait timer LO
                            bne DecNextWaitTimerCount       ; check: timer LO underrun - no: continue
                            
                            dex                             ; dec wait timer HI
                            bne DecNextWaitTimerCount       ; check: timer HI underrun - no: continue
; --------------------------------------------------------------------------------------------------------------------- ;
; slow down sign rotation speed a bit
; --------------------------------------------------------------------------------------------------------------------- ;
                            inc TabWrkGameOverSignSpinSpeed ; flip sign spin speed so wait longer the next time
; --------------------------------------------------------------------------------------------------------------------- ;
; check player input
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda CIAPRA                      ; CIA1($DC00) Data Port Register A
                            and #CIAPRA_JOY_FIRE            ; isolate the fire button     0=pressed
                            beq GameOverSpinSignPhasesX     ; check: pressed - yes: exir
                            
                            lda LR_KeyNew                   ; get actual key
                            bne GameOverSpinSignPhasesX     ; check: got a new one - yes: exit
                            
                            rts                             ; return to next phase
; --------------------------------------------------------------------------------------------------------------------- ;
; player interrupt ends spinnig - do not return to caller but to GameOver.DemoWaitInit   
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignPhasesX     pla                             ; pull return address from stack
                            pla                             ; 
                            
                            sec                             ; set flag player interrupt
                            rts                             ; 
                           .bend                            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabWrkGameOverSignSpinSpeed .byte $00                       ; save actual game over sign spinning speed
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; GameOverSpinSignIncTabPtr Does    : inc game over sign number table data pointer
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
GameOverSpinSignIncTabPtr  .block                           ; 
                            inc LRZ_SignRowNumberTabPtr_Lo  ; 
                            bne GameOverSpinSignIncTabPtrX  ; check: overflow - no
                            inc LRZ_SignRowNumberTabPtr_Hi  ; 
                            
GameOverSpinSignIncTabPtrX  rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartCycleHandler         Does    : control display of the level start cycle
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StartCycleHandler          .block                           ; 
                            lda LR_CirclePhase              ; get flag start cycle  $ff=LR_CirclePhase_Both
                            beq CircleOpen                  ; check: start cycle open only - yes: omit close on game start
; --------------------------------------------------------------------------------------------------------------------- ;
; init control values
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx #LRZ_CircleRadius_Max       ; get max circle radius
                            stx LRZ_CircleRadius            ; set max circle radius
                            
                            ldx #LRZ_CircleDirection_Close  ; get flag circle direction close
                            stx LRZ_CircleDirection         ; set flag circle direction close
; --------------------------------------------------------------------------------------------------------------------- ;
; close circle
; --------------------------------------------------------------------------------------------------------------------- ;
ExecNextCircleStep_Close    jsr StartCyclePrepare           ; prepare the circle octants output to screen
                            
                            dec LRZ_CircleRadius            ; dec radius
                            bne ExecNextCircleStep_Close    ; check: test min radius - no: continue close
; --------------------------------------------------------------------------------------------------------------------- ;
; circle fully closed - reinit for open
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen                  lda #LRZ_CircleRadius_Min       ; get min circle radius
                            sta LRZ_CircleRadius            ; set min circle radius
                            sta LRZ_CircleDirection         ; set flag circle direction open
                            
                            jsr StatusOutLives              ; write out number of lives
                            jsr StatusOutLevel              ; write out level number
; --------------------------------------------------------------------------------------------------------------------- ;
; open circle
; --------------------------------------------------------------------------------------------------------------------- ;
ExecNextCircleStep_Open     jsr StartCyclePrepare           ; prepare the circle octants output to screen
                            
                            inc LRZ_CircleRadius            ; inc radius
                            
                            lda LRZ_CircleRadius            ; get radius
                            cmp #LRZ_CircleRadius_Max       ; test max radius
                            bne ExecNextCircleStep_Open     ; check: max radius - no: continue open
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartCyclePrepare         Does    : prepare the circle octants output to screen
;                           Expects : 
;                           Returns : 
; --------------------------------------------------------------------------------------------------------------------- ;
StartCyclePrepare          .block                           ; 
                            lda LRZ_CircleRadius            ; get radius
                            sta LRZ_CircleRadiusWork_Lo     ; set work radius LO
                            
                            lda #$00                        ; get inital value
                            sta LRZ_CircleRadiusWork_Hi     ; ini work radius HI
                            sta LRZ_CircleCounter_Lo        ; ini counter HI
                            sta LRZ_CircleCounter_Hi        ; ini counter LO
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate diameter
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_CircleRadiusWork_Lo     ; 
                            asl a                           ; *2
                            sta LRZ_CircleDiameter_Lo       ; 
                            
                            lda LRZ_CircleRadiusWork_Hi     ; 
                            rol a                           ; *2
                            sta LRZ_CircleDiameter_Hi       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$03                        ; 
                            sec                             ; 
                            sbc LRZ_CircleDiameter_Lo       ; 
                            sta LRZ_CircleDiameter_Lo       ; set diameter LO
                            
                            lda #$00                        ; 
                            sbc LRZ_CircleDiameter_Hi       ; 
                            sta LRZ_CircleDiameter_Hi       ; set diameter HI
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate PosY for octants 3 and 4
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_CircleRadiusCenter_PosY; get center PosY
                            sec                             ; 
                            sbc LRZ_CircleRadius            ; 
                            sta LRZ_CirclePosY_Oc34         ; set PosY for circle octant 3 and 4
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate PosY for octants 7 and 8/5 and 6
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_CircleRadiusCenter_PosY; get center PosY
                            sta LRZ_CirclePosY_Oc78         ; set PosY for circle octant 7 and 8
                            sta LRZ_CirclePosY_Oc56         ; set PosY for circle octant 5 and 6
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate PosY for octants 1 and 2
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_CircleRadiusCenter_PosY; get center PosY
                            clc                             ; 
                            adc LRZ_CircleRadius            ; 
                            sta LRZ_CirclePosY_Oc12         ; set PosY for circle octant 1 and 2
; --------------------------------------------------------------------------------------------------------------------- ;
; calculate column numbers and clear table offsets
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_CircleRadiusCenter_PosX; get center PosX
                            sec                             ; 
                            sbc LRZ_CircleRadius            ; 
                            tax                             ; set radius LO
                            
                            lda #$00                        ; ini radius HI
                            sbc #$00                        ; sub .C - set radius HI
                            jsr StartCircleGetColNum        ; 16bit division of circle PosX for colnum and clear table offset
                            
                            sty LRZ_CircleColNum_Oc56       ; set column number for circle octant 5 and 6
                            sta LRZ_CircleClearTabOff_Oc68  ; set clear table offset for circle octant 6 and 8
                            
                            ldx #LRZ_CircleRadiusCenter_PosX; get center PosX
                            lda #$00                        ; get radius HI
                            jsr StartCircleGetColNum        ; 16bit division of circle PosX for colnum and clear table offset
                            
                            sty LRZ_CircleColNum_Oc24       ; set column number for circle octant 2 and 4
                            sty LRZ_CircleColNum_Oc13       ; set column number for circle octant 1 and 3
                            sta LRZ_CircleClearTabOff_Oc24  ; set clear table offset for circle octant 2 and 4
                            sta LRZ_CircleClearTabOff_Oc13  ; set clear table offset for circle octant 1 and 3
                            
                            lda #LRZ_CircleRadiusCenter_PosX; get center PosX
                            clc                             ; 
                            adc LRZ_CircleRadius            ; 
                            tax                             ; set radius LO
                            
                            lda #$00                        ; ini radius HI
                            adc #$00                        ; add .C - set radius HI
                            jsr StartCircleGetColNum        ; 16bit division of circle PosX for colnum and clear table offset
                            
                            sty LRZ_CircleColNum_Oc78       ; set column number for circle octant 7 and 8
                            sta LRZ_CircleClearTabOff_Oc57  ; set clear table offset for circle octant 5 and 7
; --------------------------------------------------------------------------------------------------------------------- ;
; circle prepare control 
; --------------------------------------------------------------------------------------------------------------------- ;
CheckNexCircleCounterHi     lda LRZ_CircleCounter_Hi        ; get counter HI
                            cmp LRZ_CircleRadiusWork_Hi     ; test with work counter HI
                            bcc OutNextOctant               ; check: LT - yes
                            beq CheckNexCircleCounterLo     ; check: EQ - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; check for comple circle round
; --------------------------------------------------------------------------------------------------------------------- ;
CheckFinish                 lda LRZ_CircleCounter_Lo        ; get counter LO
                            cmp LRZ_CircleRadiusWork_Lo     ; test with work counter LO
                            bne StartCyclePrepareX          ; check: EW - no
                            
                            lda LRZ_CircleCounter_Hi        ; get counter HI
                            cmp LRZ_CircleRadiusWork_Hi     ; test with work counter HI
                            bne StartCyclePrepareX          ; check: EQ - no
                            
                            jmp StartCircleShowOctants      ; output open/close phases of the circle octants and exit
; --------------------------------------------------------------------------------------------------------------------- ;
StartCyclePrepareX          rts                             ; exit
; --------------------------------------------------------------------------------------------------------------------- ;
CheckNexCircleCounterLo     lda LRZ_CircleCounter_Lo        ; get counter LO
                            cmp LRZ_CircleRadiusWork_Lo     ; test with work counter LO
                            bcs CheckFinish                 ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
OutNextOctant               jsr StartCircleShowOctants      ; output open/close phases of the circle octants
                            
                            lda LRZ_CircleDiameter_Hi       ; get work counter HI
                            bpl RoundCircleEdges            ; check: min - no
; --------------------------------------------------------------------------------------------------------------------- ;
; multiply by $04
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_CircleCounter_Lo        ; 
                            asl a                           ; *2
                            sta LRZ_CircleStep_Lo           ; 
                            
                            lda LRZ_CircleCounter_Hi        ; 
                            rol a                           ; 
                            sta LRZ_CircleStep_Hi           ; 
                            
                            lda LRZ_CircleStep_Lo           ; 
                            asl a                           ; *4
                            sta LRZ_CircleStep_Lo           ; 
                            
                            lda LRZ_CircleStep_Hi           ; 
                            rol a                           ; 
                            sta LRZ_CircleStep_Hi           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; add diameter
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_CircleDiameter_Lo       ; 
                            clc                             ; 
                            adc LRZ_CircleStep_Lo           ; 
                            sta LRZ_CircleStep_Lo           ; 
                            
                            lda LRZ_CircleDiameter_Hi       ; 
                            adc LRZ_CircleStep_Hi           ; 
                            sta LRZ_CircleStep_Hi           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; add $06
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #$06                        ; 
                            clc                             ; 
                            adc LRZ_CircleStep_Lo           ; 
                            sta LRZ_CircleDiameter_Lo       ; 
                            
                            lda #$00                        ; 
                            adc LRZ_CircleStep_Hi           ; 
                            sta LRZ_CircleDiameter_Hi       ; 
                            
                            jmp IncCircleCounter            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; round edges
; --------------------------------------------------------------------------------------------------------------------- ;
RoundCircleEdges            lda LRZ_CircleCounter_Lo        ; 
                            sec                             ; 
                            sbc LRZ_CircleRadiusWork_Lo     ; 
                            sta LRZ_CircleStep_Lo           ; 
                            
                            lda LRZ_CircleCounter_Hi        ; 
                            sbc LRZ_CircleRadiusWork_Hi     ; 
                            sta LRZ_CircleStep_Hi           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; multiply by $04
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_CircleStep_Lo           ; 
                            asl a                           ; *2
                            sta LRZ_CircleStep_Lo           ; 
                            
                            lda LRZ_CircleStep_Hi           ; 
                            rol a                           ; 
                            sta LRZ_CircleStep_Hi           ; 
                            
                            lda LRZ_CircleStep_Lo           ; 
                            asl a                           ; *4
                            sta LRZ_CircleStep_Lo           ; 
                            
                            lda LRZ_CircleStep_Hi           ; 
                            rol a                           ; 
                            sta LRZ_CircleStep_Hi           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; add $10
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_CircleStep_Lo           ; 
                            clc                             ; 
                            adc #$10                        ; 
                            sta LRZ_CircleStep_Lo           ; 
                            
                            lda LRZ_CircleStep_Hi           ; 
                            adc #$00                        ; add .C
                            sta LRZ_CircleStep_Hi           ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; add to diameter
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_CircleStep_Lo           ; 
                            clc                             ; 
                            adc LRZ_CircleDiameter_Lo       ; 
                            sta LRZ_CircleDiameter_Lo       ; 
                            
                            lda LRZ_CircleStep_Hi           ; 
                            adc LRZ_CircleDiameter_Hi       ; 
                            sta LRZ_CircleDiameter_Hi       ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; correct radius work
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda LRZ_CircleRadiusWork_Lo     ; get radius LO
                            php                             ; push processor status - save flags
                            dec LRZ_CircleRadiusWork_Lo     ; dec radius LO
                            plp                             ; pull processor status - restore flags
                            bne IncCirclePosY_Oc34          ; check: overflow - no
                            dec LRZ_CircleRadiusWork_Hi     ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; 
; --------------------------------------------------------------------------------------------------------------------- ;
IncCirclePosY_Oc34          inc LRZ_CirclePosY_Oc34         ; inc PosY for circle octant 3 and 4
; --------------------------------------------------------------------------------------------------------------------- ;
; advance circle clear table offsets
; --------------------------------------------------------------------------------------------------------------------- ;
DecCircleClearTabOff_Oc57   dec LRZ_CircleClearTabOff_Oc57  ; dec clear table offset for circle octant 5 and 7
                            bpl IncCircleClearTabOff_Oc68   ; check: min - no
; --------------------------------------------------------------------------------------------------------------------- ;
; reinit circle clear table offset for octant 5 and 7
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_CircleClearTabOff_Max - $01 ; get initial value
                            sta LRZ_CircleClearTabOff_Oc57  ; ini clear table offset for circle octant 5 and 7
                            
                            dec LRZ_CircleColNum_Oc78       ; dec column number for circle octant 7 and 8
; --------------------------------------------------------------------------------------------------------------------- ;
IncCircleClearTabOff_Oc68   inc LRZ_CircleClearTabOff_Oc68  ; inc clear table offset for circle octant 6 and 8
                            
                            lda LRZ_CircleClearTabOff_Oc68  ; get clear table offset for circle octant 6 and 8
                            cmp #LRZ_CircleClearTabOff_Max  ; test beyond max
                            bne DecCirclePosY_Oc12          ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; reinit circle clear table offset for octant 6 and 8
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_CircleClearTabOff_Min  ; get initial value
                            sta LRZ_CircleClearTabOff_Oc68  ; ini clear table offset for circle octant 6 and 8
                            
                            inc LRZ_CircleColNum_Oc56       ; inc column number for circle octant 5 and 6
; --------------------------------------------------------------------------------------------------------------------- ;
DecCirclePosY_Oc12          dec LRZ_CirclePosY_Oc12         ; dec PosY for circle octant 1 and 2
; --------------------------------------------------------------------------------------------------------------------- ;
; inc counter
; --------------------------------------------------------------------------------------------------------------------- ;
IncCircleCounter            inc LRZ_CircleCounter_Lo        ; 
                            bne IncCircleClearTabOff_Oc13   ; check: overflow - no
                            inc LRZ_CircleCounter_Hi        ; 
; --------------------------------------------------------------------------------------------------------------------- ;
IncCircleClearTabOff_Oc13   inc LRZ_CircleClearTabOff_Oc13  ; inc clear table offset for circle octant 1 and 3
                            
                            lda LRZ_CircleClearTabOff_Oc13  ; get clear table offset for circle octant 1 and 3
                            cmp #LRZ_CircleClearTabOff_Max  ; test beyond max
                            bne DecCirclePosY_Oc78          ; check: EQ - no
; --------------------------------------------------------------------------------------------------------------------- ;
; reinit circle clear table offset for octant 1 and 3
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #LRZ_CircleClearTabOff_Min  ; get initial value
                            sta LRZ_CircleClearTabOff_Oc13  ; ini clear table offset for circle octant 1 and 3
                            
                            inc LRZ_CircleColNum_Oc13       ; inc column number for circle octant 1 and 3
; --------------------------------------------------------------------------------------------------------------------- ;
DecCirclePosY_Oc78          dec LRZ_CirclePosY_Oc78         ; dec PosY for circle octant 7 and 8
                            inc LRZ_CirclePosY_Oc56         ; inc PosY for circle octant 5 and 6
; --------------------------------------------------------------------------------------------------------------------- ;
DecCircleClearTabOff_Oc24   dec LRZ_CircleClearTabOff_Oc24  ; dec clear table offset for circle octant 2 and 4
                            bpl GoCheckNexCircleCounterHi   ; check: min - no
; --------------------------------------------------------------------------------------------------------------------- ;
; reinit circle clear table offset for octant 2 and 4
; --------------------------------------------------------------------------------------------------------------------- ;
                            lda #TabCircleTileClear_Len     ; get inital value
                            sta LRZ_CircleClearTabOff_Oc24  ; ini clear table offset for circle octant 2 and 4
                            
                            dec LRZ_CircleColNum_Oc24       ; dec column number for circle octant 2 and 4
                            
GoCheckNexCircleCounterHi   jmp CheckNexCircleCounterHi     ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartCircleGetColNum      Does    : 16bit division of circle PosX for colnum and clear table offset
;                           Expects : .A=circle PosX HI
;                                   : .X=circle PosX LO
;                           Returns : .A=offset circle tile clear table
;                                   : .X=circle PosX LO
;                                   : .Y=column number
; --------------------------------------------------------------------------------------------------------------------- ;
StartCircleGetColNum       .block                           ; 
                            sta LRZ_WorkCircleColNum        ; set circle PosX HI
                            
                            txa                             ; get circle PosX LO
                            and #TabCircleTileClear_Len     ; .X-int(.X/8)*8 - rest of division .X/8
                            pha                             ; save offset circle tile clear table
                            
                            tay                             ; <obsolete> - set .N.Z flags but not .C
                            
                            txa                             ; circle PosX LO
                            ror LRZ_WorkCircleColNum        ; circle PosX HI - /2
                            ror a                           ; circle PosX LO
                            ror LRZ_WorkCircleColNum        ; circle PosX HI - /4
                            ror a                           ; circle PosX LO
                            ror LRZ_WorkCircleColNum        ; circle PosX HI - /8
                            ror a                           ; 
                            tay                             ; column number 
                            
                            pla                             ; restore offset circle tile clear table
                            
                            rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; ´ ------------------------------------------------------------------------------------------------------------------- ;
; StartCircleShowOctants    Does    : output open/close phases of the circle octants
;                           Expects : 
;                           Returns : 
;                           Remark  : the circle octants are numbered the following way
;                                   : 
;                                   :                  N 
;                                   :             _____|_____         
;                                   :            /  4  | 3   \ 
;                                   :           +.     |    . +
;                                   :          / 8 ' . |. '  7 \
;                                   :     W --.--------+--------.-- E
;                                   :          \ 6 . ' |'  . 5 /
;                                   :           +'  2  | 1   '+
;                                   :            \_____|_____/
;                                   :                  |                  
;                                   :                  S
; --------------------------------------------------------------------------------------------------------------------- ;
StartCircleShowOctants     .block                           ; 
CircleOctants_01_02         ldy LRZ_CirclePosY_Oc12         ; get PosY for circle octant 1 and 2
                            cpy #LRZ_CirclePosY_Max         ; test max PosY reached - circle bottom
                            bcs CircleOctants_03_04         ; check: GE circle bottom - yes: finished
                            
                            ldx LRZ_CircleColNum_Oc13       ; get column number for circle octant 1 and 3
                            cpx #LRZ_CircleColNum_Max       ; test max
                            bcs CircleCheck_Oc02            ; check: GE - yes
                            
                            jsr CircleCalcHiresColByteOff   ; calculate hires screen column byte offset from column number
; --------------------------------------------------------------------------------------------------------------------- ;
; open/close circle octant 01 --> S-SO
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_CircleClearTabOff_Oc13  ; get clear table offset for circle octant 1 and 3
                            ldy #$00                        ; get screen offset
                            
                            lda LRZ_CircleDirection         ; get flag circle direction
                            bne CircleOpen_Oc01             ; check: direction open - yes
                            
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display data for close circle
                            and TabCircleTileClearClose,x   ; clear screen display data for close circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for close circle
                            
                            jmp CircleCheck_Oc02            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen_Oc01             lda (LRZ_ScreenRowPreparePtr),y ; get screen prepare data for open circle
                            and TabCircleTileClearOpen,x    ; clear screen prepare data for open circle
                            ora (LRZ_ScreenGfxDisplayPtr),y ; overlay screen display data for open circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for open circle
; --------------------------------------------------------------------------------------------------------------------- ;
CircleCheck_Oc02            ldx LRZ_CircleColNum_Oc24       ; get column number for circle octant 2 and 4
                            cpx #LRZ_CircleColNum_Max       ; test max
                            bcs CircleOctants_03_04         ; check: GE - yes
; --------------------------------------------------------------------------------------------------------------------- ;
; open/close circle octant 02 --> S-SW
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldy LRZ_CirclePosY_Oc12         ; get PosY for circle octant 1 and 2
                            jsr CircleCalcHiresColByteOff   ; calculate hires screen column byte offset from column number
                            
                            ldx LRZ_CircleClearTabOff_Oc24  ; get clear table offset for circle octant 2 and 4
                            ldy #$00                        ; get screen offset 
                            
                            lda LRZ_CircleDirection         ; get flag circle direction
                            bne CircleOpen_Oc02             ; check: direction open - yes
                            
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display data for close circle
                            and TabCircleTileClearClose,x   ; clear screen display data for close circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for close circle
                            
                            jmp CircleOctants_03_04         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen_Oc02             lda (LRZ_ScreenRowPreparePtr),y ; get screen prepare data for open circle
                            and TabCircleTileClearOpen,x    ; clear screen prepare data for open circle
                            ora (LRZ_ScreenGfxDisplayPtr),y ; overlay screen display data for open circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for open circle
; --------------------------------------------------------------------------------------------------------------------- ;
; handle octants 3 and 4
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOctants_03_04         ldy LRZ_CirclePosY_Oc34         ; get PosY for circle octant 3 and 4
                            cpy #LRZ_CirclePosY_Max         ; test max PosY reached - circle center
                            bcs CircleOctants_05_06         ; check: GE circle center - yes: finished
                            
                            ldx LRZ_CircleColNum_Oc13       ; get column number for circle octant 1 and 3
                            cpx #LRZ_CircleColNum_Max       ; test max
                            bcs CircleCheck_Oc04            ; check: GE - yes
                            
                            jsr CircleCalcHiresColByteOff   ; calculate hires screen column byte offset from column number
; --------------------------------------------------------------------------------------------------------------------- ;
; open/close circle octant 03 --> N-NO
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_CircleClearTabOff_Oc13  ; get clear table offset for circle octant 1 and 3
                            ldy #$00                        ; get get screen offset
                            
                            lda LRZ_CircleDirection         ; get flag circle direction
                            bne CircleOpen_Oc03             ; check: direction open - yes
                            
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display data for close circle
                            and TabCircleTileClearClose,x   ; clear screen display data for close circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for close circle
                            
                            jmp CircleCheck_Oc04            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen_Oc03             lda (LRZ_ScreenRowPreparePtr),y ; get screen prepare data for open circle
                            and TabCircleTileClearOpen,x    ; clear screen prepare data for open circle
                            ora (LRZ_ScreenGfxDisplayPtr),y ; overlay screen display data for open circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for open circle
                            
CircleCheck_Oc04            ldx LRZ_CircleColNum_Oc24       ; get column number for circle octant 2 and 4
                            cpx #LRZ_CircleColNum_Max       ; test max
                            bcs CircleOctants_05_06         ; check: GE - yes
                            
                            ldy LRZ_CirclePosY_Oc34         ; get PosY for circle octant 3 and 4
                            jsr CircleCalcHiresColByteOff   ; calculate hires screen column byte offset from column number
; --------------------------------------------------------------------------------------------------------------------- ;
; open/close circle octant 04 --> N-NW
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_CircleClearTabOff_Oc24  ; get clear table offset for circle octant 2 and 4
                            ldy #$00                        ; get screen offset 
                            
                            lda LRZ_CircleDirection         ; get flag circle direction
                            bne CircleOpen_Oc04             ; check: direction open - yes
                            
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display data for close circle
                            and TabCircleTileClearClose,x   ; clear screen display data for close circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for close circle
                            
                            jmp CircleOctants_05_06         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen_Oc04             lda (LRZ_ScreenRowPreparePtr),y ; get screen prepare data for open circle
                            and TabCircleTileClearOpen,x    ; clear screen prepare data for open circle
                            ora (LRZ_ScreenGfxDisplayPtr),y ; overlay screen display data for open circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for open circle
; --------------------------------------------------------------------------------------------------------------------- ;
; handle octants 5 and 6
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOctants_05_06         ldy LRZ_CirclePosY_Oc56         ; get PosY for circle octant 5 and 6
                            cpy #LRZ_CirclePosY_Max         ; test max PosY
                            bcs CircleOctants_07_08         ; check: GE max PosY - yes: finished
                            
                            ldx LRZ_CircleColNum_Oc78       ; get column number for circle octant 7 and 8
                            cpx #LRZ_CircleColNum_Max       ; test max
                            bcs CircleCheck_Oc06            ; check: GE - yes
                            
                            jsr CircleCalcHiresColByteOff   ; calculate hires screen column byte offset from column number
; --------------------------------------------------------------------------------------------------------------------- ;
; open/close circle octant 05 --> O-SO
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_CircleClearTabOff_Oc57  ; get clear table offset for circle octant 5 and 7
                            ldy #$00                        ; get screen offset 
                            
                            lda LRZ_CircleDirection         ; get flag circle direction
                            bne CircleOpen_Oc05             ; check: direction open - yes
                            
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display data for close circle
                            and TabCircleTileClearClose,x   ; clear screen display data for close circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for close circle
                            
                            jmp CircleCheck_Oc06            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen_Oc05             lda (LRZ_ScreenRowPreparePtr),y ; get screen prepare data for open circle
                            and TabCircleTileClearOpen,x    ; clear screen prepare data for open circle
                            ora (LRZ_ScreenGfxDisplayPtr),y ; overlay screen display data for open circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for open circle
                            
CircleCheck_Oc06            ldx LRZ_CircleColNum_Oc56       ; get column number for circle octant 5 and 6
                            cpx #LRZ_CircleColNum_Max       ; test max
                            bcs CircleOctants_07_08         ; check: GE - yes
                            
                            ldy LRZ_CirclePosY_Oc56         ; get PosY for circle octant 5 and 6
                            jsr CircleCalcHiresColByteOff   ; calculate hires screen column byte offset from column number
; --------------------------------------------------------------------------------------------------------------------- ;
; open/close circle octant 06 --> W-SW
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_CircleClearTabOff_Oc68  ; get clear table offset for circle octant 6 and 8
                            ldy #$00                        ; get screen offset 
                            
                            lda LRZ_CircleDirection         ; get flag circle direction
                            bne CircleOpen_Oc06             ; check: direction open - yes
                            
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display data for close circle
                            and TabCircleTileClearClose,x   ; clear screen display data for close circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for close circle
                            
                            jmp CircleOctants_07_08         ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen_Oc06             lda (LRZ_ScreenRowPreparePtr),y ; get screen prepare data for open circle
                            and TabCircleTileClearOpen,x    ; clear screen prepare data for open circle
                            ora (LRZ_ScreenGfxDisplayPtr),y ; overlay screen display data for open circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for open circle
; --------------------------------------------------------------------------------------------------------------------- ;
; handle octants 7 and 8
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOctants_07_08         ldy LRZ_CirclePosY_Oc78         ; get PosY for circle octant 7 and 8
                            cpy #LRZ_CirclePosY_Max         ; test max PosY
                            bcs StartCircleShowOctantsX     ; check: GE max PosY - yes: finished
                            
                            ldx LRZ_CircleColNum_Oc78       ; get column number for circle octant 7 and 8
                            cpx #LRZ_CircleColNum_Max       ; test max
                            bcs CircleCheck_Oc08            ; check: GE - yes
                            
                            jsr CircleCalcHiresColByteOff   ; calculate hires screen column byte offset from column number
; --------------------------------------------------------------------------------------------------------------------- ;
; open/close circle octant 07 --> NO-O
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_CircleClearTabOff_Oc57  ; get clear table offset for circle octant 5 and 7
                            ldy #$00                        ; get screen offset 
                            
                            lda LRZ_CircleDirection         ; get flag circle direction
                            bne CircleOpen_Oc07             ; check: direction open - yes
                            
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display data for close circle
                            and TabCircleTileClearClose,x   ; clear screen display data for close circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for close circle
                            
                            jmp CircleCheck_Oc08            ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen_Oc07             lda (LRZ_ScreenRowPreparePtr),y ; get screen prepare data for open circle
                            and TabCircleTileClearOpen,x    ; clear screen prepare data for open circle
                            ora (LRZ_ScreenGfxDisplayPtr),y ; overlay screen display data for open circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for open circle
                            
CircleCheck_Oc08            ldx LRZ_CircleColNum_Oc56       ; get column number for circle octant 5 and 6
                            cpx #LRZ_CircleColNum_Max       ; test max
                            bcs StartCircleShowOctantsX     ; check: GE - yes
                            
                            ldy LRZ_CirclePosY_Oc78         ; get PosY for circle octant 7 and 8
                            jsr CircleCalcHiresColByteOff   ; calculate hires screen column byte offset from column number
; --------------------------------------------------------------------------------------------------------------------- ;
; open/close circle octant 08 --> N-NW
; --------------------------------------------------------------------------------------------------------------------- ;
                            ldx LRZ_CircleClearTabOff_Oc68  ; get clear table offset for circle octant 6 and 8
                            ldy #$00                        ; get screen offset 
                            
                            lda LRZ_CircleDirection         ; get flag circle direction
                            bne CircleOpen_Oc08             ; check: direction open - yes
                            
                            lda (LRZ_ScreenGfxDisplayPtr),y ; get screen display data for close circle
                            and TabCircleTileClearClose,x   ; clear screen display data for close circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for close circle
                            
                            rts                             ; 
; --------------------------------------------------------------------------------------------------------------------- ;
CircleOpen_Oc08             lda (LRZ_ScreenRowPreparePtr),y ; get screen prepare data for open circle
                            and TabCircleTileClearOpen,x    ; clear screen prepare data for open circle
                            ora (LRZ_ScreenGfxDisplayPtr),y ; overlay screen display data for open circle
                            sta (LRZ_ScreenGfxDisplayPtr),y ; set screen display data for open circle
                            
StartCircleShowOctantsX     rts                             ; 
                           .bend                            ; 
; ` ------------------------------------------------------------------------------------------------------------------- ;
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabCircleTileClearClose     = *       ; 
                            .byte $0f ; ....####
                            .byte $0f ; ....####
                            .byte $0f ; ....####
                            .byte $0f ; ....####
; --------------------------------------------------------------------------------------------------------------------- ;
TabCircleTileClearOpen       = *       ; 
                            .byte $f0 ; ####....
                            .byte $f0 ; ####....
                            .byte $f0 ; ####....
                            .byte $f0 ; ####....
TabCircleTileClear_Len      = * - TabCircleTileClearClose - $01 ; open/close table contains all entries in opposite order
; --------------------------------------------------------------------------------------------------------------------- ;
                            .byte $0f ; ....####
                            .byte $0f ; ....####
                            .byte $0f ; ....####
                            .byte $0f ; ....####
; --------------------------------------------------------------------------------------------------------------------- ;
                            
GarbageArea_02              .include "..\inc\LR_Garbage_02.asm" ; old memory remnants - not referenced
                            
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleMaxNum             .byte TabJingleDataPtr_Len ; 
TabJingleHeight_Min         .byte $02 ; 
TabJingleHeight_Max         .byte $0c ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleDataPtr            = *       ; 
TabJingleDataPtr_Lo         = * + $00 ;
TabJingleDataPtr_Hi         = * + $01 ;
                            .word TabJingleData_00 ; $00
                            .word TabJingleData_01 ; $01
                            .word TabJingleData_02 ; $02
                            .word TabJingleData_03 ; $03
                            .word TabJingleData_04 ; $04
                            .word TabJingleData_05 ; $05
                            .word TabJingleData_06 ; $06
                            .word TabJingleData_07 ; $07
                            .word TabJingleData_08 ; $08
                            .word TabJingleData_09 ; $09
TabJingleDataPtr_Len        = (* - TabJingleDataPtr) / 2 - 1
; --------------------------------------------------------------------------------------------------------------------- ;
                            .word TabJingleData_0a ; $0a - empty: not used
                            .word TabJingleData_0a ; $0a - empty: not used
                            .word TabJingleData_0a ; $0a - empty: not used
                            .word TabJingleData_0a ; $0a - empty: not used
                            .word TabJingleData_0a ; $0a - empty: not used
; --------------------------------------------------------------------------------------------------------------------- ;
TabFreqCtrlData_Lo          = *       ; 
                            .byte $00 ; 
                            .byte $e1 ; 
                            .byte $68 ; 
                            .byte $f7 ; 
                            .byte $8f ; 
                            .byte $30 ; 
                            .byte $da ; 
                            .byte $8f ; 
                            .byte $4e ; 
                            .byte $18 ; 
                            .byte $ef ; 
                            .byte $d2 ; 
                            .byte $c3 ; 
                            .byte $c3 ; 
                            .byte $d1 ; 
                            .byte $ef ; 
                            .byte $1f ; 
                            .byte $60 ; 
                            .byte $b5 ; 
                            .byte $1e ; 
                            .byte $9c ; 
                            .byte $31 ; 
                            .byte $df ; 
                            .byte $a5 ; 
                            .byte $87 ; 
                            .byte $86 ; 
                            .byte $a2 ; 
                            .byte $df ; 
                            .byte $3e ; 
                            .byte $c1 ; 
                            .byte $6b ; 
                            .byte $3c ; 
                            .byte $39 ; 
                            .byte $63 ; 
                            .byte $be ; 
                            .byte $4b ; 
                            .byte $0f ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabFreqCtrlData_Hi          = *       ; 
                            .byte $00 ; 
                            .byte $08 ; 
                            .byte $09 ; 
                            .byte $09 ; 
                            .byte $0a ; 
                            .byte $0b ; 
                            .byte $0b ; 
                            .byte $0c ; 
                            .byte $0d ; 
                            .byte $0e ; 
                            .byte $0e ; 
                            .byte $0f ; 
                            .byte $10 ; 
                            .byte $11 ; 
                            .byte $12 ; 
                            .byte $13 ; 
                            .byte $15 ; 
                            .byte $16 ; 
                            .byte $17 ; 
                            .byte $19 ; 
                            .byte $1a ; 
                            .byte $1c ; 
                            .byte $1d ; 
                            .byte $1f ; 
                            .byte $21 ; 
                            .byte $23 ; 
                            .byte $25 ; 
                            .byte $27 ; 
                            .byte $2a ; 
                            .byte $2c ; 
                            .byte $2f ; 
                            .byte $32 ; 
                            .byte $35 ; 
                            .byte $38 ; 
                            .byte $3b ; 
                            .byte $3f ; 
                            .byte $43 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_09            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
TabJingleDataBlock_Len      = * - TabJingleData_09
                            
                            .byte $08 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_05            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                             
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $c0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0f ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $14 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0f ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_02            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                             
                            .byte $05 ; playtime
                            .byte $02 ; tune voice2
                            .byte $1c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $04 ; tune voice2
                            .byte $17 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $05 ; tune voice2
                            .byte $15 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $07 ; tune voice2
                            .byte $13 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $09 ; tune voice2
                            .byte $11 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $0b ; tune voice2
                            .byte $10 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $0c ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0b ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $11 ; tune voice2
                            .byte $09 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $13 ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $15 ; tune voice2
                            .byte $05 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $17 ; tune voice2
                            .byte $04 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $1c ; tune voice2
                            .byte $02 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_06            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                             
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $c0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $06 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $08 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $17 ; tune voice2
                            .byte $11 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $10 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_08            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                             
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol

                            .byte $03 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol

                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $01 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $0b ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $05 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $03 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_03            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $07 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $50 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_00            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $10 ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $13 ; tune voice2
                            .byte $10 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $11 ; tune voice2
                            .byte $0e ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $11 ; tune voice2
                            .byte $0e ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $90 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $10 ; tune voice2
                            .byte $0c ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $06 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $b0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $90 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $70 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $60 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $50 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $40 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $30 ; su/re/vol
                            
                            .byte $08 ; playtime
                            .byte $0e ; tune voice2
                            .byte $07 ; tune voice3
                            .byte $20 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_04            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_07            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $17 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $16 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $14 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0f ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0e ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0d ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $0c ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_01            = *       ; 
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $10 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $18 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $11 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $0c ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                             
                            .byte $04 ; playtime
                            .byte $1f ; tune voice2
                            .byte $0f ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $12 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $1f ; tune voice2
                            .byte $0f ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $15 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $17 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $d0 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $04 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $a0 ; su/re/vol
                            
                            .byte $02 ; playtime
                            .byte $13 ; tune voice2
                            .byte $ff ; tune voice3
                            .byte $80 ; su/re/vol
                            
                            .byte $10 ; playtime
                            .byte $00 ; tune voice2
                            .byte $00 ; tune voice3
                            .byte $00 ; su/re/vol
                            
                            .byte $00 ; end of Jingle marker
; --------------------------------------------------------------------------------------------------------------------- ;
TabJingleData_0a            = *       ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;

GarbageArea_01              .include "..\inc\LR_Garbage_01.asm" ; whole area same as $693e-$6fff and not referenced
                            
; --------------------------------------------------------------------------------------------------------------------- ;
; 2 columns of image data for each of the 4 possible image x-positions - accessed by TabImageDataOff
; --------------------------------------------------------------------------------------------------------------------- ;
; image row byte 1 - from $a000/$a200/$a400/$a600 - At TabImageDataOff_Len
; image row byte 2 - from $a100/$a300/$a500/$a700 - At TabImageDataOff_Len       - part 1 - combined with part 2
;                  - from $a000/$a200/$a400/$a600 - At TabImageDataOff_Len * $02 - part 2
; image row byte 3 - from $a100/$a300/$a500/$a700 - At TabImageDataOff_Len * $02
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageData                = *       ; 
TabImageDataPos_01_Part_01  = *       ; $a000    $a100      $a200    $a300      $a400    $a500      $a600    $a700   
                            .byte $00 ; ........ ........   ........ ........   ........ ........   ........ ........
                            .byte $01 ; .......# ........   ........ .#......   ........ ...#....   ........ .....#..
                            .byte $02 ; ......#. ........   ........ #.......   ........ ..#.....   ........ ....#...
                            .byte $03 ; ......## ........   ........ ##......   ........ ..##....   ........ ....##..
                            .byte $04 ; .....#.. ........   .......# ........   ........ .#......   ........ ...#....
                            .byte $05 ; .....#.# ........   .......# .#......   ........ .#.#....   ........ ...#.#..
                            .byte $06 ; .....##. ........   .......# #.......   ........ .##.....   ........ ...##...
                            .byte $07 ; .....### ........   .......# ##......   ........ .###....   ........ ...###..
                            .byte $08 ; ....#... ........   ......#. ........   ........ #.......   ........ ..#.....
                            .byte $09 ; ....#..# ........   ......#. .#......   ........ #..#....   ........ ..#..#..
                            .byte $0a ; ....#.#. ........   ......#. #.......   ........ #.#.....   ........ ..#.#...
                            .byte $0b ; ....#.## ........   ......#. ##......   ........ #.##....   ........ ..#.##..
                            .byte $0c ; ....##.. ........   ......## ........   ........ ##......   ........ ..##....
                            .byte $0d ; ....##.# ........   ......## .#......   ........ ##.#....   ........ ..##.#..
                            .byte $0e ; ....###. ........   ......## #.......   ........ ###.....   ........ ..###...
                            .byte $0f ; ....#### ........   ......## ##......   ........ ####....   ........ ..####..
                            .byte $10 ; ...#.... ........   .....#.. ........   .......# ........   ........ .#......
                            .byte $11 ; ...#...# ........   .....#.. .#......   .......# ...#....   ........ .#...#..
                            .byte $12 ; ...#..#. ........   .....#.. #.......   .......# ..#.....   ........ .#..#...
                            .byte $13 ; ...#..## ........   .....#.. ##......   .......# ..##....   ........ .#..##..
                            .byte $14 ; ...#.#.. ........   .....#.# ........   .......# .#......   ........ .#.#....
                            .byte $15 ; ...#.#.# ........   .....#.# .#......   .......# .#.#....   ........ .#.#.#..
                            .byte $16 ; ...#.##. ........   .....#.# #.......   .......# .##.....   ........ .#.##...
                            .byte $17 ; ...#.### ........   .....#.# ##......   .......# .###....   ........ .#.###..
                            .byte $18 ; ...##... ........   .....##. ........   .......# #.......   ........ .##.....
                            .byte $19 ; ...##..# ........   .....##. .#......   .......# #..#....   ........ .##..#..
                            .byte $1a ; ...##.#. ........   .....##. #.......   .......# #.#.....   ........ .##.#...
                            .byte $1b ; ...##.## ........   .....##. ##......   .......# #.##....   ........ .##.##..
                            .byte $1c ; ...###.. ........   .....### ........   .......# ##......   ........ .###....
                            .byte $1d ; ...###.# ........   .....### .#......   .......# ##.#....   ........ .###.#..
                            .byte $1e ; ...####. ........   .....### #.......   .......# ###.....   ........ .####...
                            .byte $1f ; ...##### ........   .....### ##......   .......# ####....   ........ .#####..
                            .byte $20 ; ..#..... ........   ....#... ........   ......#. ........   ........ #.......
                            .byte $21 ; ..#....# ........   ....#... .#......   ......#. ...#....   ........ #....#..
                            .byte $22 ; ..#...#. ........   ....#... #.......   ......#. ..#.....   ........ #...#...
                            .byte $23 ; ..#...## ........   ....#... ##......   ......#. ..##....   ........ #...##..
                            .byte $24 ; ..#..#.. ........   ....#..# ........   ......#. .#......   ........ #..#....
                            .byte $25 ; ..#..#.# ........   ....#..# .#......   ......#. .#.#....   ........ #..#.#..
                            .byte $26 ; ..#..##. ........   ....#..# #.......   ......#. .##.....   ........ #..##...
                            .byte $27 ; ..#..### ........   ....#..# ##......   ......#. .###....   ........ #..###..
                            .byte $28 ; ..#.#... ........   ....#.#. ........   ......#. #.......   ........ #.#.....
                            .byte $29 ; ..#.#..# ........   ....#.#. .#......   ......#. #..#....   ........ #.#..#..
                            .byte $2a ; ..#.#.#. ........   ....#.#. #.......   ......#. #.#.....   ........ #.#.#...
                            .byte $2b ; ..#.#.## ........   ....#.#. ##......   ......#. #.##....   ........ #.#.##..
                            .byte $2c ; ..#.##.. ........   ....#.## ........   ......#. ##......   ........ #.##....
                            .byte $2d ; ..#.##.# ........   ....#.## .#......   ......#. ##.#....   ........ #.##.#..
                            .byte $2e ; ..#.###. ........   ....#.## #.......   ......#. ###.....   ........ #.###...
                            .byte $2f ; ..#.#### ........   ....#.## ##......   ......#. ####....   ........ #.####..
                            .byte $30 ; ..##.... ........   ....##.. ........   ......## ........   ........ ##......
                            .byte $31 ; ..##...# ........   ....##.. .#......   ......## ...#....   ........ ##...#..
                            .byte $32 ; ..##..#. ........   ....##.. #.......   ......## ..#.....   ........ ##..#...
                            .byte $33 ; ..##..## ........   ....##.. ##......   ......## ..##....   ........ ##..##..
                            .byte $34 ; ..##.#.. ........   ....##.# ........   ......## .#......   ........ ##.#....
                            .byte $35 ; ..##.#.# ........   ....##.# .#......   ......## .#.#....   ........ ##.#.#..
                            .byte $36 ; ..##.##. ........   ....##.# #.......   ......## .##.....   ........ ##.##...
                            .byte $37 ; ..##.### ........   ....##.# ##......   ......## .###....   ........ ##.###..
                            .byte $38 ; ..###... ........   ....###. ........   ......## #.......   ........ ###.....
                            .byte $39 ; ..###..# ........   ....###. .#......   ......## #..#....   ........ ###..#..
                            .byte $3a ; ..###.#. ........   ....###. #.......   ......## #.#.....   ........ ###.#...
                            .byte $3b ; ..###.## ........   ....###. ##......   ......## #.##....   ........ ###.##..
                            .byte $3c ; ..####.. ........   ....#### ........   ......## ##......   ........ ####....
                            .byte $3d ; ..####.# ........   ....#### .#......   ......## ##.#....   ........ ####.#..
                            .byte $3e ; ..#####. ........   ....#### #.......   ......## ###.....   ........ #####...
                            .byte $3f ; ..###### ........   ....#### ##......   ......## ####....   ........ ######..
                            .byte $40 ; .#...... ........   ...#.... ........   .....#.. ........   .......# ........
                            .byte $41 ; .#.....# ........   ...#.... .#......   .....#.. ...#....   .......# .....#..
                            .byte $42 ; .#....#. ........   ...#.... #.......   .....#.. ..#.....   .......# ....#...
                            .byte $43 ; .#....## ........   ...#.... ##......   .....#.. ..##....   .......# ....##..
                            .byte $44 ; .#...#.. ........   ...#...# ........   .....#.. .#......   .......# ...#....
                            .byte $45 ; .#...#.# ........   ...#...# .#......   .....#.. .#.#....   .......# ...#.#..
                            .byte $46 ; .#...##. ........   ...#...# #.......   .....#.. .##.....   .......# ...##...
                            .byte $47 ; .#...### ........   ...#...# ##......   .....#.. .###....   .......# ...###..
                            .byte $48 ; .#..#... ........   ...#..#. ........   .....#.. #.......   .......# ..#.....
                            .byte $49 ; .#..#..# ........   ...#..#. .#......   .....#.. #..#....   .......# ..#..#..
                            .byte $4a ; .#..#.#. ........   ...#..#. #.......   .....#.. #.#.....   .......# ..#.#...
                            .byte $4b ; .#..#.## ........   ...#..#. ##......   .....#.. #.##....   .......# ..#.##..
                            .byte $4c ; .#..##.. ........   ...#..## ........   .....#.. ##......   .......# ..##....
                            .byte $4d ; .#..##.# ........   ...#..## .#......   .....#.. ##.#....   .......# ..##.#..
                            .byte $4e ; .#..###. ........   ...#..## #.......   .....#.. ###.....   .......# ..###...
                            .byte $4f ; .#..#### ........   ...#..## ##......   .....#.. ####....   .......# ..####..
                            .byte $50 ; .#.#.... ........   ...#.#.. ........   .....#.# ........   .......# .#......
                            .byte $51 ; .#.#...# ........   ...#.#.. .#......   .....#.# ...#....   .......# .#...#..
                            .byte $52 ; .#.#..#. ........   ...#.#.. #.......   .....#.# ..#.....   .......# .#..#...
                            .byte $53 ; .#.#..## ........   ...#.#.. ##......   .....#.# ..##....   .......# .#..##..
                            .byte $54 ; .#.#.#.. ........   ...#.#.# ........   .....#.# .#......   .......# .#.#....
                            .byte $55 ; .#.#.#.# ........   ...#.#.# .#......   .....#.# .#.#....   .......# .#.#.#..
                            .byte $56 ; .#.#.##. ........   ...#.#.# #.......   .....#.# .##.....   .......# .#.##...
                            .byte $57 ; .#.#.### ........   ...#.#.# ##......   .....#.# .###....   .......# .#.###..
                            .byte $58 ; .#.##... ........   ...#.##. ........   .....#.# #.......   .......# .##.....
                            .byte $59 ; .#.##..# ........   ...#.##. .#......   .....#.# #..#....   .......# .##..#..
                            .byte $5a ; .#.##.#. ........   ...#.##. #.......   .....#.# #.#.....   .......# .##.#...
                            .byte $5b ; .#.##.## ........   ...#.##. ##......   .....#.# #.##....   .......# .##.##..
                            .byte $5c ; .#.###.. ........   ...#.### ........   .....#.# ##......   .......# .###....
                            .byte $5d ; .#.###.# ........   ...#.### .#......   .....#.# ##.#....   .......# .###.#..
                            .byte $5e ; .#.####. ........   ...#.### #.......   .....#.# ###.....   .......# .####...
                            .byte $5f ; .#.##### ........   ...#.### ##......   .....#.# ####....   .......# .#####..
                            .byte $60 ; .##..... ........   ...##... ........   .....##. ........   .......# #.......
                            .byte $61 ; .##....# ........   ...##... .#......   .....##. ...#....   .......# #....#..
                            .byte $62 ; .##...#. ........   ...##... #.......   .....##. ..#.....   .......# #...#...
                            .byte $63 ; .##...## ........   ...##... ##......   .....##. ..##....   .......# #...##..
                            .byte $64 ; .##..#.. ........   ...##..# ........   .....##. .#......   .......# #..#....
                            .byte $65 ; .##..#.# ........   ...##..# .#......   .....##. .#.#....   .......# #..#.#..
                            .byte $66 ; .##..##. ........   ...##..# #.......   .....##. .##.....   .......# #..##...
                            .byte $67 ; .##..### ........   ...##..# ##......   .....##. .###....   .......# #..###..
                            .byte $68 ; .##.#... ........   ...##.#. ........   .....##. #.......   .......# #.#.....
                            .byte $69 ; .##.#..# ........   ...##.#. .#......   .....##. #..#....   .......# #.#..#..
                            .byte $6a ; .##.#.#. ........   ...##.#. #.......   .....##. #.#.....   .......# #.#.#...
                            .byte $6b ; .##.#.## ........   ...##.#. ##......   .....##. #.##....   .......# #.#.##..
                            .byte $6c ; .##.##.. ........   ...##.## ........   .....##. ##......   .......# #.##....
                            .byte $6d ; .##.##.# ........   ...##.## .#......   .....##. ##.#....   .......# #.##.#..
                            .byte $6e ; .##.###. ........   ...##.## #.......   .....##. ###.....   .......# #.###...
                            .byte $6f ; .##.#### ........   ...##.## ##......   .....##. ####....   .......# #.####..
                            .byte $70 ; .###.... ........   ...###.. ........   .....### ........   .......# ##......
                            .byte $71 ; .###...# ........   ...###.. .#......   .....### ...#....   .......# ##...#..
                            .byte $72 ; .###..#. ........   ...###.. #.......   .....### ..#.....   .......# ##..#...
                            .byte $73 ; .###..## ........   ...###.. ##......   .....### ..##....   .......# ##..##..
                            .byte $74 ; .###.#.. ........   ...###.# ........   .....### .#......   .......# ##.#....
                            .byte $75 ; .###.#.# ........   ...###.# .#......   .....### .#.#....   .......# ##.#.#..
                            .byte $76 ; .###.##. ........   ...###.# #.......   .....### .##.....   .......# ##.##...
                            .byte $77 ; .###.### ........   ...###.# ##......   .....### .###....   .......# ##.###..
                            .byte $78 ; .####... ........   ...####. ........   .....### #.......   .......# ###.....
                            .byte $79 ; .####..# ........   ...####. .#......   .....### #..#....   .......# ###..#..
                            .byte $7a ; .####.#. ........   ...####. #.......   .....### #.#.....   .......# ###.#...
                            .byte $7b ; .####.## ........   ...####. ##......   .....### #.##....   .......# ###.##..
                            .byte $7c ; .#####.. ........   ...##### ........   .....### ##......   .......# ####....
                            .byte $7d ; .#####.# ........   ...##### .#......   .....### ##.#....   .......# ####.#..
                            .byte $7e ; .######. ........   ...##### #.......   .....### ###.....   .......# #####...
                            .byte $7f ; .####### ........   ...##### ##......   .....### ####....   .......# ######..
                            .byte $80 ; #....... ........   ..#..... ........   ....#... ........   ......#. ........
                            .byte $81 ; #......# ........   ..#..... .#......   ....#... ...#....   ......#. .....#..
                            .byte $82 ; #.....#. ........   ..#..... #.......   ....#... ..#.....   ......#. ....#...
                            .byte $83 ; #.....## ........   ..#..... ##......   ....#... ..##....   ......#. ....##..
                            .byte $84 ; #....#.. ........   ..#....# ........   ....#... .#......   ......#. ...#....
                            .byte $85 ; #....#.# ........   ..#....# .#......   ....#... .#.#....   ......#. ...#.#..
                            .byte $86 ; #....##. ........   ..#....# #.......   ....#... .##.....   ......#. ...##...
                            .byte $87 ; #....### ........   ..#....# ##......   ....#... .###....   ......#. ...###..
                            .byte $88 ; #...#... ........   ..#...#. ........   ....#... #.......   ......#. ..#.....
                            .byte $89 ; #...#..# ........   ..#...#. .#......   ....#... #..#....   ......#. ..#..#..
                            .byte $8a ; #...#.#. ........   ..#...#. #.......   ....#... #.#.....   ......#. ..#.#...
                            .byte $8b ; #...#.## ........   ..#...#. ##......   ....#... #.##....   ......#. ..#.##..
                            .byte $8c ; #...##.. ........   ..#...## ........   ....#... ##......   ......#. ..##....
                            .byte $8d ; #...##.# ........   ..#...## .#......   ....#... ##.#....   ......#. ..##.#..
                            .byte $8e ; #...###. ........   ..#...## #.......   ....#... ###.....   ......#. ..###...
                            .byte $8f ; #...#### ........   ..#...## ##......   ....#... ####....   ......#. ..####..
                            .byte $90 ; #..#.... ........   ..#..#.. ........   ....#..# ........   ......#. .#......
                            .byte $91 ; #..#...# ........   ..#..#.. .#......   ....#..# ...#....   ......#. .#...#..
                            .byte $92 ; #..#..#. ........   ..#..#.. #.......   ....#..# ..#.....   ......#. .#..#...
                            .byte $93 ; #..#..## ........   ..#..#.. ##......   ....#..# ..##....   ......#. .#..##..
                            .byte $94 ; #..#.#.. ........   ..#..#.# ........   ....#..# .#......   ......#. .#.#....
                            .byte $95 ; #..#.#.# ........   ..#..#.# .#......   ....#..# .#.#....   ......#. .#.#.#..
                            .byte $96 ; #..#.##. ........   ..#..#.# #.......   ....#..# .##.....   ......#. .#.##...
                            .byte $97 ; #..#.### ........   ..#..#.# ##......   ....#..# .###....   ......#. .#.###..
                            .byte $98 ; #..##... ........   ..#..##. ........   ....#..# #.......   ......#. .##.....
                            .byte $99 ; #..##..# ........   ..#..##. .#......   ....#..# #..#....   ......#. .##..#..
                            .byte $9a ; #..##.#. ........   ..#..##. #.......   ....#..# #.#.....   ......#. .##.#...
                            .byte $9b ; #..##.## ........   ..#..##. ##......   ....#..# #.##....   ......#. .##.##..
                            .byte $9c ; #..###.. ........   ..#..### ........   ....#..# ##......   ......#. .###....
                            .byte $9d ; #..###.# ........   ..#..### .#......   ....#..# ##.#....   ......#. .###.#..
                            .byte $9e ; #..####. ........   ..#..### #.......   ....#..# ###.....   ......#. .####...
                            .byte $9f ; #..##### ........   ..#..### ##......   ....#..# ####....   ......#. .#####..
                            .byte $a0 ; #.#..... ........   ..#.#... ........   ....#.#. ........   ......#. #.......
                            .byte $a1 ; #.#....# ........   ..#.#... .#......   ....#.#. ...#....   ......#. #....#..
                            .byte $a2 ; #.#...#. ........   ..#.#... #.......   ....#.#. ..#.....   ......#. #...#...
                            .byte $a3 ; #.#...## ........   ..#.#... ##......   ....#.#. ..##....   ......#. #...##..
                            .byte $a4 ; #.#..#.. ........   ..#.#..# ........   ....#.#. .#......   ......#. #..#....
                            .byte $a5 ; #.#..#.# ........   ..#.#..# .#......   ....#.#. .#.#....   ......#. #..#.#..
                            .byte $a6 ; #.#..##. ........   ..#.#..# #.......   ....#.#. .##.....   ......#. #..##...
                            .byte $a7 ; #.#..### ........   ..#.#..# ##......   ....#.#. .###....   ......#. #..###..
                            .byte $a8 ; #.#.#... ........   ..#.#.#. ........   ....#.#. #.......   ......#. #.#.....
                            .byte $a9 ; #.#.#..# ........   ..#.#.#. .#......   ....#.#. #..#....   ......#. #.#..#..
                            .byte $aa ; #.#.#.#. ........   ..#.#.#. #.......   ....#.#. #.#.....   ......#. #.#.#...
                            .byte $ab ; #.#.#.## ........   ..#.#.#. ##......   ....#.#. #.##....   ......#. #.#.##..
                            .byte $ac ; #.#.##.. ........   ..#.#.## ........   ....#.#. ##......   ......#. #.##....
                            .byte $ad ; #.#.##.# ........   ..#.#.## .#......   ....#.#. ##.#....   ......#. #.##.#..
                            .byte $ae ; #.#.###. ........   ..#.#.## #.......   ....#.#. ###.....   ......#. #.###...
                            .byte $af ; #.#.#### ........   ..#.#.## ##......   ....#.#. ####....   ......#. #.####..
                            .byte $b0 ; #.##.... ........   ..#.##.. ........   ....#.## ........   ......#. ##......
                            .byte $b1 ; #.##...# ........   ..#.##.. .#......   ....#.## ...#....   ......#. ##...#..
                            .byte $b2 ; #.##..#. ........   ..#.##.. #.......   ....#.## ..#.....   ......#. ##..#...
                            .byte $b3 ; #.##..## ........   ..#.##.. ##......   ....#.## ..##....   ......#. ##..##..
                            .byte $b4 ; #.##.#.. ........   ..#.##.# ........   ....#.## .#......   ......#. ##.#....
                            .byte $b5 ; #.##.#.# ........   ..#.##.# .#......   ....#.## .#.#....   ......#. ##.#.#..
                            .byte $b6 ; #.##.##. ........   ..#.##.# #.......   ....#.## .##.....   ......#. ##.##...
                            .byte $b7 ; #.##.### ........   ..#.##.# ##......   ....#.## .###....   ......#. ##.###..
                            .byte $b8 ; #.###... ........   ..#.###. ........   ....#.## #.......   ......#. ###.....
                            .byte $b9 ; #.###..# ........   ..#.###. .#......   ....#.## #..#....   ......#. ###..#..
                            .byte $ba ; #.###.#. ........   ..#.###. #.......   ....#.## #.#.....   ......#. ###.#...
                            .byte $bb ; #.###.## ........   ..#.###. ##......   ....#.## #.##....   ......#. ###.##..
                            .byte $bc ; #.####.. ........   ..#.#### ........   ....#.## ##......   ......#. ####....
                            .byte $bd ; #.####.# ........   ..#.#### .#......   ....#.## ##.#....   ......#. ####.#..
                            .byte $be ; #.#####. ........   ..#.#### #.......   ....#.## ###.....   ......#. #####...
                            .byte $bf ; #.###### ........   ..#.#### ##......   ....#.## ####....   ......#. ######..
                            .byte $c0 ; ##...... ........   ..##.... ........   ....##.. ........   ......## ........
                            .byte $c1 ; ##.....# ........   ..##.... .#......   ....##.. ...#....   ......## .....#..
                            .byte $c2 ; ##....#. ........   ..##.... #.......   ....##.. ..#.....   ......## ....#...
                            .byte $c3 ; ##....## ........   ..##.... ##......   ....##.. ..##....   ......## ....##..
                            .byte $c4 ; ##...#.. ........   ..##...# ........   ....##.. .#......   ......## ...#....
                            .byte $c5 ; ##...#.# ........   ..##...# .#......   ....##.. .#.#....   ......## ...#.#..
                            .byte $c6 ; ##...##. ........   ..##...# #.......   ....##.. .##.....   ......## ...##...
                            .byte $c7 ; ##...### ........   ..##...# ##......   ....##.. .###....   ......## ...###..
                            .byte $c8 ; ##..#... ........   ..##..#. ........   ....##.. #.......   ......## ..#.....
                            .byte $c9 ; ##..#..# ........   ..##..#. .#......   ....##.. #..#....   ......## ..#..#..
                            .byte $ca ; ##..#.#. ........   ..##..#. #.......   ....##.. #.#.....   ......## ..#.#...
                            .byte $cb ; ##..#.## ........   ..##..#. ##......   ....##.. #.##....   ......## ..#.##..
                            .byte $cc ; ##..##.. ........   ..##..## ........   ....##.. ##......   ......## ..##....
                            .byte $cd ; ##..##.# ........   ..##..## .#......   ....##.. ##.#....   ......## ..##.#..
                            .byte $ce ; ##..###. ........   ..##..## #.......   ....##.. ###.....   ......## ..###...
                            .byte $cf ; ##..#### ........   ..##..## ##......   ....##.. ####....   ......## ..####..
                            .byte $d0 ; ##.#.... ........   ..##.#.. ........   ....##.# ........   ......## .#......
                            .byte $d1 ; ##.#...# ........   ..##.#.. .#......   ....##.# ...#....   ......## .#...#..
                            .byte $d2 ; ##.#..#. ........   ..##.#.. #.......   ....##.# ..#.....   ......## .#..#...
                            .byte $d3 ; ##.#..## ........   ..##.#.. ##......   ....##.# ..##....   ......## .#..##..
                            .byte $d4 ; ##.#.#.. ........   ..##.#.# ........   ....##.# .#......   ......## .#.#....
                            .byte $d5 ; ##.#.#.# ........   ..##.#.# .#......   ....##.# .#.#....   ......## .#.#.#..
                            .byte $d6 ; ##.#.##. ........   ..##.#.# #.......   ....##.# .##.....   ......## .#.##...
                            .byte $d7 ; ##.#.### ........   ..##.#.# ##......   ....##.# .###....   ......## .#.###..
                            .byte $d8 ; ##.##... ........   ..##.##. ........   ....##.# #.......   ......## .##.....
                            .byte $d9 ; ##.##..# ........   ..##.##. .#......   ....##.# #..#....   ......## .##..#..
                            .byte $da ; ##.##.#. ........   ..##.##. #.......   ....##.# #.#.....   ......## .##.#...
                            .byte $db ; ##.##.## ........   ..##.##. ##......   ....##.# #.##....   ......## .##.##..
                            .byte $dc ; ##.###.. ........   ..##.### ........   ....##.# ##......   ......## .###....
                            .byte $dd ; ##.###.# ........   ..##.### .#......   ....##.# ##.#....   ......## .###.#..
                            .byte $de ; ##.####. ........   ..##.### #.......   ....##.# ###.....   ......## .####...
                            .byte $df ; ##.##### ........   ..##.### ##......   ....##.# ####....   ......## .#####..
                            .byte $e0 ; ###..... ........   ..###... ........   ....###. ........   ......## #.......
                            .byte $e1 ; ###....# ........   ..###... .#......   ....###. ...#....   ......## #....#..
                            .byte $e2 ; ###...#. ........   ..###... #.......   ....###. ..#.....   ......## #...#...
                            .byte $e3 ; ###...## ........   ..###... ##......   ....###. ..##....   ......## #...##..
                            .byte $e4 ; ###..#.. ........   ..###..# ........   ....###. .#......   ......## #..#....
                            .byte $e5 ; ###..#.# ........   ..###..# .#......   ....###. .#.#....   ......## #..#.#..
                            .byte $e6 ; ###..##. ........   ..###..# #.......   ....###. .##.....   ......## #..##...
                            .byte $e7 ; ###..### ........   ..###..# ##......   ....###. .###....   ......## #..###..
                            .byte $e8 ; ###.#... ........   ..###.#. ........   ....###. #.......   ......## #.#.....
                            .byte $e9 ; ###.#..# ........   ..###.#. .#......   ....###. #..#....   ......## #.#..#..
                            .byte $ea ; ###.#.#. ........   ..###.#. #.......   ....###. #.#.....   ......## #.#.#...
                            .byte $eb ; ###.#.## ........   ..###.#. ##......   ....###. #.##....   ......## #.#.##..
                            .byte $ec ; ###.##.. ........   ..###.## ........   ....###. ##......   ......## #.##....
                            .byte $ed ; ###.##.# ........   ..###.## .#......   ....###. ##.#....   ......## #.##.#..
                            .byte $ee ; ###.###. ........   ..###.## #.......   ....###. ###.....   ......## #.###...
                            .byte $ef ; ###.#### ........   ..###.## ##......   ....###. ####....   ......## #.####..
                            .byte $f0 ; ####.... ........   ..####.. ........   ....#### ........   ......## ##......
                            .byte $f1 ; ####...# ........   ..####.. .#......   ....#### ...#....   ......## ##...#..
                            .byte $f2 ; ####..#. ........   ..####.. #.......   ....#### ..#.....   ......## ##..#...
                            .byte $f3 ; ####..## ........   ..####.. ##......   ....#### ..##....   ......## ##..##..
                            .byte $f4 ; ####.#.. ........   ..####.# ........   ....#### .#......   ......## ##.#....
                            .byte $f5 ; ####.#.# ........   ..####.# .#......   ....#### .#.#....   ......## ##.#.#..
                            .byte $f6 ; ####.##. ........   ..####.# #.......   ....#### .##.....   ......## ##.##...
                            .byte $f7 ; ####.### ........   ..####.# ##......   ....#### .###....   ......## ##.###..
                            .byte $f8 ; #####... ........   ..#####. ........   ....#### #.......   ......## ###.....
                            .byte $f9 ; #####..# ........   ..#####. .#......   ....#### #..#....   ......## ###..#..
                            .byte $fa ; #####.#. ........   ..#####. #.......   ....#### #.#.....   ......## ###.#...
                            .byte $fb ; #####.## ........   ..#####. ##......   ....#### #.##....   ......## ###.##..
                            .byte $fc ; ######.. ........   ..###### ........   ....#### ##......   ......## ####....
                            .byte $fd ; ######.# ........   ..###### .#......   ....#### ##.#....   ......## ####.#..
                            .byte $fe ; #######. ........   ..###### #.......   ....#### ###.....   ......## #####...
                            .byte $ff ; ######## ........   ..###### ##......   ....#### ####....   ......## ######..
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_01_Part_02  = *       ; 
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
                            .byte $00 ; ........
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_02_Part_01  = *       ; 
                            .byte $00 ; ........  ........
                            .byte $00 ; ........  .#......
                            .byte $00 ; ........  #.......
                            .byte $00 ; ........  ##......
                            .byte $01 ; .......#  ........
                            .byte $01 ; .......#  .#......
                            .byte $01 ; .......#  #.......
                            .byte $01 ; .......#  ##......
                            .byte $02 ; ......#.  ........
                            .byte $02 ; ......#.  .#......
                            .byte $02 ; ......#.  #.......
                            .byte $02 ; ......#.  ##......
                            .byte $03 ; ......##  ........
                            .byte $03 ; ......##  .#......
                            .byte $03 ; ......##  #.......
                            .byte $03 ; ......##  ##......
                            .byte $04 ; .....#..  ........
                            .byte $04 ; .....#..  .#......
                            .byte $04 ; .....#..  #.......
                            .byte $04 ; .....#..  ##......
                            .byte $05 ; .....#.#  ........
                            .byte $05 ; .....#.#  .#......
                            .byte $05 ; .....#.#  #.......
                            .byte $05 ; .....#.#  ##......
                            .byte $06 ; .....##.  ........
                            .byte $06 ; .....##.  .#......
                            .byte $06 ; .....##.  #.......
                            .byte $06 ; .....##.  ##......
                            .byte $07 ; .....###  ........
                            .byte $07 ; .....###  .#......
                            .byte $07 ; .....###  #.......
                            .byte $07 ; .....###  ##......
                            .byte $08 ; ....#...  ........
                            .byte $08 ; ....#...  .#......
                            .byte $08 ; ....#...  #.......
                            .byte $08 ; ....#...  ##......
                            .byte $09 ; ....#..#  ........
                            .byte $09 ; ....#..#  .#......
                            .byte $09 ; ....#..#  #.......
                            .byte $09 ; ....#..#  ##......
                            .byte $0a ; ....#.#.  ........
                            .byte $0a ; ....#.#.  .#......
                            .byte $0a ; ....#.#.  #.......
                            .byte $0a ; ....#.#.  ##......
                            .byte $0b ; ....#.##  ........
                            .byte $0b ; ....#.##  .#......
                            .byte $0b ; ....#.##  #.......
                            .byte $0b ; ....#.##  ##......
                            .byte $0c ; ....##..  ........
                            .byte $0c ; ....##..  .#......
                            .byte $0c ; ....##..  #.......
                            .byte $0c ; ....##..  ##......
                            .byte $0d ; ....##.#  ........
                            .byte $0d ; ....##.#  .#......
                            .byte $0d ; ....##.#  #.......
                            .byte $0d ; ....##.#  ##......
                            .byte $0e ; ....###.  ........
                            .byte $0e ; ....###.  .#......
                            .byte $0e ; ....###.  #.......
                            .byte $0e ; ....###.  ##......
                            .byte $0f ; ....####  ........
                            .byte $0f ; ....####  .#......
                            .byte $0f ; ....####  #.......
                            .byte $0f ; ....####  ##......
                            .byte $10 ; ...#....  ........
                            .byte $10 ; ...#....  .#......
                            .byte $10 ; ...#....  #.......
                            .byte $10 ; ...#....  ##......
                            .byte $11 ; ...#...#  ........
                            .byte $11 ; ...#...#  .#......
                            .byte $11 ; ...#...#  #.......
                            .byte $11 ; ...#...#  ##......
                            .byte $12 ; ...#..#.  ........
                            .byte $12 ; ...#..#.  .#......
                            .byte $12 ; ...#..#.  #.......
                            .byte $12 ; ...#..#.  ##......
                            .byte $13 ; ...#..##  ........
                            .byte $13 ; ...#..##  .#......
                            .byte $13 ; ...#..##  #.......
                            .byte $13 ; ...#..##  ##......
                            .byte $14 ; ...#.#..  ........
                            .byte $14 ; ...#.#..  .#......
                            .byte $14 ; ...#.#..  #.......
                            .byte $14 ; ...#.#..  ##......
                            .byte $15 ; ...#.#.#  ........
                            .byte $15 ; ...#.#.#  .#......
                            .byte $15 ; ...#.#.#  #.......
                            .byte $15 ; ...#.#.#  ##......
                            .byte $16 ; ...#.##.  ........
                            .byte $16 ; ...#.##.  .#......
                            .byte $16 ; ...#.##.  #.......
                            .byte $16 ; ...#.##.  ##......
                            .byte $17 ; ...#.###  ........
                            .byte $17 ; ...#.###  .#......
                            .byte $17 ; ...#.###  #.......
                            .byte $17 ; ...#.###  ##......
                            .byte $18 ; ...##...  ........
                            .byte $18 ; ...##...  .#......
                            .byte $18 ; ...##...  #.......
                            .byte $18 ; ...##...  ##......
                            .byte $19 ; ...##..#  ........
                            .byte $19 ; ...##..#  .#......
                            .byte $19 ; ...##..#  #.......
                            .byte $19 ; ...##..#  ##......
                            .byte $1a ; ...##.#.  ........
                            .byte $1a ; ...##.#.  .#......
                            .byte $1a ; ...##.#.  #.......
                            .byte $1a ; ...##.#.  ##......
                            .byte $1b ; ...##.##  ........
                            .byte $1b ; ...##.##  .#......
                            .byte $1b ; ...##.##  #.......
                            .byte $1b ; ...##.##  ##......
                            .byte $1c ; ...###..  ........
                            .byte $1c ; ...###..  .#......
                            .byte $1c ; ...###..  #.......
                            .byte $1c ; ...###..  ##......
                            .byte $1d ; ...###.#  ........
                            .byte $1d ; ...###.#  .#......
                            .byte $1d ; ...###.#  #.......
                            .byte $1d ; ...###.#  ##......
                            .byte $1e ; ...####.  ........
                            .byte $1e ; ...####.  .#......
                            .byte $1e ; ...####.  #.......
                            .byte $1e ; ...####.  ##......
                            .byte $1f ; ...#####  ........
                            .byte $1f ; ...#####  .#......
                            .byte $1f ; ...#####  #.......
                            .byte $1f ; ...#####  ##......
                            .byte $20 ; ..#.....  ........
                            .byte $20 ; ..#.....  .#......
                            .byte $20 ; ..#.....  #.......
                            .byte $20 ; ..#.....  ##......
                            .byte $21 ; ..#....#  ........
                            .byte $21 ; ..#....#  .#......
                            .byte $21 ; ..#....#  #.......
                            .byte $21 ; ..#....#  ##......
                            .byte $22 ; ..#...#.  ........
                            .byte $22 ; ..#...#.  .#......
                            .byte $22 ; ..#...#.  #.......
                            .byte $22 ; ..#...#.  ##......
                            .byte $23 ; ..#...##  ........
                            .byte $23 ; ..#...##  .#......
                            .byte $23 ; ..#...##  #.......
                            .byte $23 ; ..#...##  ##......
                            .byte $24 ; ..#..#..  ........
                            .byte $24 ; ..#..#..  .#......
                            .byte $24 ; ..#..#..  #.......
                            .byte $24 ; ..#..#..  ##......
                            .byte $25 ; ..#..#.#  ........
                            .byte $25 ; ..#..#.#  .#......
                            .byte $25 ; ..#..#.#  #.......
                            .byte $25 ; ..#..#.#  ##......
                            .byte $26 ; ..#..##.  ........
                            .byte $26 ; ..#..##.  .#......
                            .byte $26 ; ..#..##.  #.......
                            .byte $26 ; ..#..##.  ##......
                            .byte $27 ; ..#..###  ........
                            .byte $27 ; ..#..###  .#......
                            .byte $27 ; ..#..###  #.......
                            .byte $27 ; ..#..###  ##......
                            .byte $28 ; ..#.#...  ........
                            .byte $28 ; ..#.#...  .#......
                            .byte $28 ; ..#.#...  #.......
                            .byte $28 ; ..#.#...  ##......
                            .byte $29 ; ..#.#..#  ........
                            .byte $29 ; ..#.#..#  .#......
                            .byte $29 ; ..#.#..#  #.......
                            .byte $29 ; ..#.#..#  ##......
                            .byte $2a ; ..#.#.#.  ........
                            .byte $2a ; ..#.#.#.  .#......
                            .byte $2a ; ..#.#.#.  #.......
                            .byte $2a ; ..#.#.#.  ##......
                            .byte $2b ; ..#.#.##  ........
                            .byte $2b ; ..#.#.##  .#......
                            .byte $2b ; ..#.#.##  #.......
                            .byte $2b ; ..#.#.##  ##......
                            .byte $2c ; ..#.##..  ........
                            .byte $2c ; ..#.##..  .#......
                            .byte $2c ; ..#.##..  #.......
                            .byte $2c ; ..#.##..  ##......
                            .byte $2d ; ..#.##.#  ........
                            .byte $2d ; ..#.##.#  .#......
                            .byte $2d ; ..#.##.#  #.......
                            .byte $2d ; ..#.##.#  ##......
                            .byte $2e ; ..#.###.  ........
                            .byte $2e ; ..#.###.  .#......
                            .byte $2e ; ..#.###.  #.......
                            .byte $2e ; ..#.###.  ##......
                            .byte $2f ; ..#.####  ........
                            .byte $2f ; ..#.####  .#......
                            .byte $2f ; ..#.####  #.......
                            .byte $2f ; ..#.####  ##......
                            .byte $30 ; ..##....  ........
                            .byte $30 ; ..##....  .#......
                            .byte $30 ; ..##....  #.......
                            .byte $30 ; ..##....  ##......
                            .byte $31 ; ..##...#  ........
                            .byte $31 ; ..##...#  .#......
                            .byte $31 ; ..##...#  #.......
                            .byte $31 ; ..##...#  ##......
                            .byte $32 ; ..##..#.  ........
                            .byte $32 ; ..##..#.  .#......
                            .byte $32 ; ..##..#.  #.......
                            .byte $32 ; ..##..#.  ##......
                            .byte $33 ; ..##..##  ........
                            .byte $33 ; ..##..##  .#......
                            .byte $33 ; ..##..##  #.......
                            .byte $33 ; ..##..##  ##......
                            .byte $34 ; ..##.#..  ........
                            .byte $34 ; ..##.#..  .#......
                            .byte $34 ; ..##.#..  #.......
                            .byte $34 ; ..##.#..  ##......
                            .byte $35 ; ..##.#.#  ........
                            .byte $35 ; ..##.#.#  .#......
                            .byte $35 ; ..##.#.#  #.......
                            .byte $35 ; ..##.#.#  ##......
                            .byte $36 ; ..##.##.  ........
                            .byte $36 ; ..##.##.  .#......
                            .byte $36 ; ..##.##.  #.......
                            .byte $36 ; ..##.##.  ##......
                            .byte $37 ; ..##.###  ........
                            .byte $37 ; ..##.###  .#......
                            .byte $37 ; ..##.###  #.......
                            .byte $37 ; ..##.###  ##......
                            .byte $38 ; ..###...  ........
                            .byte $38 ; ..###...  .#......
                            .byte $38 ; ..###...  #.......
                            .byte $38 ; ..###...  ##......
                            .byte $39 ; ..###..#  ........
                            .byte $39 ; ..###..#  .#......
                            .byte $39 ; ..###..#  #.......
                            .byte $39 ; ..###..#  ##......
                            .byte $3a ; ..###.#.  ........
                            .byte $3a ; ..###.#.  .#......
                            .byte $3a ; ..###.#.  #.......
                            .byte $3a ; ..###.#.  ##......
                            .byte $3b ; ..###.##  ........
                            .byte $3b ; ..###.##  .#......
                            .byte $3b ; ..###.##  #.......
                            .byte $3b ; ..###.##  ##......
                            .byte $3c ; ..####..  ........
                            .byte $3c ; ..####..  .#......
                            .byte $3c ; ..####..  #.......
                            .byte $3c ; ..####..  ##......
                            .byte $3d ; ..####.#  ........
                            .byte $3d ; ..####.#  .#......
                            .byte $3d ; ..####.#  #.......
                            .byte $3d ; ..####.#  ##......
                            .byte $3e ; ..#####.  ........
                            .byte $3e ; ..#####.  .#......
                            .byte $3e ; ..#####.  #.......
                            .byte $3e ; ..#####.  ##......
                            .byte $3f ; ..######  ........
                            .byte $3f ; ..######  .#......
                            .byte $3f ; ..######  #.......
                            .byte $3f ; ..######  ##......
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_02_Part_02  = *       ; 
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
                            .byte $00 ; ........
                            .byte $40 ; .#......
                            .byte $80 ; #.......
                            .byte $c0 ; ##......
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_03_Part_01  = *       ; 
                            .byte $00 ; ........  ........
                            .byte $00 ; ........  ...#....
                            .byte $00 ; ........  ..#.....
                            .byte $00 ; ........  ..##....
                            .byte $00 ; ........  .#......
                            .byte $00 ; ........  .#.#....
                            .byte $00 ; ........  .##.....
                            .byte $00 ; ........  .###....
                            .byte $00 ; ........  #.......
                            .byte $00 ; ........  #..#....
                            .byte $00 ; ........  #.#.....
                            .byte $00 ; ........  #.##....
                            .byte $00 ; ........  ##......
                            .byte $00 ; ........  ##.#....
                            .byte $00 ; ........  ###.....
                            .byte $00 ; ........  ####....
                            .byte $01 ; .......#  ........
                            .byte $01 ; .......#  ...#....
                            .byte $01 ; .......#  ..#.....
                            .byte $01 ; .......#  ..##....
                            .byte $01 ; .......#  .#......
                            .byte $01 ; .......#  .#.#....
                            .byte $01 ; .......#  .##.....
                            .byte $01 ; .......#  .###....
                            .byte $01 ; .......#  #.......
                            .byte $01 ; .......#  #..#....
                            .byte $01 ; .......#  #.#.....
                            .byte $01 ; .......#  #.##....
                            .byte $01 ; .......#  ##......
                            .byte $01 ; .......#  ##.#....
                            .byte $01 ; .......#  ###.....
                            .byte $01 ; .......#  ####....
                            .byte $02 ; ......#.  ........
                            .byte $02 ; ......#.  ...#....
                            .byte $02 ; ......#.  ..#.....
                            .byte $02 ; ......#.  ..##....
                            .byte $02 ; ......#.  .#......
                            .byte $02 ; ......#.  .#.#....
                            .byte $02 ; ......#.  .##.....
                            .byte $02 ; ......#.  .###....
                            .byte $02 ; ......#.  #.......
                            .byte $02 ; ......#.  #..#....
                            .byte $02 ; ......#.  #.#.....
                            .byte $02 ; ......#.  #.##....
                            .byte $02 ; ......#.  ##......
                            .byte $02 ; ......#.  ##.#....
                            .byte $02 ; ......#.  ###.....
                            .byte $02 ; ......#.  ####....
                            .byte $03 ; ......##  ........
                            .byte $03 ; ......##  ...#....
                            .byte $03 ; ......##  ..#.....
                            .byte $03 ; ......##  ..##....
                            .byte $03 ; ......##  .#......
                            .byte $03 ; ......##  .#.#....
                            .byte $03 ; ......##  .##.....
                            .byte $03 ; ......##  .###....
                            .byte $03 ; ......##  #.......
                            .byte $03 ; ......##  #..#....
                            .byte $03 ; ......##  #.#.....
                            .byte $03 ; ......##  #.##....
                            .byte $03 ; ......##  ##......
                            .byte $03 ; ......##  ##.#....
                            .byte $03 ; ......##  ###.....
                            .byte $03 ; ......##  ####....
                            .byte $04 ; .....#..  ........
                            .byte $04 ; .....#..  ...#....
                            .byte $04 ; .....#..  ..#.....
                            .byte $04 ; .....#..  ..##....
                            .byte $04 ; .....#..  .#......
                            .byte $04 ; .....#..  .#.#....
                            .byte $04 ; .....#..  .##.....
                            .byte $04 ; .....#..  .###....
                            .byte $04 ; .....#..  #.......
                            .byte $04 ; .....#..  #..#....
                            .byte $04 ; .....#..  #.#.....
                            .byte $04 ; .....#..  #.##....
                            .byte $04 ; .....#..  ##......
                            .byte $04 ; .....#..  ##.#....
                            .byte $04 ; .....#..  ###.....
                            .byte $04 ; .....#..  ####....
                            .byte $05 ; .....#.#  ........
                            .byte $05 ; .....#.#  ...#....
                            .byte $05 ; .....#.#  ..#.....
                            .byte $05 ; .....#.#  ..##....
                            .byte $05 ; .....#.#  .#......
                            .byte $05 ; .....#.#  .#.#....
                            .byte $05 ; .....#.#  .##.....
                            .byte $05 ; .....#.#  .###....
                            .byte $05 ; .....#.#  #.......
                            .byte $05 ; .....#.#  #..#....
                            .byte $05 ; .....#.#  #.#.....
                            .byte $05 ; .....#.#  #.##....
                            .byte $05 ; .....#.#  ##......
                            .byte $05 ; .....#.#  ##.#....
                            .byte $05 ; .....#.#  ###.....
                            .byte $05 ; .....#.#  ####....
                            .byte $06 ; .....##.  ........
                            .byte $06 ; .....##.  ...#....
                            .byte $06 ; .....##.  ..#.....
                            .byte $06 ; .....##.  ..##....
                            .byte $06 ; .....##.  .#......
                            .byte $06 ; .....##.  .#.#....
                            .byte $06 ; .....##.  .##.....
                            .byte $06 ; .....##.  .###....
                            .byte $06 ; .....##.  #.......
                            .byte $06 ; .....##.  #..#....
                            .byte $06 ; .....##.  #.#.....
                            .byte $06 ; .....##.  #.##....
                            .byte $06 ; .....##.  ##......
                            .byte $06 ; .....##.  ##.#....
                            .byte $06 ; .....##.  ###.....
                            .byte $06 ; .....##.  ####....
                            .byte $07 ; .....###  ........
                            .byte $07 ; .....###  ...#....
                            .byte $07 ; .....###  ..#.....
                            .byte $07 ; .....###  ..##....
                            .byte $07 ; .....###  .#......
                            .byte $07 ; .....###  .#.#....
                            .byte $07 ; .....###  .##.....
                            .byte $07 ; .....###  .###....
                            .byte $07 ; .....###  #.......
                            .byte $07 ; .....###  #..#....
                            .byte $07 ; .....###  #.#.....
                            .byte $07 ; .....###  #.##....
                            .byte $07 ; .....###  ##......
                            .byte $07 ; .....###  ##.#....
                            .byte $07 ; .....###  ###.....
                            .byte $07 ; .....###  ####....
                            .byte $08 ; ....#...  ........
                            .byte $08 ; ....#...  ...#....
                            .byte $08 ; ....#...  ..#.....
                            .byte $08 ; ....#...  ..##....
                            .byte $08 ; ....#...  .#......
                            .byte $08 ; ....#...  .#.#....
                            .byte $08 ; ....#...  .##.....
                            .byte $08 ; ....#...  .###....
                            .byte $08 ; ....#...  #.......
                            .byte $08 ; ....#...  #..#....
                            .byte $08 ; ....#...  #.#.....
                            .byte $08 ; ....#...  #.##....
                            .byte $08 ; ....#...  ##......
                            .byte $08 ; ....#...  ##.#....
                            .byte $08 ; ....#...  ###.....
                            .byte $08 ; ....#...  ####....
                            .byte $09 ; ....#..#  ........
                            .byte $09 ; ....#..#  ...#....
                            .byte $09 ; ....#..#  ..#.....
                            .byte $09 ; ....#..#  ..##....
                            .byte $09 ; ....#..#  .#......
                            .byte $09 ; ....#..#  .#.#....
                            .byte $09 ; ....#..#  .##.....
                            .byte $09 ; ....#..#  .###....
                            .byte $09 ; ....#..#  #.......
                            .byte $09 ; ....#..#  #..#....
                            .byte $09 ; ....#..#  #.#.....
                            .byte $09 ; ....#..#  #.##....
                            .byte $09 ; ....#..#  ##......
                            .byte $09 ; ....#..#  ##.#....
                            .byte $09 ; ....#..#  ###.....
                            .byte $09 ; ....#..#  ####....
                            .byte $0a ; ....#.#.  ........
                            .byte $0a ; ....#.#.  ...#....
                            .byte $0a ; ....#.#.  ..#.....
                            .byte $0a ; ....#.#.  ..##....
                            .byte $0a ; ....#.#.  .#......
                            .byte $0a ; ....#.#.  .#.#....
                            .byte $0a ; ....#.#.  .##.....
                            .byte $0a ; ....#.#.  .###....
                            .byte $0a ; ....#.#.  #.......
                            .byte $0a ; ....#.#.  #..#....
                            .byte $0a ; ....#.#.  #.#.....
                            .byte $0a ; ....#.#.  #.##....
                            .byte $0a ; ....#.#.  ##......
                            .byte $0a ; ....#.#.  ##.#....
                            .byte $0a ; ....#.#.  ###.....
                            .byte $0a ; ....#.#.  ####....
                            .byte $0b ; ....#.##  ........
                            .byte $0b ; ....#.##  ...#....
                            .byte $0b ; ....#.##  ..#.....
                            .byte $0b ; ....#.##  ..##....
                            .byte $0b ; ....#.##  .#......
                            .byte $0b ; ....#.##  .#.#....
                            .byte $0b ; ....#.##  .##.....
                            .byte $0b ; ....#.##  .###....
                            .byte $0b ; ....#.##  #.......
                            .byte $0b ; ....#.##  #..#....
                            .byte $0b ; ....#.##  #.#.....
                            .byte $0b ; ....#.##  #.##....
                            .byte $0b ; ....#.##  ##......
                            .byte $0b ; ....#.##  ##.#....
                            .byte $0b ; ....#.##  ###.....
                            .byte $0b ; ....#.##  ####....
                            .byte $0c ; ....##..  ........
                            .byte $0c ; ....##..  ...#....
                            .byte $0c ; ....##..  ..#.....
                            .byte $0c ; ....##..  ..##....
                            .byte $0c ; ....##..  .#......
                            .byte $0c ; ....##..  .#.#....
                            .byte $0c ; ....##..  .##.....
                            .byte $0c ; ....##..  .###....
                            .byte $0c ; ....##..  #.......
                            .byte $0c ; ....##..  #..#....
                            .byte $0c ; ....##..  #.#.....
                            .byte $0c ; ....##..  #.##....
                            .byte $0c ; ....##..  ##......
                            .byte $0c ; ....##..  ##.#....
                            .byte $0c ; ....##..  ###.....
                            .byte $0c ; ....##..  ####....
                            .byte $0d ; ....##.#  ........
                            .byte $0d ; ....##.#  ...#....
                            .byte $0d ; ....##.#  ..#.....
                            .byte $0d ; ....##.#  ..##....
                            .byte $0d ; ....##.#  .#......
                            .byte $0d ; ....##.#  .#.#....
                            .byte $0d ; ....##.#  .##.....
                            .byte $0d ; ....##.#  .###....
                            .byte $0d ; ....##.#  #.......
                            .byte $0d ; ....##.#  #..#....
                            .byte $0d ; ....##.#  #.#.....
                            .byte $0d ; ....##.#  #.##....
                            .byte $0d ; ....##.#  ##......
                            .byte $0d ; ....##.#  ##.#....
                            .byte $0d ; ....##.#  ###.....
                            .byte $0d ; ....##.#  ####....
                            .byte $0e ; ....###.  ........
                            .byte $0e ; ....###.  ...#....
                            .byte $0e ; ....###.  ..#.....
                            .byte $0e ; ....###.  ..##....
                            .byte $0e ; ....###.  .#......
                            .byte $0e ; ....###.  .#.#....
                            .byte $0e ; ....###.  .##.....
                            .byte $0e ; ....###.  .###....
                            .byte $0e ; ....###.  #.......
                            .byte $0e ; ....###.  #..#....
                            .byte $0e ; ....###.  #.#.....
                            .byte $0e ; ....###.  #.##....
                            .byte $0e ; ....###.  ##......
                            .byte $0e ; ....###.  ##.#....
                            .byte $0e ; ....###.  ###.....
                            .byte $0e ; ....###.  ####....
                            .byte $0f ; ....####  ........
                            .byte $0f ; ....####  ...#....
                            .byte $0f ; ....####  ..#.....
                            .byte $0f ; ....####  ..##....
                            .byte $0f ; ....####  .#......
                            .byte $0f ; ....####  .#.#....
                            .byte $0f ; ....####  .##.....
                            .byte $0f ; ....####  .###....
                            .byte $0f ; ....####  #.......
                            .byte $0f ; ....####  #..#....
                            .byte $0f ; ....####  #.#.....
                            .byte $0f ; ....####  #.##....
                            .byte $0f ; ....####  ##......
                            .byte $0f ; ....####  ##.#....
                            .byte $0f ; ....####  ###.....
                            .byte $0f ; ....####  ####....
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_03_Part_02  = *       ; 
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
                            .byte $00 ; ........
                            .byte $10 ; ...#....
                            .byte $20 ; ..#.....
                            .byte $30 ; ..##....
                            .byte $40 ; .#......
                            .byte $50 ; .#.#....
                            .byte $60 ; .##.....
                            .byte $70 ; .###....
                            .byte $80 ; #.......
                            .byte $90 ; #..#....
                            .byte $a0 ; #.#.....
                            .byte $b0 ; #.##....
                            .byte $c0 ; ##......
                            .byte $d0 ; ##.#....
                            .byte $e0 ; ###.....
                            .byte $f0 ; ####....
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_04_Part_01  = *       ; 
                            .byte $00 ; ........  ........
                            .byte $00 ; ........  .....#..
                            .byte $00 ; ........  ....#...
                            .byte $00 ; ........  ....##..
                            .byte $00 ; ........  ...#....
                            .byte $00 ; ........  ...#.#..
                            .byte $00 ; ........  ...##...
                            .byte $00 ; ........  ...###..
                            .byte $00 ; ........  ..#.....
                            .byte $00 ; ........  ..#..#..
                            .byte $00 ; ........  ..#.#...
                            .byte $00 ; ........  ..#.##..
                            .byte $00 ; ........  ..##....
                            .byte $00 ; ........  ..##.#..
                            .byte $00 ; ........  ..###...
                            .byte $00 ; ........  ..####..
                            .byte $00 ; ........  .#......
                            .byte $00 ; ........  .#...#..
                            .byte $00 ; ........  .#..#...
                            .byte $00 ; ........  .#..##..
                            .byte $00 ; ........  .#.#....
                            .byte $00 ; ........  .#.#.#..
                            .byte $00 ; ........  .#.##...
                            .byte $00 ; ........  .#.###..
                            .byte $00 ; ........  .##.....
                            .byte $00 ; ........  .##..#..
                            .byte $00 ; ........  .##.#...
                            .byte $00 ; ........  .##.##..
                            .byte $00 ; ........  .###....
                            .byte $00 ; ........  .###.#..
                            .byte $00 ; ........  .####...
                            .byte $00 ; ........  .#####..
                            .byte $00 ; ........  #.......
                            .byte $00 ; ........  #....#..
                            .byte $00 ; ........  #...#...
                            .byte $00 ; ........  #...##..
                            .byte $00 ; ........  #..#....
                            .byte $00 ; ........  #..#.#..
                            .byte $00 ; ........  #..##...
                            .byte $00 ; ........  #..###..
                            .byte $00 ; ........  #.#.....
                            .byte $00 ; ........  #.#..#..
                            .byte $00 ; ........  #.#.#...
                            .byte $00 ; ........  #.#.##..
                            .byte $00 ; ........  #.##....
                            .byte $00 ; ........  #.##.#..
                            .byte $00 ; ........  #.###...
                            .byte $00 ; ........  #.####..
                            .byte $00 ; ........  ##......
                            .byte $00 ; ........  ##...#..
                            .byte $00 ; ........  ##..#...
                            .byte $00 ; ........  ##..##..
                            .byte $00 ; ........  ##.#....
                            .byte $00 ; ........  ##.#.#..
                            .byte $00 ; ........  ##.##...
                            .byte $00 ; ........  ##.###..
                            .byte $00 ; ........  ###.....
                            .byte $00 ; ........  ###..#..
                            .byte $00 ; ........  ###.#...
                            .byte $00 ; ........  ###.##..
                            .byte $00 ; ........  ####....
                            .byte $00 ; ........  ####.#..
                            .byte $00 ; ........  #####...
                            .byte $00 ; ........  ######..
                            .byte $01 ; .......#  ........
                            .byte $01 ; .......#  .....#..
                            .byte $01 ; .......#  ....#...
                            .byte $01 ; .......#  ....##..
                            .byte $01 ; .......#  ...#....
                            .byte $01 ; .......#  ...#.#..
                            .byte $01 ; .......#  ...##...
                            .byte $01 ; .......#  ...###..
                            .byte $01 ; .......#  ..#.....
                            .byte $01 ; .......#  ..#..#..
                            .byte $01 ; .......#  ..#.#...
                            .byte $01 ; .......#  ..#.##..
                            .byte $01 ; .......#  ..##....
                            .byte $01 ; .......#  ..##.#..
                            .byte $01 ; .......#  ..###...
                            .byte $01 ; .......#  ..####..
                            .byte $01 ; .......#  .#......
                            .byte $01 ; .......#  .#...#..
                            .byte $01 ; .......#  .#..#...
                            .byte $01 ; .......#  .#..##..
                            .byte $01 ; .......#  .#.#....
                            .byte $01 ; .......#  .#.#.#..
                            .byte $01 ; .......#  .#.##...
                            .byte $01 ; .......#  .#.###..
                            .byte $01 ; .......#  .##.....
                            .byte $01 ; .......#  .##..#..
                            .byte $01 ; .......#  .##.#...
                            .byte $01 ; .......#  .##.##..
                            .byte $01 ; .......#  .###....
                            .byte $01 ; .......#  .###.#..
                            .byte $01 ; .......#  .####...
                            .byte $01 ; .......#  .#####..
                            .byte $01 ; .......#  #.......
                            .byte $01 ; .......#  #....#..
                            .byte $01 ; .......#  #...#...
                            .byte $01 ; .......#  #...##..
                            .byte $01 ; .......#  #..#....
                            .byte $01 ; .......#  #..#.#..
                            .byte $01 ; .......#  #..##...
                            .byte $01 ; .......#  #..###..
                            .byte $01 ; .......#  #.#.....
                            .byte $01 ; .......#  #.#..#..
                            .byte $01 ; .......#  #.#.#...
                            .byte $01 ; .......#  #.#.##..
                            .byte $01 ; .......#  #.##....
                            .byte $01 ; .......#  #.##.#..
                            .byte $01 ; .......#  #.###...
                            .byte $01 ; .......#  #.####..
                            .byte $01 ; .......#  ##......
                            .byte $01 ; .......#  ##...#..
                            .byte $01 ; .......#  ##..#...
                            .byte $01 ; .......#  ##..##..
                            .byte $01 ; .......#  ##.#....
                            .byte $01 ; .......#  ##.#.#..
                            .byte $01 ; .......#  ##.##...
                            .byte $01 ; .......#  ##.###..
                            .byte $01 ; .......#  ###.....
                            .byte $01 ; .......#  ###..#..
                            .byte $01 ; .......#  ###.#...
                            .byte $01 ; .......#  ###.##..
                            .byte $01 ; .......#  ####....
                            .byte $01 ; .......#  ####.#..
                            .byte $01 ; .......#  #####...
                            .byte $01 ; .......#  ######..
                            .byte $02 ; ......#.  ........
                            .byte $02 ; ......#.  .....#..
                            .byte $02 ; ......#.  ....#...
                            .byte $02 ; ......#.  ....##..
                            .byte $02 ; ......#.  ...#....
                            .byte $02 ; ......#.  ...#.#..
                            .byte $02 ; ......#.  ...##...
                            .byte $02 ; ......#.  ...###..
                            .byte $02 ; ......#.  ..#.....
                            .byte $02 ; ......#.  ..#..#..
                            .byte $02 ; ......#.  ..#.#...
                            .byte $02 ; ......#.  ..#.##..
                            .byte $02 ; ......#.  ..##....
                            .byte $02 ; ......#.  ..##.#..
                            .byte $02 ; ......#.  ..###...
                            .byte $02 ; ......#.  ..####..
                            .byte $02 ; ......#.  .#......
                            .byte $02 ; ......#.  .#...#..
                            .byte $02 ; ......#.  .#..#...
                            .byte $02 ; ......#.  .#..##..
                            .byte $02 ; ......#.  .#.#....
                            .byte $02 ; ......#.  .#.#.#..
                            .byte $02 ; ......#.  .#.##...
                            .byte $02 ; ......#.  .#.###..
                            .byte $02 ; ......#.  .##.....
                            .byte $02 ; ......#.  .##..#..
                            .byte $02 ; ......#.  .##.#...
                            .byte $02 ; ......#.  .##.##..
                            .byte $02 ; ......#.  .###....
                            .byte $02 ; ......#.  .###.#..
                            .byte $02 ; ......#.  .####...
                            .byte $02 ; ......#.  .#####..
                            .byte $02 ; ......#.  #.......
                            .byte $02 ; ......#.  #....#..
                            .byte $02 ; ......#.  #...#...
                            .byte $02 ; ......#.  #...##..
                            .byte $02 ; ......#.  #..#....
                            .byte $02 ; ......#.  #..#.#..
                            .byte $02 ; ......#.  #..##...
                            .byte $02 ; ......#.  #..###..
                            .byte $02 ; ......#.  #.#.....
                            .byte $02 ; ......#.  #.#..#..
                            .byte $02 ; ......#.  #.#.#...
                            .byte $02 ; ......#.  #.#.##..
                            .byte $02 ; ......#.  #.##....
                            .byte $02 ; ......#.  #.##.#..
                            .byte $02 ; ......#.  #.###...
                            .byte $02 ; ......#.  #.####..
                            .byte $02 ; ......#.  ##......
                            .byte $02 ; ......#.  ##...#..
                            .byte $02 ; ......#.  ##..#...
                            .byte $02 ; ......#.  ##..##..
                            .byte $02 ; ......#.  ##.#....
                            .byte $02 ; ......#.  ##.#.#..
                            .byte $02 ; ......#.  ##.##...
                            .byte $02 ; ......#.  ##.###..
                            .byte $02 ; ......#.  ###.....
                            .byte $02 ; ......#.  ###..#..
                            .byte $02 ; ......#.  ###.#...
                            .byte $02 ; ......#.  ###.##..
                            .byte $02 ; ......#.  ####....
                            .byte $02 ; ......#.  ####.#..
                            .byte $02 ; ......#.  #####...
                            .byte $02 ; ......#.  ######..
                            .byte $03 ; ......##  ........
                            .byte $03 ; ......##  .....#..
                            .byte $03 ; ......##  ....#...
                            .byte $03 ; ......##  ....##..
                            .byte $03 ; ......##  ...#....
                            .byte $03 ; ......##  ...#.#..
                            .byte $03 ; ......##  ...##...
                            .byte $03 ; ......##  ...###..
                            .byte $03 ; ......##  ..#.....
                            .byte $03 ; ......##  ..#..#..
                            .byte $03 ; ......##  ..#.#...
                            .byte $03 ; ......##  ..#.##..
                            .byte $03 ; ......##  ..##....
                            .byte $03 ; ......##  ..##.#..
                            .byte $03 ; ......##  ..###...
                            .byte $03 ; ......##  ..####..
                            .byte $03 ; ......##  .#......
                            .byte $03 ; ......##  .#...#..
                            .byte $03 ; ......##  .#..#...
                            .byte $03 ; ......##  .#..##..
                            .byte $03 ; ......##  .#.#....
                            .byte $03 ; ......##  .#.#.#..
                            .byte $03 ; ......##  .#.##...
                            .byte $03 ; ......##  .#.###..
                            .byte $03 ; ......##  .##.....
                            .byte $03 ; ......##  .##..#..
                            .byte $03 ; ......##  .##.#...
                            .byte $03 ; ......##  .##.##..
                            .byte $03 ; ......##  .###....
                            .byte $03 ; ......##  .###.#..
                            .byte $03 ; ......##  .####...
                            .byte $03 ; ......##  .#####..
                            .byte $03 ; ......##  #.......
                            .byte $03 ; ......##  #....#..
                            .byte $03 ; ......##  #...#...
                            .byte $03 ; ......##  #...##..
                            .byte $03 ; ......##  #..#....
                            .byte $03 ; ......##  #..#.#..
                            .byte $03 ; ......##  #..##...
                            .byte $03 ; ......##  #..###..
                            .byte $03 ; ......##  #.#.....
                            .byte $03 ; ......##  #.#..#..
                            .byte $03 ; ......##  #.#.#...
                            .byte $03 ; ......##  #.#.##..
                            .byte $03 ; ......##  #.##....
                            .byte $03 ; ......##  #.##.#..
                            .byte $03 ; ......##  #.###...
                            .byte $03 ; ......##  #.####..
                            .byte $03 ; ......##  ##......
                            .byte $03 ; ......##  ##...#..
                            .byte $03 ; ......##  ##..#...
                            .byte $03 ; ......##  ##..##..
                            .byte $03 ; ......##  ##.#....
                            .byte $03 ; ......##  ##.#.#..
                            .byte $03 ; ......##  ##.##...
                            .byte $03 ; ......##  ##.###..
                            .byte $03 ; ......##  ###.....
                            .byte $03 ; ......##  ###..#..
                            .byte $03 ; ......##  ###.#...
                            .byte $03 ; ......##  ###.##..
                            .byte $03 ; ......##  ####....
                            .byte $03 ; ......##  ####.#..
                            .byte $03 ; ......##  #####...
                            .byte $03 ; ......##  ######..
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataPos_04_Part_02  = *       ; 
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $0c ; ....##..
                            .byte $10 ; ...#....
                            .byte $14 ; ...#.#..
                            .byte $18 ; ...##...
                            .byte $1c ; ...###..
                            .byte $20 ; ..#.....
                            .byte $24 ; ..#..#..
                            .byte $28 ; ..#.#...
                            .byte $2c ; ..#.##..
                            .byte $30 ; ..##....
                            .byte $34 ; ..##.#..
                            .byte $38 ; ..###...
                            .byte $3c ; ..####..
                            .byte $40 ; .#......
                            .byte $44 ; .#...#..
                            .byte $48 ; .#..#...
                            .byte $4c ; .#..##..
                            .byte $50 ; .#.#....
                            .byte $54 ; .#.#.#..
                            .byte $58 ; .#.##...
                            .byte $5c ; .#.###..
                            .byte $60 ; .##.....
                            .byte $64 ; .##..#..
                            .byte $68 ; .##.#...
                            .byte $6c ; .##.##..
                            .byte $70 ; .###....
                            .byte $74 ; .###.#..
                            .byte $78 ; .####...
                            .byte $7c ; .#####..
                            .byte $80 ; #.......
                            .byte $84 ; #....#..
                            .byte $88 ; #...#...
                            .byte $8c ; #...##..
                            .byte $90 ; #..#....
                            .byte $94 ; #..#.#..
                            .byte $98 ; #..##...
                            .byte $9c ; #..###..
                            .byte $a0 ; #.#.....
                            .byte $a4 ; #.#..#..
                            .byte $a8 ; #.#.#...
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.##....
                            .byte $b4 ; #.##.#..
                            .byte $b8 ; #.###...
                            .byte $bc ; #.####..
                            .byte $c0 ; ##......
                            .byte $c4 ; ##...#..
                            .byte $c8 ; ##..#...
                            .byte $cc ; ##..##..
                            .byte $d0 ; ##.#....
                            .byte $d4 ; ##.#.#..
                            .byte $d8 ; ##.##...
                            .byte $dc ; ##.###..
                            .byte $e0 ; ###.....
                            .byte $e4 ; ###..#..
                            .byte $e8 ; ###.#...
                            .byte $ec ; ###.##..
                            .byte $f0 ; ####....
                            .byte $f4 ; ####.#..
                            .byte $f8 ; #####...
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $0c ; ....##..
                            .byte $10 ; ...#....
                            .byte $14 ; ...#.#..
                            .byte $18 ; ...##...
                            .byte $1c ; ...###..
                            .byte $20 ; ..#.....
                            .byte $24 ; ..#..#..
                            .byte $28 ; ..#.#...
                            .byte $2c ; ..#.##..
                            .byte $30 ; ..##....
                            .byte $34 ; ..##.#..
                            .byte $38 ; ..###...
                            .byte $3c ; ..####..
                            .byte $40 ; .#......
                            .byte $44 ; .#...#..
                            .byte $48 ; .#..#...
                            .byte $4c ; .#..##..
                            .byte $50 ; .#.#....
                            .byte $54 ; .#.#.#..
                            .byte $58 ; .#.##...
                            .byte $5c ; .#.###..
                            .byte $60 ; .##.....
                            .byte $64 ; .##..#..
                            .byte $68 ; .##.#...
                            .byte $6c ; .##.##..
                            .byte $70 ; .###....
                            .byte $74 ; .###.#..
                            .byte $78 ; .####...
                            .byte $7c ; .#####..
                            .byte $80 ; #.......
                            .byte $84 ; #....#..
                            .byte $88 ; #...#...
                            .byte $8c ; #...##..
                            .byte $90 ; #..#....
                            .byte $94 ; #..#.#..
                            .byte $98 ; #..##...
                            .byte $9c ; #..###..
                            .byte $a0 ; #.#.....
                            .byte $a4 ; #.#..#..
                            .byte $a8 ; #.#.#...
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.##....
                            .byte $b4 ; #.##.#..
                            .byte $b8 ; #.###...
                            .byte $bc ; #.####..
                            .byte $c0 ; ##......
                            .byte $c4 ; ##...#..
                            .byte $c8 ; ##..#...
                            .byte $cc ; ##..##..
                            .byte $d0 ; ##.#....
                            .byte $d4 ; ##.#.#..
                            .byte $d8 ; ##.##...
                            .byte $dc ; ##.###..
                            .byte $e0 ; ###.....
                            .byte $e4 ; ###..#..
                            .byte $e8 ; ###.#...
                            .byte $ec ; ###.##..
                            .byte $f0 ; ####....
                            .byte $f4 ; ####.#..
                            .byte $f8 ; #####...
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $0c ; ....##..
                            .byte $10 ; ...#....
                            .byte $14 ; ...#.#..
                            .byte $18 ; ...##...
                            .byte $1c ; ...###..
                            .byte $20 ; ..#.....
                            .byte $24 ; ..#..#..
                            .byte $28 ; ..#.#...
                            .byte $2c ; ..#.##..
                            .byte $30 ; ..##....
                            .byte $34 ; ..##.#..
                            .byte $38 ; ..###...
                            .byte $3c ; ..####..
                            .byte $40 ; .#......
                            .byte $44 ; .#...#..
                            .byte $48 ; .#..#...
                            .byte $4c ; .#..##..
                            .byte $50 ; .#.#....
                            .byte $54 ; .#.#.#..
                            .byte $58 ; .#.##...
                            .byte $5c ; .#.###..
                            .byte $60 ; .##.....
                            .byte $64 ; .##..#..
                            .byte $68 ; .##.#...
                            .byte $6c ; .##.##..
                            .byte $70 ; .###....
                            .byte $74 ; .###.#..
                            .byte $78 ; .####...
                            .byte $7c ; .#####..
                            .byte $80 ; #.......
                            .byte $84 ; #....#..
                            .byte $88 ; #...#...
                            .byte $8c ; #...##..
                            .byte $90 ; #..#....
                            .byte $94 ; #..#.#..
                            .byte $98 ; #..##...
                            .byte $9c ; #..###..
                            .byte $a0 ; #.#.....
                            .byte $a4 ; #.#..#..
                            .byte $a8 ; #.#.#...
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.##....
                            .byte $b4 ; #.##.#..
                            .byte $b8 ; #.###...
                            .byte $bc ; #.####..
                            .byte $c0 ; ##......
                            .byte $c4 ; ##...#..
                            .byte $c8 ; ##..#...
                            .byte $cc ; ##..##..
                            .byte $d0 ; ##.#....
                            .byte $d4 ; ##.#.#..
                            .byte $d8 ; ##.##...
                            .byte $dc ; ##.###..
                            .byte $e0 ; ###.....
                            .byte $e4 ; ###..#..
                            .byte $e8 ; ###.#...
                            .byte $ec ; ###.##..
                            .byte $f0 ; ####....
                            .byte $f4 ; ####.#..
                            .byte $f8 ; #####...
                            .byte $fc ; ######..
                            .byte $00 ; ........
                            .byte $04 ; .....#..
                            .byte $08 ; ....#...
                            .byte $0c ; ....##..
                            .byte $10 ; ...#....
                            .byte $14 ; ...#.#..
                            .byte $18 ; ...##...
                            .byte $1c ; ...###..
                            .byte $20 ; ..#.....
                            .byte $24 ; ..#..#..
                            .byte $28 ; ..#.#...
                            .byte $2c ; ..#.##..
                            .byte $30 ; ..##....
                            .byte $34 ; ..##.#..
                            .byte $38 ; ..###...
                            .byte $3c ; ..####..
                            .byte $40 ; .#......
                            .byte $44 ; .#...#..
                            .byte $48 ; .#..#...
                            .byte $4c ; .#..##..
                            .byte $50 ; .#.#....
                            .byte $54 ; .#.#.#..
                            .byte $58 ; .#.##...
                            .byte $5c ; .#.###..
                            .byte $60 ; .##.....
                            .byte $64 ; .##..#..
                            .byte $68 ; .##.#...
                            .byte $6c ; .##.##..
                            .byte $70 ; .###....
                            .byte $74 ; .###.#..
                            .byte $78 ; .####...
                            .byte $7c ; .#####..
                            .byte $80 ; #.......
                            .byte $84 ; #....#..
                            .byte $88 ; #...#...
                            .byte $8c ; #...##..
                            .byte $90 ; #..#....
                            .byte $94 ; #..#.#..
                            .byte $98 ; #..##...
                            .byte $9c ; #..###..
                            .byte $a0 ; #.#.....
                            .byte $a4 ; #.#..#..
                            .byte $a8 ; #.#.#...
                            .byte $ac ; #.#.##..
                            .byte $b0 ; #.##....
                            .byte $b4 ; #.##.#..
                            .byte $b8 ; #.###...
                            .byte $bc ; #.####..
                            .byte $c0 ; ##......
                            .byte $c4 ; ##...#..
                            .byte $c8 ; ##..#...
                            .byte $cc ; ##..##..
                            .byte $d0 ; ##.#....
                            .byte $d4 ; ##.#.#..
                            .byte $d8 ; ##.##...
                            .byte $dc ; ##.###..
                            .byte $e0 ; ###.....
                            .byte $e4 ; ###..#..
                            .byte $e8 ; ###.#...
                            .byte $ec ; ###.##..
                            .byte $f0 ; ####....
                            .byte $f4 ; ####.#..
                            .byte $f8 ; #####...
                            .byte $fc ; ######..
; --------------------------------------------------------------------------------------------------------------------- ;
; table image data offsets for image rows $00-$0a and imges form $00-$67
; --------------------------------------------------------------------------------------------------------------------- ;
; to construct a image
;   select the image number row
;   pick up the data bytes from TabImageData with each of the row offsets 
;     image row byte 1 - from $a000/$a200/$a400/$a600 - At TabImageDataOff_Len
;     image row byte 2 - from $a100/$a300/$a500/$a700 - At TabImageDataOff_Len       - part 1 - combined with part 2
;                      - from $a000/$a200/$a400/$a600 - At TabImageDataOff_Len * $02 - part 2
;     image row byte 3 - from $a100/$a300/$a500/$a700 - At TabImageDataOff_Len * $02
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff             = *       ; image data offsets
; .---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+-----------------------------.
; ! row $00 ! row $01 ! row $02 ! row $03 ! row $04 ! row $05 ! row $06 ! row $07 ! row $08 ! row $09 ! row $0a ! image number                !
; +---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+-----------------------------+
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00 - Level Tile Blank      !
; ! $a8-$80 ! $a8-$80 ! $a8-$80 ! $a8-$80 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $01 - Level Tile WallWeak   +
; ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $00-$00 ! $02 - Level Tile WallHard   !
; ! $c3-$00 ! $c3-$00 ! $ff-$00 ! $c3-$00 ! $c3-$00 ! $c3-$00 ! $c3-$00 ! $ff-$00 ! $c3-$00 ! $c3-$00 ! $c3-$00 ! $03 - Level Tile Ladder     !
; ! $00-$00 ! $ff-$c0 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $04 - Level Tile Pole       !
; ! $aa-$80 ! $aa-$80 ! $00-$00 ! $3f-$00 ! $0c-$00 ! $0c-$00 ! $0c-$00 ! $0c-$00 ! $aa-$80 ! $aa-$80 ! $00-$00 ! $05 - Level Tile WallTrap   !
; ! $c0-$00 ! $c0-$00 ! $ff-$00 ! $c3-$00 ! $03-$00 ! $03-$00 ! $03-$00 ! $c3-$00 ! $ff-$00 ! $c0-$00 ! $c0-$00 ! $06 - Level Tile LadderSec  !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $ff-$00 ! $eb-$00 ! $eb-$00 ! $eb-$00 ! $ff-$00 ! $00-$00 ! $07 - Level Tile Gold       !
; ! $08-$00 ! $14-$00 ! $14-$00 ! $04-$00 ! $15-$00 ! $44-$40 ! $06-$00 ! $15-$00 ! $15-$40 ! $10-$00 ! $10-$00 ! $08 - Level Tile Enemy      !
; ! $02-$00 ! $07-$00 ! $07-$00 ! $0e-$00 ! $37-$00 ! $6c-$c0 ! $0c-$00 ! $0e-$00 ! $7b-$00 ! $03-$00 ! $03-$00 ! $09 - Level Tile LodeRunner !
; ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $ff-$c0 ! $0a - Blank Reverse         !
; ! $10-$00 ! $38-$00 ! $38-$00 ! $1c-$00 ! $3b-$00 ! $cd-$80 ! $0c-$00 ! $1c-$00 ! $37-$80 ! $30-$00 ! $30-$00 ! $0b - Sprite Run Le 00      !
; ! $10-$00 ! $38-$00 ! $38-$00 ! $18-$00 ! $1c-$00 ! $3e-$00 ! $de-$00 ! $38-$00 ! $3c-$00 ! $0e-$00 ! $0c-$00 ! $0c - Sprite Run Le 01      !
; ! $10-$00 ! $38-$00 ! $38-$00 ! $18-$00 ! $5e-$00 ! $7b-$00 ! $18-$00 ! $3c-$00 ! $66-$00 ! $63-$00 ! $03-$00 ! $0d - Sprite Run Le 02      !
; ! $0c-$00 ! $0c-$40 ! $0f-$c0 ! $4e-$00 ! $7e-$00 ! $0e-$00 ! $0e-$00 ! $1b-$00 ! $1b-$80 ! $18-$00 ! $38-$00 ! $0e - Sprite Ladder 00      !
; ! $02-$00 ! $07-$00 ! $07-$00 ! $03-$00 ! $0f-$c0 ! $5b-$40 ! $43-$00 ! $07-$00 ! $0d-$80 ! $0d-$80 ! $0d-$80 ! $0f - Sprite Fire Le        !
; ! $02-$00 ! $07-$00 ! $07-$00 ! $06-$00 ! $0e-$00 ! $1f-$00 ! $1e-$c0 ! $07-$00 ! $0f-$00 ! $1c-$00 ! $0c-$00 ! $10 - Sprite Run Ri 00      !
; ! $02-$00 ! $07-$00 ! $07-$00 ! $06-$00 ! $1e-$80 ! $37-$80 ! $06-$00 ! $0f-$00 ! $19-$80 ! $31-$80 ! $30-$00 ! $11 - Sprite Run Ri 01      !
; ! $0c-$00 ! $8c-$00 ! $fc-$00 ! $1c-$80 ! $1f-$80 ! $1c-$00 ! $1c-$00 ! $36-$00 ! $76-$00 ! $06-$00 ! $07-$00 ! $12 - Sprite Run Ri 02      !
; ! $64-$c0 ! $6e-$c0 ! $6e-$c0 ! $3f-$80 ! $06-$00 ! $06-$00 ! $1e-$00 ! $36-$00 ! $36-$00 ! $36-$00 ! $06-$00 ! $13 - Sprite Fall Le        !
; ! $c9-$80 ! $dd-$80 ! $dd-$80 ! $7f-$00 ! $18-$00 ! $18-$00 ! $1e-$00 ! $1b-$00 ! $1b-$00 ! $1b-$00 ! $18-$00 ! $14 - Sprite Fall Ri        !
; ! $61-$80 ! $61-$80 ! $6d-$80 ! $6f-$00 ! $3c-$00 ! $18-$00 ! $18-$00 ! $78-$00 ! $d8-$00 ! $d8-$00 ! $b0-$00 ! $15 - Sprite Pole Ri 00     !
; ! $06-$00 ! $06-$00 ! $1e-$00 ! $1c-$00 ! $78-$00 ! $d8-$00 ! $18-$00 ! $38-$00 ! $6c-$00 ! $6c-$00 ! $6c-$00 ! $16 - Sprite Pole Ri 01     !
; ! $18-$00 ! $18-$00 ! $1e-$00 ! $0e-$c0 ! $07-$80 ! $06-$00 ! $06-$00 ! $0e-$00 ! $1b-$00 ! $1b-$00 ! $1b-$00 ! $17 - Sprite Pole Ri 02     !
; ! $61-$80 ! $61-$80 ! $6d-$80 ! $3d-$80 ! $0f-$00 ! $06-$00 ! $06-$00 ! $07-$80 ! $06-$c0 ! $06-$c0 ! $03-$40 ! $18 - Sprite Pole Le 00     !
; ! $18-$00 ! $18-$00 ! $1e-$00 ! $0e-$00 ! $07-$80 ! $06-$c0 ! $06-$00 ! $07-$00 ! $0d-$80 ! $0d-$80 ! $0d-$80 ! $19 - Sprite Pole Le 01     !
; ! $06-$00 ! $06-$00 ! $1e-$00 ! $dc-$00 ! $78-$00 ! $18-$00 ! $18-$00 ! $1c-$00 ! $36-$00 ! $36-$00 ! $36-$00 ! $1a - Sprite Pole Le 02     !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $02-$40 ! $20-$40 ! $09-$00 ! $01-$00 ! $1b - Shoot Spark 00        !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $00-$00 ! $00-$80 ! $80-$00 ! $20-$00 ! $0a-$40 ! $21-$40 ! $09-$00 ! $1c - Shoot Spark 01        !
; ! $08-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $88-$00 ! $00-$80 ! $80-$00 ! $20-$00 ! $02-$00 ! $1d - Shoot Spark 02        !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $00-$00 ! $80-$00 ! $00-$00 ! $00-$80 ! $00-$00 ! $00-$00 ! $00-$00 ! $1e - Shoot Spark 03        !
; ! $a4-$80 ! $a8-$80 ! $a8-$80 ! $a8-$80 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $1f - Shoot Melt Ground 00  !
; ! $04-$00 ! $14-$00 ! $80-$80 ! $a8-$80 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $20 - Shoot Melt Ground 01  !
; ! $00-$00 ! $04-$00 ! $14-$00 ! $94-$80 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $21 - Shoot Melt Ground 02  !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $04-$00 ! $14-$00 ! $15-$00 ! $00-$00 ! $8a-$80 ! $8a-$80 ! $8a-$80 ! $00-$00 ! $22 - Shoot Melt Ground 03  !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $04-$00 ! $05-$00 ! $95-$00 ! $80-$00 ! $8a-$80 ! $00-$00 ! $23 - Shoot Melt Ground 04  !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $04-$00 ! $14-$00 ! $15-$00 ! $00-$00 ! $24 - Shoot Melt Ground 05  !
; ! $08-$00 ! $1c-$00 ! $1c-$00 ! $18-$00 ! $7e-$00 ! $5b-$40 ! $18-$40 ! $1c-$00 ! $36-$00 ! $36-$00 ! $36-$00 ! $25 - Fire Ri               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $22-$00 ! $48-$00 ! $50-$80 ! $10-$00 ! $26 - Shoot Melt 00         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $00-$00 ! $00-$80 ! $a0-$00 ! $40-$00 ! $4a-$00 ! $11-$00 ! $11-$00 ! $27 - Shoot Melt 01         !
; ! $02-$00 ! $05-$00 ! $05-$00 ! $04-$00 ! $15-$00 ! $44-$40 ! $0c-$00 ! $0e-$00 ! $7b-$00 ! $03-$00 ! $03-$00 ! $28 - Run Ri 00             !
; ! $02-$00 ! $05-$00 ! $05-$00 ! $04-$00 ! $14-$00 ! $15-$00 ! $06-$40 ! $07-$00 ! $0f-$00 ! $1c-$00 ! $0c-$00 ! $29 - Run Ri 01             !
; ! $02-$00 ! $05-$00 ! $05-$00 ! $04-$00 ! $15-$00 ! $45-$00 ! $06-$00 ! $0f-$00 ! $19-$80 ! $31-$80 ! $30-$00 ! $2a - Run Ri 02             !
; ! $08-$00 ! $14-$00 ! $14-$00 ! $04-$00 ! $05-$00 ! $15-$00 ! $4c-$00 ! $1c-$00 ! $1e-$00 ! $07-$00 ! $06-$00 ! $2b - Run Le 01             !
; ! $08-$00 ! $14-$00 ! $14-$00 ! $04-$00 ! $15-$00 ! $14-$40 ! $0c-$00 ! $1e-$00 ! $33-$00 ! $31-$80 ! $01-$80 ! $2c - Run Le 02             !
; ! $41-$00 ! $41-$00 ! $45-$00 ! $45-$00 ! $14-$00 ! $10-$00 ! $10-$00 ! $78-$00 ! $d8-$00 ! $d8-$00 ! $b0-$00 ! $2d - Pole Ri 00            !
; ! $04-$00 ! $04-$00 ! $14-$00 ! $14-$00 ! $50-$00 ! $50-$00 ! $10-$00 ! $38-$00 ! $6c-$00 ! $6c-$00 ! $0c-$00 ! $2e - Pole Ri 01            !
; ! $10-$00 ! $10-$00 ! $14-$00 ! $04-$40 ! $05-$00 ! $04-$00 ! $04-$00 ! $0e-$00 ! $1b-$00 ! $1b-$00 ! $1b-$00 ! $2f - Pole Ri 02            !
; ! $41-$00 ! $41-$00 ! $51-$00 ! $51-$00 ! $14-$00 ! $04-$00 ! $04-$00 ! $0f-$00 ! $0d-$80 ! $0d-$80 ! $06-$80 ! $30 - Pole Le 00            !
; ! $10-$00 ! $10-$00 ! $14-$00 ! $14-$00 ! $05-$00 ! $05-$00 ! $04-$00 ! $0e-$00 ! $1b-$00 ! $1b-$00 ! $1b-$00 ! $31 - Pole Le 01            !
; ! $04-$00 ! $04-$00 ! $14-$00 ! $10-$00 ! $50-$00 ! $10-$00 ! $10-$00 ! $38-$00 ! $6c-$00 ! $6c-$00 ! $6c-$00 ! $32 - Pole Le 02            !
; ! $04-$00 ! $04-$40 ! $05-$40 ! $44-$00 ! $54-$00 ! $04-$00 ! $0e-$00 ! $1b-$00 ! $1b-$80 ! $18-$00 ! $38-$00 ! $33 - Ladder  00            !
; ! $04-$00 ! $84-$00 ! $d4-$00 ! $14-$80 ! $15-$80 ! $14-$00 ! $1c-$00 ! $36-$00 ! $76-$00 ! $06-$00 ! $07-$00 ! $34 - Ladder  01            !
; ! $44-$40 ! $44-$40 ! $44-$40 ! $15-$00 ! $04-$00 ! $04-$00 ! $0f-$00 ! $0d-$80 ! $0d-$80 ! $0d-$80 ! $0c-$00 ! $35 - Fall Ri               !
; ! $44-$40 ! $44-$40 ! $44-$40 ! $15-$00 ! $04-$00 ! $04-$00 ! $1e-$00 ! $36-$00 ! $36-$00 ! $36-$00 ! $06-$00 ! $36 - Fall Le               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $80-$80 ! $80-$80 ! $00-$00 ! $37 - Close Hole 00         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $80-$80 ! $80-$80 ! $80-$80 ! $80-$80 ! $00-$00 ! $38 - Close Hole 01         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $14-$00 ! $55-$00 ! $00-$00 ! $39 - Enemy Rebirth 00         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $14-$00 ! $55-$00 ! $55-$00 ! $00-$00 ! $3a - Enemy Rebirth 01         !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $41-$00 ! $41-$00 ! $45-$00 ! $45-$00 ! $45-$00 ! $55-$00 ! $3b - Digit 0               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $14-$00 ! $14-$00 ! $04-$00 ! $04-$00 ! $04-$00 ! $04-$00 ! $15-$00 ! $15-$00 ! $3c - Digit 1               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $01-$00 ! $55-$00 ! $40-$00 ! $40-$00 ! $45-$00 ! $55-$00 ! $3d - Digit 2               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $01-$00 ! $15-$00 ! $01-$00 ! $01-$00 ! $41-$00 ! $55-$00 ! $3e - Digit 3               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $51-$00 ! $51-$00 ! $51-$00 ! $55-$00 ! $01-$00 ! $01-$00 ! $01-$00 ! $01-$00 ! $3f - Digit 4               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $40-$00 ! $40-$00 ! $55-$00 ! $05-$00 ! $05-$00 ! $05-$00 ! $55-$00 ! $40 - Digit 5               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $40-$00 ! $40-$00 ! $55-$00 ! $45-$00 ! $45-$00 ! $55-$00 ! $41 - Digit 6               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $05-$00 ! $05-$00 ! $05-$00 ! $14-$00 ! $10-$00 ! $10-$00 ! $10-$00 ! $42 - Digit 7               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $15-$00 ! $11-$00 ! $11-$00 ! $55-$00 ! $41-$00 ! $41-$00 ! $41-$00 ! $55-$00 ! $43 - Digit 8               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $55-$00 ! $41-$00 ! $41-$00 ! $55-$00 ! $05-$00 ! $05-$00 ! $05-$00 ! $05-$00 ! $44 - Digit 9               !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $2a-$00 ! $22-$00 ! $22-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $8a-$00 ! $8a-$00 ! $45 - Char A                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $a8-$00 ! $88-$00 ! $88-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $46 - Char B                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $80-$00 ! $80-$00 ! $a0-$00 ! $a0-$00 ! $a2-$00 ! $aa-$00 ! $47 - Char C                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $a8-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $a8-$00 ! $48 - Char D                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $a0-$00 ! $a0-$00 ! $a8-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $aa-$00 ! $49 - Char E                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $a0-$00 ! $a0-$00 ! $a8-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $4a - Char F                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $80-$00 ! $80-$00 ! $8a-$00 ! $8a-$00 ! $82-$00 ! $aa-$00 ! $4b - Char G                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $4c - Char H                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $20-$00 ! $20-$00 ! $20-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $4d - Char I                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $08-$00 ! $08-$00 ! $08-$00 ! $0a-$00 ! $0a-$00 ! $0a-$00 ! $8a-$00 ! $aa-$00 ! $4e - Char J                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $8a-$00 ! $88-$00 ! $a8-$00 ! $aa-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $4f - Char K                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $80-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $aa-$00 ! $50 - Char L                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $a2-$00 ! $aa-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $51 - Char M                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $a2-$00 ! $aa-$00 ! $aa-$00 ! $8a-$00 ! $82-$00 ! $82-$00 ! $52 - Char N                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $8a-$00 ! $8a-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $53 - Char O                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $54 - Char P                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $8a-$00 ! $8a-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $88-$00 ! $a2-$00 ! $55 - Char Q                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $a8-$00 ! $a8-$00 ! $a2-$00 ! $a2-$00 ! $56 - Char R                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $80-$00 ! $aa-$00 ! $0a-$00 ! $0a-$00 ! $8a-$00 ! $aa-$00 ! $57 - Char S                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $20-$00 ! $20-$00 ! $20-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $58 - Char T                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $aa-$00 ! $59 - Char U                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $a2-$00 ! $aa-$00 ! $28-$00 ! $20-$00 ! $5a - Char V                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $aa-$00 ! $aa-$00 ! $a2-$00 ! $82-$00 ! $5b - Char W                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $28-$00 ! $28-$00 ! $82-$00 ! $82-$00 ! $82-$00 ! $5c - Char X                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $8a-$00 ! $8a-$00 ! $8a-$00 ! $aa-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $5d - Char Y                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$00 ! $82-$00 ! $82-$00 ! $08-$00 ! $28-$00 ! $80-$00 ! $8a-$00 ! $aa-$00 ! $5e - Char Z                !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $80-$00 ! $a0-$00 ! $28-$00 ! $0a-$00 ! $0a-$00 ! $28-$00 ! $a0-$00 ! $80-$00 ! $5f - Special Char  >       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $28-$00 ! $28-$00 ! $28-$00 ! $60 - Special Char  .       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $28-$00 ! $28-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $a0-$00 ! $28-$00 ! $28-$00 ! $61 - Special Char  (       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $28-$00 ! $28-$00 ! $0a-$00 ! $0a-$00 ! $0a-$00 ! $0a-$00 ! $28-$00 ! $28-$00 ! $62 - Special Char  )       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $02-$00 ! $02-$00 ! $08-$00 ! $08-$00 ! $20-$00 ! $20-$00 ! $80-$00 ! $80-$00 ! $63 - Special Char  /       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $aa-$80 ! $00-$00 ! $00-$00 ! $64 - Special Char  -       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $02-$00 ! $0a-$00 ! $28-$00 ! $a0-$00 ! $a0-$00 ! $28-$00 ! $0a-$00 ! $02-$00 ! $65 - Special Char  <       !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $66 - Blank                 !
; ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $00-$00 ! $67 - Blank                 !
; `---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+---------+-----------------------------´
TabImageDataOff_R_00_B_01   = *       ; offset to image data row_00 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $a8 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $aa ; $05 - Level Tile Wall Trap
                            .byte $c0 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $08 ; $08 - Level Tile Enemy
                            .byte $02 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $10 ; $0b - Loderunner Run Le 00
                            .byte $10 ; $0c - Loderunner Run Le 01
                            .byte $10 ; $0d - Loderunner Run Le 02
                            .byte $0c ; $0e - Loderunner Ladder 00
                            .byte $02 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $02 ; $10 - Loderunner Run Ri 01
                            .byte $02 ; $11 - Loderunner Run Ri 02
                            .byte $0c ; $12 - Loderunner Ladder 01
                            .byte $64 ; $13 - Loderunner Fall Le
                            .byte $c9 ; $14 - Loderunner Fall Ri
                            .byte $61 ; $15 - Loderunner Pole Ri 00
                            .byte $06 ; $16 - Loderunner Pole Ri 01
                            .byte $18 ; $17 - Loderunner Pole Ri 02
                            .byte $61 ; $18 - Loderunner Pole Le 00
                            .byte $18 ; $19 - Loderunner Pole Le 01
                            .byte $06 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $08 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $a4 ; $1f - Shoot Melt Ground 00
                            .byte $04 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $08 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $02 ; $28 - Enemy Run Ri 00
                            .byte $02 ; $29 - Enemy Run Ri 01
                            .byte $02 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $08 ; $2b - Enemy Run Le 01
                            .byte $08 ; $2c - Enemy Run Le 02
                            .byte $41 ; $2d - Enemy Pole Ri 00
                            .byte $04 ; $2e - Enemy Pole Ri 01
                            .byte $10 ; $2f - Enemy Pole Ri 02
                            .byte $41 ; $30 - Enemy Pole Le 00
                            .byte $10 ; $31 - Enemy Pole Le 01
                            .byte $04 ; $32 - Enemy Pole Le 02
                            .byte $04 ; $33 - Enemy Ladder  00
                            .byte $04 ; $34 - Enemy Ladder  01
                            .byte $44 ; $35 - Enemy Fall Ri
                            .byte $44 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
TabImageDataOff_Len         = * - TabImageDataOff ; length of pointer table entry
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_00_B_02   = *       ; offset to image data row_00 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $80 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunnernner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $c0 ; $13 - Loderunner Fall Le
                            .byte $80 ; $14 - Loderunner Fall Ri
                            .byte $80 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $40 ; $35 - Enemy Fall Ri
                            .byte $40 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_01_B_01   = *       ; offset to image data row_01 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $a8 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $ff ; $04 - Level Tile Pole
                            .byte $aa ; $05 - Level Tile Wall Trap
                            .byte $c0 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $14 ; $08 - Level Tile Enemy
                            .byte $07 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $38 ; $0b - Loderunner Run Le 00
                            .byte $38 ; $0c - Loderunner Run Le 01
                            .byte $38 ; $0d - Loderunner Run Le 02
                            .byte $0c ; $0e - Loderunner Ladder 00
                            .byte $07 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunnernner Run Ri 00 = Level Tile Loderunner
                            .byte $07 ; $10 - Loderunner Run Ri 00
                            .byte $07 ; $11 - Loderunner Run Ri 01
                            .byte $8c ; $12 - Loderunner Run Ri 02
                            .byte $6e ; $13 - Loderunner Fall Le
                            .byte $dd ; $14 - Loderunner Fall Ri
                            .byte $61 ; $15 - Loderunner Pole Ri 00
                            .byte $06 ; $16 - Loderunner Pole Ri 01
                            .byte $18 ; $17 - Loderunner Pole Ri 02
                            .byte $61 ; $18 - Loderunner Pole Le 00
                            .byte $18 ; $19 - Loderunner Pole Le 01
                            .byte $06 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $a8 ; $1f - Shoot Melt Ground 00
                            .byte $14 ; $20 - Shoot Melt Ground 01
                            .byte $04 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $1c ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $05 ; $28 - Enemy Run Ri 00
                            .byte $05 ; $29 - Enemy Run Ri 01
                            .byte $05 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $14 ; $2b - Enemy Run Le 01
                            .byte $14 ; $2c - Enemy Run Le 02
                            .byte $41 ; $2d - Enemy Pole Ri 00
                            .byte $04 ; $2e - Enemy Pole Ri 01
                            .byte $10 ; $2f - Enemy Pole Ri 02
                            .byte $41 ; $30 - Enemy Pole Le 00
                            .byte $10 ; $31 - Enemy Pole Le 01
                            .byte $04 ; $32 - Enemy Pole Le 02
                            .byte $04 ; $33 - Enemy Ladder  00
                            .byte $84 ; $34 - Enemy Ladder  01
                            .byte $44 ; $35 - Enemy Fall Ri
                            .byte $44 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_01_B_02   = *       ; offset to image data row_01 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $c0 ; $04 - Level Tile Pole
                            .byte $80 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $40 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $c0 ; $13 - Loderunner Fall Le
                            .byte $80 ; $14 - Loderunner Fall Ri
                            .byte $80 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $40 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $40 ; $35 - Enemy Fall Ri
                            .byte $40 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_02_B_01   = *       ; offset to image data row_02 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $a8 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $ff ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $ff ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $14 ; $08 - Level Tile Enemy
                            .byte $07 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $38 ; $0b - Loderunner Run Le 00
                            .byte $38 ; $0c - Loderunner Run Le 01
                            .byte $38 ; $0d - Loderunner Run Le 02
                            .byte $0f ; $0e - Loderunner Ladder 00
                            .byte $07 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $07 ; $10 - Loderunner Run Ri 00
                            .byte $07 ; $11 - Loderunner Run Ri 01
                            .byte $fc ; $12 - Loderunner Run Ri 02
                            .byte $6e ; $13 - Loderunner Fall Le
                            .byte $dd ; $14 - Loderunner Fall Ri
                            .byte $6d ; $15 - Loderunner Pole Ri 00
                            .byte $1e ; $16 - Loderunner Pole Ri 01
                            .byte $1e ; $17 - Loderunner Pole Ri 02
                            .byte $6d ; $18 - Loderunner Pole Le 00
                            .byte $1e ; $19 - Loderunner Pole Le 01
                            .byte $1e ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $a8 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $14 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $1c ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $05 ; $28 - Enemy Run Ri 00
                            .byte $05 ; $29 - Enemy Run Ri 01
                            .byte $05 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $14 ; $2b - Enemy Run Le 01
                            .byte $14 ; $2c - Enemy Run Le 02
                            .byte $45 ; $2d - Enemy Pole Ri 00
                            .byte $14 ; $2e - Enemy Pole Ri 01
                            .byte $14 ; $2f - Enemy Pole Ri 02
                            .byte $51 ; $30 - Enemy Pole Le 00
                            .byte $14 ; $31 - Enemy Pole Le 01
                            .byte $14 ; $32 - Enemy Pole Le 02
                            .byte $05 ; $33 - Enemy Ladder  00
                            .byte $d4 ; $34 - Enemy Ladder  01
                            .byte $44 ; $35 - Enemy Fall Ri
                            .byte $44 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_02_B_02   = *       ; offset to image data row_02 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $c0 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $c0 ; $13 - Loderunner Fall Le
                            .byte $80 ; $14 - Loderunner Fall Ri
                            .byte $80 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $40 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $40 ; $35 - Enemy Fall Ri
                            .byte $40 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_03_B_01   = *       ; offset to image data row_03 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $a8 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $3f ; $05 - Level Tile Wall Trap
                            .byte $c3 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $04 ; $08 - Level Tile Enemy
                            .byte $0e ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $1c ; $0b - Loderunner Run Le 00
                            .byte $18 ; $0c - Loderunner Run Le 01
                            .byte $18 ; $0d - Loderunner Run Le 02
                            .byte $4e ; $0e - Loderunner Ladder 00
                            .byte $03 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $06 ; $10 - Loderunner Run Ri 00
                            .byte $06 ; $11 - Loderunner Run Ri 01
                            .byte $1c ; $12 - Loderunner Run Ri 02
                            .byte $3f ; $13 - Loderunner Fall Le
                            .byte $7f ; $14 - Loderunner Fall Ri
                            .byte $6f ; $15 - Loderunner Pole Ri 00
                            .byte $1c ; $16 - Loderunner Pole Ri 01
                            .byte $0e ; $17 - Loderunner Pole Ri 02
                            .byte $3d ; $18 - Loderunner Pole Le 00
                            .byte $0e ; $19 - Loderunner Pole Le 01
                            .byte $dc ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $08 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $08 ; $1e - Shoot Spark 03
                            .byte $a8 ; $1f - Shoot Melt Ground 00
                            .byte $a8 ; $20 - Shoot Melt Ground 01
                            .byte $94 ; $21 - Shoot Melt Ground 02
                            .byte $04 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $18 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $08 ; $27 - Shoot Melt 01
                            .byte $04 ; $28 - Enemy Run Ri 00
                            .byte $04 ; $29 - Enemy Run Ri 01
                            .byte $04 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $04 ; $2b - Enemy Run Le 01
                            .byte $04 ; $2c - Enemy Run Le 02
                            .byte $45 ; $2d - Enemy Pole Ri 00
                            .byte $14 ; $2e - Enemy Pole Ri 01
                            .byte $04 ; $2f - Enemy Pole Ri 02
                            .byte $51 ; $30 - Enemy Pole Le 00
                            .byte $14 ; $31 - Enemy Pole Le 01
                            .byte $10 ; $32 - Enemy Pole Le 02
                            .byte $44 ; $33 - Enemy Ladder  00
                            .byte $14 ; $34 - Enemy Ladder  01
                            .byte $15 ; $35 - Enemy Fall Ri
                            .byte $15 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $55 ; $3b - Digit 0
                            .byte $14 ; $3c - Digit 1
                            .byte $55 ; $3d - Digit 2
                            .byte $55 ; $3e - Digit 3
                            .byte $51 ; $3f - Digit 4
                            .byte $55 ; $40 - Digit 5
                            .byte $55 ; $41 - Digit 6
                            .byte $55 ; $42 - Digit 7
                            .byte $15 ; $43 - Digit 8
                            .byte $55 ; $44 - Digit 9
                            .byte $2a ; $45 - Char A
                            .byte $a8 ; $46 - Char B
                            .byte $aa ; $47 - Char C
                            .byte $a8 ; $48 - Char D
                            .byte $aa ; $49 - Char E
                            .byte $aa ; $4a - Char F
                            .byte $aa ; $4b - Char G
                            .byte $82 ; $4c - Char H
                            .byte $20 ; $4d - Char I
                            .byte $08 ; $4e - Char J
                            .byte $82 ; $4f - Char K
                            .byte $80 ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $82 ; $52 - Char N
                            .byte $aa ; $53 - Char O
                            .byte $aa ; $54 - Char P
                            .byte $aa ; $55 - Char Q
                            .byte $aa ; $56 - Char R
                            .byte $aa ; $57 - Char S
                            .byte $aa ; $58 - Char T
                            .byte $82 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $8a ; $5d - Char Y
                            .byte $aa ; $5e - Char Z
                            .byte $80 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $28 ; $61 - Special Char  (
                            .byte $28 ; $62 - Special Char  )
                            .byte $02 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $02 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_03_B_02   = *       ; offset to image data row_03 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $80 ; $12 - Loderunner Run Ri 02
                            .byte $80 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $c0 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $40 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $80 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_04_B_01   = *       ; offset to image data row_04 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $00 ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $0c ; $05 - Level Tile Wall Trap
                            .byte $03 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $15 ; $08 - Level Tile Enemy
                            .byte $37 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $3b ; $0b - Loderunner Run Le 00
                            .byte $1c ; $0c - Loderunner Run Le 01
                            .byte $5e ; $0d - Loderunner Run Le 02
                            .byte $7e ; $0e - Loderunner Ladder 00
                            .byte $0f ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $0e ; $10 - Loderunner Run Ri 00
                            .byte $1e ; $11 - Loderunner Run Ri 01
                            .byte $1f ; $12 - Loderunner Run Ri 02
                            .byte $06 ; $13 - Loderunner Fall Le
                            .byte $18 ; $14 - Loderunner Fall Ri
                            .byte $3c ; $15 - Loderunner Pole Ri 00
                            .byte $78 ; $16 - Loderunner Pole Ri 01
                            .byte $07 ; $17 - Loderunner Pole Ri 02
                            .byte $0f ; $18 - Loderunner Pole Le 00
                            .byte $07 ; $19 - Loderunner Pole Le 01
                            .byte $78 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $00 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $14 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $7e ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $15 ; $28 - Enemy Run Ri 00
                            .byte $14 ; $29 - Enemy Run Ri 01
                            .byte $15 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $05 ; $2b - Enemy Run Le 01
                            .byte $15 ; $2c - Enemy Run Le 02
                            .byte $14 ; $2d - Enemy Pole Ri 00
                            .byte $50 ; $2e - Enemy Pole Ri 01
                            .byte $05 ; $2f - Enemy Pole Ri 02
                            .byte $14 ; $30 - Enemy Pole Le 00
                            .byte $05 ; $31 - Enemy Pole Le 01
                            .byte $50 ; $32 - Enemy Pole Le 02
                            .byte $54 ; $33 - Enemy Ladder  00
                            .byte $15 ; $34 - Enemy Ladder  01
                            .byte $04 ; $35 - Enemy Fall Ri
                            .byte $04 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $41 ; $3b - Digit 0
                            .byte $14 ; $3c - Digit 1
                            .byte $41 ; $3d - Digit 2
                            .byte $41 ; $3e - Digit 3
                            .byte $51 ; $3f - Digit 4
                            .byte $40 ; $40 - Digit 5
                            .byte $41 ; $41 - Digit 6
                            .byte $05 ; $42 - Digit 7
                            .byte $11 ; $43 - Digit 8
                            .byte $41 ; $44 - Digit 9
                            .byte $22 ; $45 - Char A
                            .byte $88 ; $46 - Char B
                            .byte $82 ; $47 - Char C
                            .byte $82 ; $48 - Char D
                            .byte $a0 ; $49 - Char E
                            .byte $a0 ; $4a - Char F
                            .byte $82 ; $4b - Char G
                            .byte $82 ; $4c - Char H
                            .byte $20 ; $4d - Char I
                            .byte $08 ; $4e - Char J
                            .byte $8a ; $4f - Char K
                            .byte $80 ; $50 - Char L
                            .byte $a2 ; $51 - Char M
                            .byte $82 ; $52 - Char N
                            .byte $8a ; $53 - Char O
                            .byte $82 ; $54 - Char P
                            .byte $8a ; $55 - Char Q
                            .byte $82 ; $56 - Char R
                            .byte $82 ; $57 - Char S
                            .byte $20 ; $58 - Char T
                            .byte $82 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $8a ; $5d - Char Y
                            .byte $82 ; $5e - Char Z
                            .byte $a0 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $28 ; $61 - Special Char  (
                            .byte $28 ; $62 - Special Char  )
                            .byte $02 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $0a ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_04_B_02   = *       ; offset to image data row_04 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $00 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $c0 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $80 ; $11 - Loderunner Run Ri 01
                            .byte $80 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $80 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $80 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $00 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $80 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_05_B_01   = *       ; offset to image data row_05 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $0c ; $05 - Level Tile Wall Trap
                            .byte $03 ; $06 - Level Tile Ladder Secret
                            .byte $ff ; $07 - Level Tile Gold
                            .byte $44 ; $08 - Level Tile Enemy
                            .byte $6c ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $cd ; $0b - Loderunner Run Le 00
                            .byte $3e ; $0c - Loderunner Run Le 01
                            .byte $7b ; $0d - Loderunner Run Le 02
                            .byte $0e ; $0e - Loderunner Ladder 00
                            .byte $5b ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $1f ; $10 - Loderunner Run Ri 00
                            .byte $37 ; $11 - Loderunner Run Ri 01
                            .byte $1c ; $12 - Loderunner Run Ri 02
                            .byte $06 ; $13 - Loderunner Fall Le
                            .byte $18 ; $14 - Loderunner Fall Ri
                            .byte $18 ; $15 - Loderunner Pole Ri 00
                            .byte $d8 ; $16 - Loderunner Pole Ri 01
                            .byte $06 ; $17 - Loderunner Pole Ri 02
                            .byte $06 ; $18 - Loderunner Pole Le 00
                            .byte $06 ; $19 - Loderunner Pole Le 01
                            .byte $18 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $80 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $15 ; $22 - Shoot Melt Ground 03
                            .byte $04 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $5b ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $44 ; $28 - Enemy Run Ri 00
                            .byte $15 ; $29 - Enemy Run Ri 01
                            .byte $45 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $15 ; $2b - Enemy Run Le 01
                            .byte $14 ; $2c - Enemy Run Le 02
                            .byte $10 ; $2d - Enemy Pole Ri 00
                            .byte $50 ; $2e - Enemy Pole Ri 01
                            .byte $04 ; $2f - Enemy Pole Ri 02
                            .byte $04 ; $30 - Enemy Pole Le 00
                            .byte $05 ; $31 - Enemy Pole Le 01
                            .byte $10 ; $32 - Enemy Pole Le 02
                            .byte $04 ; $33 - Enemy Ladder  00
                            .byte $14 ; $34 - Enemy Ladder  01
                            .byte $04 ; $35 - Enemy Fall Ri
                            .byte $04 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $41 ; $3b - Digit 0
                            .byte $04 ; $3c - Digit 1
                            .byte $01 ; $3d - Digit 2
                            .byte $01 ; $3e - Digit 3
                            .byte $51 ; $3f - Digit 4
                            .byte $40 ; $40 - Digit 5
                            .byte $40 ; $41 - Digit 6
                            .byte $05 ; $42 - Digit 7
                            .byte $11 ; $43 - Digit 8
                            .byte $41 ; $44 - Digit 9
                            .byte $22 ; $45 - Char A
                            .byte $88 ; $46 - Char B
                            .byte $80 ; $47 - Char C
                            .byte $82 ; $48 - Char D
                            .byte $a0 ; $49 - Char E
                            .byte $a0 ; $4a - Char F
                            .byte $80 ; $4b - Char G
                            .byte $82 ; $4c - Char H
                            .byte $20 ; $4d - Char I
                            .byte $08 ; $4e - Char J
                            .byte $88 ; $4f - Char K
                            .byte $80 ; $50 - Char L
                            .byte $aa ; $51 - Char M
                            .byte $a2 ; $52 - Char N
                            .byte $8a ; $53 - Char O
                            .byte $82 ; $54 - Char P
                            .byte $8a ; $55 - Char Q
                            .byte $82 ; $56 - Char R
                            .byte $80 ; $57 - Char S
                            .byte $20 ; $58 - Char T
                            .byte $82 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $8a ; $5d - Char Y
                            .byte $82 ; $5e - Char Z
                            .byte $28 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $a0 ; $61 - Special Char  (
                            .byte $0a ; $62 - Special Char  )
                            .byte $08 ; $63 - Special Char  /
                            .byte $aa ; $64 - Special Char  -
                            .byte $28 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_05_B_02   = *       ; offset to image data row_05 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $40 ; $08 - Level Tile Enemy
                            .byte $c0 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $80 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $40 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $80 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $c0 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $80 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $40 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $80 ; $27 - Shoot Melt 01
                            .byte $40 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $40 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $80 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_06_B_01   = *       ; offset to image data row_06 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $0c ; $05 - Level Tile Wall Trap
                            .byte $03 ; $06 - Level Tile Ladder Secret
                            .byte $eb ; $07 - Level Tile Gold
                            .byte $06 ; $08 - Level Tile Enemy
                            .byte $0c ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $0c ; $0b - Loderunner Run Le 00
                            .byte $de ; $0c - Loderunner Run Le 01
                            .byte $18 ; $0d - Loderunner Run Le 02
                            .byte $0e ; $0e - Loderunner Ladder 00
                            .byte $43 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $1e ; $10 - Loderunner Run Ri 00
                            .byte $06 ; $11 - Loderunner Run Ri 01
                            .byte $1c ; $12 - Loderunner Run Ri 02
                            .byte $1e ; $13 - Loderunner Fall Le
                            .byte $1e ; $14 - Loderunner Fall Ri
                            .byte $18 ; $15 - Loderunner Pole Ri 00
                            .byte $18 ; $16 - Loderunner Pole Ri 01
                            .byte $06 ; $17 - Loderunner Pole Ri 02
                            .byte $06 ; $18 - Loderunner Pole Le 00
                            .byte $06 ; $19 - Loderunner Pole Le 01
                            .byte $18 ; $1a - Loderunner Pole Le 02
                            .byte $08 ; $1b - Shoot Spark 00
                            .byte $80 ; $1c - Shoot Spark 01
                            .byte $88 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $05 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $18 ; $25 - Fire Ri
                            .byte $08 ; $26 - Shoot Melt 00
                            .byte $a0 ; $27 - Shoot Melt 01
                            .byte $0c ; $28 - Enemy Run Ri 00
                            .byte $06 ; $29 - Enemy Run Ri 01
                            .byte $06 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $4c ; $2b - Enemy Run Le 01
                            .byte $0c ; $2c - Enemy Run Le 02
                            .byte $10 ; $2d - Enemy Pole Ri 00
                            .byte $10 ; $2e - Enemy Pole Ri 01
                            .byte $04 ; $2f - Enemy Pole Ri 02
                            .byte $04 ; $30 - Enemy Pole Le 00
                            .byte $04 ; $31 - Enemy Pole Le 01
                            .byte $10 ; $32 - Enemy Pole Le 02
                            .byte $0e ; $33 - Enemy Ladder  00
                            .byte $1c ; $34 - Enemy Ladder  01
                            .byte $0f ; $35 - Enemy Fall Ri
                            .byte $1e ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $41 ; $3b - Digit 0
                            .byte $04 ; $3c - Digit 1
                            .byte $55 ; $3d - Digit 2
                            .byte $15 ; $3e - Digit 3
                            .byte $55 ; $3f - Digit 4
                            .byte $55 ; $40 - Digit 5
                            .byte $40 ; $41 - Digit 6
                            .byte $05 ; $42 - Digit 7
                            .byte $55 ; $43 - Digit 8
                            .byte $55 ; $44 - Digit 9
                            .byte $aa ; $45 - Char A
                            .byte $aa ; $46 - Char B
                            .byte $80 ; $47 - Char C
                            .byte $82 ; $48 - Char D
                            .byte $a8 ; $49 - Char E
                            .byte $a8 ; $4a - Char F
                            .byte $80 ; $4b - Char G
                            .byte $aa ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $0a ; $4e - Char J
                            .byte $a8 ; $4f - Char K
                            .byte $80 ; $50 - Char L
                            .byte $aa ; $51 - Char M
                            .byte $aa ; $52 - Char N
                            .byte $82 ; $53 - Char O
                            .byte $aa ; $54 - Char P
                            .byte $82 ; $55 - Char Q
                            .byte $aa ; $56 - Char R
                            .byte $aa ; $57 - Char S
                            .byte $20 ; $58 - Char T
                            .byte $82 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $28 ; $5c - Char X
                            .byte $aa ; $5d - Char Y
                            .byte $08 ; $5e - Char Z
                            .byte $0a ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $a0 ; $61 - Special Char  (
                            .byte $0a ; $62 - Special Char  )
                            .byte $08 ; $63 - Special Char  /
                            .byte $aa ; $64 - Special Char  -
                            .byte $a0 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_06_B_02   = *       ; offset to image data row_06 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $c0 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $00 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $40 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $40 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $80 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_07_B_01   = *       ; offset to image data row_07 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $ff ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $0c ; $05 - Level Tile Wall Trap
                            .byte $c3 ; $06 - Level Tile Ladder Secret
                            .byte $eb ; $07 - Level Tile Gold
                            .byte $15 ; $08 - Level Tile Enemy
                            .byte $0e ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $1c ; $0b - Loderunner Run Le 00
                            .byte $38 ; $0c - Loderunner Run Le 01
                            .byte $3c ; $0d - Loderunner Run Le 02
                            .byte $1b ; $0e - Loderunner Ladder 00
                            .byte $07 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $07 ; $10 - Loderunner Run Ri 00
                            .byte $0f ; $11 - Loderunner Run Ri 01
                            .byte $36 ; $12 - Loderunner Run Ri 02
                            .byte $36 ; $13 - Loderunner Fall Le
                            .byte $1b ; $14 - Loderunner Fall Ri
                            .byte $78 ; $15 - Loderunner Pole Ri 00
                            .byte $38 ; $16 - Loderunner Pole Ri 01
                            .byte $0e ; $17 - Loderunner Pole Ri 02
                            .byte $07 ; $18 - Loderunner Pole Le 00
                            .byte $07 ; $19 - Loderunner Pole Le 01
                            .byte $1c ; $1a - Loderunner Pole Le 02
                            .byte $02 ; $1b - Shoot Spark 00
                            .byte $20 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $8a ; $22 - Shoot Melt Ground 03
                            .byte $95 ; $23 - Shoot Melt Ground 04
                            .byte $04 ; $24 - Shoot Melt Ground 05
                            .byte $1c ; $25 - Fire Ri
                            .byte $22 ; $26 - Shoot Melt 00
                            .byte $40 ; $27 - Shoot Melt 01
                            .byte $0e ; $28 - Enemy Run Ri 00
                            .byte $07 ; $29 - Enemy Run Ri 01
                            .byte $0f ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $1c ; $2b - Enemy Run Le 01
                            .byte $1e ; $2c - Enemy Run Le 02
                            .byte $78 ; $2d - Enemy Pole Ri 00
                            .byte $38 ; $2e - Enemy Pole Ri 01
                            .byte $0e ; $2f - Enemy Pole Ri 02
                            .byte $0f ; $30 - Enemy Pole Le 00
                            .byte $0e ; $31 - Enemy Pole Le 01
                            .byte $38 ; $32 - Enemy Pole Le 02
                            .byte $1b ; $33 - Enemy Ladder  00
                            .byte $36 ; $34 - Enemy Ladder  01
                            .byte $0d ; $35 - Enemy Fall Ri
                            .byte $36 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $14 ; $3a - Enemy Rebirth 01
                            .byte $45 ; $3b - Digit 0
                            .byte $04 ; $3c - Digit 1
                            .byte $40 ; $3d - Digit 2
                            .byte $01 ; $3e - Digit 3
                            .byte $01 ; $3f - Digit 4
                            .byte $05 ; $40 - Digit 5
                            .byte $55 ; $41 - Digit 6
                            .byte $14 ; $42 - Digit 7
                            .byte $41 ; $43 - Digit 8
                            .byte $05 ; $44 - Digit 9
                            .byte $82 ; $45 - Char A
                            .byte $82 ; $46 - Char B
                            .byte $a0 ; $47 - Char C
                            .byte $a2 ; $48 - Char D
                            .byte $80 ; $49 - Char E
                            .byte $80 ; $4a - Char F
                            .byte $8a ; $4b - Char G
                            .byte $a2 ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $0a ; $4e - Char J
                            .byte $aa ; $4f - Char K
                            .byte $a0 ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $aa ; $52 - Char N
                            .byte $82 ; $53 - Char O
                            .byte $a0 ; $54 - Char P
                            .byte $82 ; $55 - Char Q
                            .byte $a8 ; $56 - Char R
                            .byte $0a ; $57 - Char S
                            .byte $28 ; $58 - Char T
                            .byte $a2 ; $59 - Char U
                            .byte $a2 ; $5a - Char V
                            .byte $aa ; $5b - Char W
                            .byte $28 ; $5c - Char X
                            .byte $28 ; $5d - Char Y
                            .byte $28 ; $5e - Char Z
                            .byte $0a ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $a0 ; $61 - Special Char  (
                            .byte $0a ; $62 - Special Char  )
                            .byte $20 ; $63 - Special Char  /
                            .byte $aa ; $64 - Special Char  -
                            .byte $a0 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_07_B_02   = *       ; offset to image data row_07 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $00 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $80 ; $18 - Loderunner Pole Le 00
                            .byte $00 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $40 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $80 ; $1d - Shoot Spark 02
                            .byte $80 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $80 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $00 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $80 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $80 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_08_B_01   = *       ; offset to image data row_08 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $aa ; $05 - Level Tile Wall Trap
                            .byte $ff ; $06 - Level Tile Ladder Secret
                            .byte $eb ; $07 - Level Tile Gold
                            .byte $15 ; $08 - Level Tile Enemy
                            .byte $7b ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $37 ; $0b - Loderunner Run Le 00
                            .byte $3c ; $0c - Loderunner Run Le 01
                            .byte $66 ; $0d - Loderunner Run Le 02
                            .byte $1b ; $0e - Loderunner Ladder 00
                            .byte $0d ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $0f ; $10 - Loderunner Run Ri 00
                            .byte $19 ; $11 - Loderunner Run Ri 01
                            .byte $76 ; $12 - Loderunner Run Ri 02
                            .byte $36 ; $13 - Loderunner Fall Le
                            .byte $1b ; $14 - Loderunner Fall Ri
                            .byte $d8 ; $15 - Loderunner Pole Ri 00
                            .byte $6c ; $16 - Loderunner Pole Ri 01
                            .byte $1b ; $17 - Loderunner Pole Ri 02
                            .byte $06 ; $18 - Loderunner Pole Le 00
                            .byte $0d ; $19 - Loderunner Pole Le 01
                            .byte $36 ; $1a - Loderunner Pole Le 02
                            .byte $20 ; $1b - Shoot Spark 00
                            .byte $0a ; $1c - Shoot Spark 01
                            .byte $80 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $8a ; $22 - Shoot Melt Ground 03
                            .byte $80 ; $23 - Shoot Melt Ground 04
                            .byte $14 ; $24 - Shoot Melt Ground 05
                            .byte $36 ; $25 - Fire Ri
                            .byte $48 ; $26 - Shoot Melt 00
                            .byte $4a ; $27 - Shoot Melt 01
                            .byte $7b ; $28 - Enemy Run Ri 00
                            .byte $0f ; $29 - Enemy Run Ri 01
                            .byte $19 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $1e ; $2b - Enemy Run Le 01
                            .byte $33 ; $2c - Enemy Run Le 02
                            .byte $d8 ; $2d - Enemy Pole Ri 00
                            .byte $6c ; $2e - Enemy Pole Ri 01
                            .byte $1b ; $2f - Enemy Pole Ri 02
                            .byte $0d ; $30 - Enemy Pole Le 00
                            .byte $1b ; $31 - Enemy Pole Le 01
                            .byte $6c ; $32 - Enemy Pole Le 02
                            .byte $1b ; $33 - Enemy Ladder  00
                            .byte $76 ; $34 - Enemy Ladder  01
                            .byte $0d ; $35 - Enemy Fall Ri
                            .byte $36 ; $36 - Enemy Fall Le
                            .byte $80 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $14 ; $39 - Enemy Rebirth 00
                            .byte $55 ; $3a - Enemy Rebirth 01
                            .byte $45 ; $3b - Digit 0
                            .byte $04 ; $3c - Digit 1
                            .byte $40 ; $3d - Digit 2
                            .byte $01 ; $3e - Digit 3
                            .byte $01 ; $3f - Digit 4
                            .byte $05 ; $40 - Digit 5
                            .byte $45 ; $41 - Digit 6
                            .byte $10 ; $42 - Digit 7
                            .byte $41 ; $43 - Digit 8
                            .byte $05 ; $44 - Digit 9
                            .byte $82 ; $45 - Char A
                            .byte $82 ; $46 - Char B
                            .byte $a0 ; $47 - Char C
                            .byte $a2 ; $48 - Char D
                            .byte $80 ; $49 - Char E
                            .byte $80 ; $4a - Char F
                            .byte $8a ; $4b - Char G
                            .byte $a2 ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $0a ; $4e - Char J
                            .byte $a2 ; $4f - Char K
                            .byte $a0 ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $8a ; $52 - Char N
                            .byte $82 ; $53 - Char O
                            .byte $a0 ; $54 - Char P
                            .byte $82 ; $55 - Char Q
                            .byte $a8 ; $56 - Char R
                            .byte $0a ; $57 - Char S
                            .byte $28 ; $58 - Char T
                            .byte $a2 ; $59 - Char U
                            .byte $aa ; $5a - Char V
                            .byte $aa ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $28 ; $5d - Char Y
                            .byte $80 ; $5e - Char Z
                            .byte $28 ; $5f - Special Char  >
                            .byte $28 ; $60 - Special Char  .
                            .byte $a0 ; $61 - Special Char  (
                            .byte $0a ; $62 - Special Char  )
                            .byte $20 ; $63 - Special Char  /
                            .byte $aa ; $64 - Special Char  -
                            .byte $28 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_08_B_02   = *       ; offset to image data row_08 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $80 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $40 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $80 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $80 ; $0e - Loderunner Ladder 00
                            .byte $80 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $80 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $c0 ; $18 - Loderunner Pole Le 00
                            .byte $80 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $40 ; $1b - Shoot Spark 00
                            .byte $40 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $80 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $80 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $00 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $80 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $80 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $80 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $80 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $80 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_09_B_01   = *       ; offset to image data row_09 byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $8a ; $01 - Level Tile Wall Weak
                            .byte $aa ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $aa ; $05 - Level Tile Wall Trap
                            .byte $c0 ; $06 - Level Tile Ladder Secret
                            .byte $ff ; $07 - Level Tile Gold
                            .byte $10 ; $08 - Level Tile Enemy
                            .byte $03 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $30 ; $0b - Loderunner Run Le 00
                            .byte $0e ; $0c - Loderunner Run Le 01
                            .byte $63 ; $0d - Loderunner Run Le 02
                            .byte $18 ; $0e - Loderunner Ladder 00
                            .byte $0d ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $1c ; $10 - Loderunner Run Ri 00
                            .byte $31 ; $11 - Loderunner Run Ri 01
                            .byte $06 ; $12 - Loderunner Run Ri 02
                            .byte $36 ; $13 - Loderunner Fall Le
                            .byte $1b ; $14 - Loderunner Fall Ri
                            .byte $d8 ; $15 - Loderunner Pole Ri 00
                            .byte $6c ; $16 - Loderunner Pole Ri 01
                            .byte $1b ; $17 - Loderunner Pole Ri 02
                            .byte $06 ; $18 - Loderunner Pole Le 00
                            .byte $0d ; $19 - Loderunner Pole Le 01
                            .byte $36 ; $1a - Loderunner Pole Le 02
                            .byte $09 ; $1b - Shoot Spark 00
                            .byte $21 ; $1c - Shoot Spark 01
                            .byte $20 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $8a ; $1f - Shoot Melt Ground 00
                            .byte $8a ; $20 - Shoot Melt Ground 01
                            .byte $8a ; $21 - Shoot Melt Ground 02
                            .byte $8a ; $22 - Shoot Melt Ground 03
                            .byte $8a ; $23 - Shoot Melt Ground 04
                            .byte $15 ; $24 - Shoot Melt Ground 05
                            .byte $36 ; $25 - Fire Ri
                            .byte $50 ; $26 - Shoot Melt 00
                            .byte $11 ; $27 - Shoot Melt 01
                            .byte $03 ; $28 - Enemy Run Ri 00
                            .byte $1c ; $29 - Enemy Run Ri 01
                            .byte $31 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $07 ; $2b - Enemy Run Le 01
                            .byte $31 ; $2c - Enemy Run Le 02
                            .byte $d8 ; $2d - Enemy Pole Ri 00
                            .byte $6c ; $2e - Enemy Pole Ri 01
                            .byte $1b ; $2f - Enemy Pole Ri 02
                            .byte $0d ; $30 - Enemy Pole Le 00
                            .byte $1b ; $31 - Enemy Pole Le 01
                            .byte $6c ; $32 - Enemy Pole Le 02
                            .byte $18 ; $33 - Enemy Ladder  00
                            .byte $06 ; $34 - Enemy Ladder  01
                            .byte $0d ; $35 - Enemy Fall Ri
                            .byte $36 ; $36 - Enemy Fall Le
                            .byte $80 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $55 ; $39 - Enemy Rebirth 00
                            .byte $55 ; $3a - Enemy Rebirth 01
                            .byte $45 ; $3b - Digit 0
                            .byte $15 ; $3c - Digit 1
                            .byte $45 ; $3d - Digit 2
                            .byte $41 ; $3e - Digit 3
                            .byte $01 ; $3f - Digit 4
                            .byte $05 ; $40 - Digit 5
                            .byte $45 ; $41 - Digit 6
                            .byte $10 ; $42 - Digit 7
                            .byte $41 ; $43 - Digit 8
                            .byte $05 ; $44 - Digit 9
                            .byte $8a ; $45 - Char A
                            .byte $82 ; $46 - Char B
                            .byte $a2 ; $47 - Char C
                            .byte $a2 ; $48 - Char D
                            .byte $80 ; $49 - Char E
                            .byte $80 ; $4a - Char F
                            .byte $82 ; $4b - Char G
                            .byte $a2 ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $8a ; $4e - Char J
                            .byte $a2 ; $4f - Char K
                            .byte $a0 ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $82 ; $52 - Char N
                            .byte $82 ; $53 - Char O
                            .byte $a0 ; $54 - Char P
                            .byte $88 ; $55 - Char Q
                            .byte $a2 ; $56 - Char R
                            .byte $8a ; $57 - Char S
                            .byte $28 ; $58 - Char T
                            .byte $a2 ; $59 - Char U
                            .byte $28 ; $5a - Char V
                            .byte $a2 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $28 ; $5d - Char Y
                            .byte $8a ; $5e - Char Z
                            .byte $a0 ; $5f - Special Char  >
                            .byte $28 ; $60 - Special Char  .
                            .byte $28 ; $61 - Special Char  (
                            .byte $28 ; $62 - Special Char  )
                            .byte $80 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $0a ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_09_B_02   = *       ; offset to image data row_09 byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $80 ; $01 - Level Tile Wall Weak
                            .byte $80 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $80 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $80 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $80 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $c0 ; $18 - Loderunner Pole Le 00
                            .byte $80 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $40 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $80 ; $1f - Shoot Melt Ground 00
                            .byte $80 ; $20 - Shoot Melt Ground 01
                            .byte $80 ; $21 - Shoot Melt Ground 02
                            .byte $80 ; $22 - Shoot Melt Ground 03
                            .byte $80 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $80 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $80 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $80 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $80 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $80 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $80 ; $37 - Close Hole 00
                            .byte $80 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_0a_B_01   = *       ; offset to image data row_0a byte 1-2
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $00 ; $01 - Level Tile Wall Weak
                            .byte $00 ; $02 - Level Tile Wall Hard
                            .byte $c3 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $c0 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $10 ; $08 - Level Tile Enemy
                            .byte $03 ; $09 - Level Tile Loderunner
                            .byte $ff ; $0a - Blank Reverse
                            .byte $30 ; $0b - Loderunner Run Le 00
                            .byte $0c ; $0c - Loderunner Run Le 01
                            .byte $03 ; $0d - Loderunner Run Le 02
                            .byte $38 ; $0e - Loderunner Ladder 00
                            .byte $0d ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $0c ; $10 - Loderunner Run Ri 00
                            .byte $30 ; $11 - Loderunner Run Ri 01
                            .byte $07 ; $12 - Loderunner Run Ri 02
                            .byte $06 ; $13 - Loderunner Fall Le
                            .byte $18 ; $14 - Loderunner Fall Ri
                            .byte $b0 ; $15 - Loderunner Pole Ri 00
                            .byte $6c ; $16 - Loderunner Pole Ri 01
                            .byte $1b ; $17 - Loderunner Pole Ri 02
                            .byte $03 ; $18 - Loderunner Pole Le 00
                            .byte $0d ; $19 - Loderunner Pole Le 01
                            .byte $36 ; $1a - Loderunner Pole Le 02
                            .byte $01 ; $1b - Shoot Spark 00
                            .byte $09 ; $1c - Shoot Spark 01
                            .byte $02 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $00 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $36 ; $25 - Fire Ri
                            .byte $10 ; $26 - Shoot Melt 00
                            .byte $11 ; $27 - Shoot Melt 01
                            .byte $03 ; $28 - Enemy Run Ri 00
                            .byte $0c ; $29 - Enemy Run Ri 01
                            .byte $30 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $06 ; $2b - Enemy Run Le 01
                            .byte $01 ; $2c - Enemy Run Le 02
                            .byte $b0 ; $2d - Enemy Pole Ri 00
                            .byte $0c ; $2e - Enemy Pole Ri 01
                            .byte $1b ; $2f - Enemy Pole Ri 02
                            .byte $06 ; $30 - Enemy Pole Le 00
                            .byte $1b ; $31 - Enemy Pole Le 01
                            .byte $6c ; $32 - Enemy Pole Le 02
                            .byte $38 ; $33 - Enemy Ladder  00
                            .byte $07 ; $34 - Enemy Ladder  01
                            .byte $0c ; $35 - Enemy Fall Ri
                            .byte $06 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $55 ; $3b - Digit 0
                            .byte $15 ; $3c - Digit 1
                            .byte $55 ; $3d - Digit 2
                            .byte $55 ; $3e - Digit 3
                            .byte $01 ; $3f - Digit 4
                            .byte $55 ; $40 - Digit 5
                            .byte $55 ; $41 - Digit 6
                            .byte $10 ; $42 - Digit 7
                            .byte $55 ; $43 - Digit 8
                            .byte $05 ; $44 - Digit 9
                            .byte $8a ; $45 - Char A
                            .byte $aa ; $46 - Char B
                            .byte $aa ; $47 - Char C
                            .byte $a8 ; $48 - Char D
                            .byte $aa ; $49 - Char E
                            .byte $80 ; $4a - Char F
                            .byte $aa ; $4b - Char G
                            .byte $a2 ; $4c - Char H
                            .byte $28 ; $4d - Char I
                            .byte $aa ; $4e - Char J
                            .byte $a2 ; $4f - Char K
                            .byte $aa ; $50 - Char L
                            .byte $82 ; $51 - Char M
                            .byte $82 ; $52 - Char N
                            .byte $aa ; $53 - Char O
                            .byte $a0 ; $54 - Char P
                            .byte $a2 ; $55 - Char Q
                            .byte $a2 ; $56 - Char R
                            .byte $aa ; $57 - Char S
                            .byte $28 ; $58 - Char T
                            .byte $aa ; $59 - Char U
                            .byte $20 ; $5a - Char V
                            .byte $82 ; $5b - Char W
                            .byte $82 ; $5c - Char X
                            .byte $28 ; $5d - Char Y
                            .byte $aa ; $5e - Char Z
                            .byte $80 ; $5f - Special Char  >
                            .byte $28 ; $60 - Special Char  .
                            .byte $28 ; $61 - Special Char  (
                            .byte $28 ; $62 - Special Char  )
                            .byte $80 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $02 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
TabImageDataOff_R_0a_B_02   = *       ; offset to image data row_0a byte 2-3
                            .byte $00 ; $00 - Level Tile Blank
                            .byte $00 ; $01 - Level Tile Wall Weak
                            .byte $00 ; $02 - Level Tile Wall Hard
                            .byte $00 ; $03 - Level Tile Ladder
                            .byte $00 ; $04 - Level Tile Pole
                            .byte $00 ; $05 - Level Tile Wall Trap
                            .byte $00 ; $06 - Level Tile Ladder Secret
                            .byte $00 ; $07 - Level Tile Gold
                            .byte $00 ; $08 - Level Tile Enemy
                            .byte $00 ; $09 - Level Tile Loderunner
                            .byte $c0 ; $0a - Blank Reverse
                            .byte $00 ; $0b - Loderunner Run Le 00
                            .byte $00 ; $0c - Loderunner Run Le 01
                            .byte $00 ; $0d - Loderunner Run Le 02
                            .byte $00 ; $0e - Loderunner Ladder 00
                            .byte $80 ; $0f - Loderunner Fire Le
                                      ; $09 - Loderunner Run Ri 00 = Level Tile Loderunner
                            .byte $00 ; $10 - Loderunner Run Ri 00
                            .byte $00 ; $11 - Loderunner Run Ri 01
                            .byte $00 ; $12 - Loderunner Run Ri 02
                            .byte $00 ; $13 - Loderunner Fall Le
                            .byte $00 ; $14 - Loderunner Fall Ri
                            .byte $00 ; $15 - Loderunner Pole Ri 00
                            .byte $00 ; $16 - Loderunner Pole Ri 01
                            .byte $00 ; $17 - Loderunner Pole Ri 02
                            .byte $40 ; $18 - Loderunner Pole Le 00
                            .byte $80 ; $19 - Loderunner Pole Le 01
                            .byte $00 ; $1a - Loderunner Pole Le 02
                            .byte $00 ; $1b - Shoot Spark 00
                            .byte $00 ; $1c - Shoot Spark 01
                            .byte $00 ; $1d - Shoot Spark 02
                            .byte $00 ; $1e - Shoot Spark 03
                            .byte $00 ; $1f - Shoot Melt Ground 00
                            .byte $00 ; $20 - Shoot Melt Ground 01
                            .byte $00 ; $21 - Shoot Melt Ground 02
                            .byte $00 ; $22 - Shoot Melt Ground 03
                            .byte $00 ; $23 - Shoot Melt Ground 04
                            .byte $00 ; $24 - Shoot Melt Ground 05
                            .byte $00 ; $25 - Fire Ri
                            .byte $00 ; $26 - Shoot Melt 00
                            .byte $00 ; $27 - Shoot Melt 01
                            .byte $00 ; $28 - Enemy Run Ri 00
                            .byte $00 ; $29 - Enemy Run Ri 01
                            .byte $00 ; $2a - Enemy Run Ri 02
                                      ; $08 - Enemy Run Le 00 = Level Tile Enemy
                            .byte $00 ; $2b - Enemy Run Le 01
                            .byte $80 ; $2c - Enemy Run Le 02
                            .byte $00 ; $2d - Enemy Pole Ri 00
                            .byte $00 ; $2e - Enemy Pole Ri 01
                            .byte $00 ; $2f - Enemy Pole Ri 02
                            .byte $80 ; $30 - Enemy Pole Le 00
                            .byte $00 ; $31 - Enemy Pole Le 01
                            .byte $00 ; $32 - Enemy Pole Le 02
                            .byte $00 ; $33 - Enemy Ladder  00
                            .byte $00 ; $34 - Enemy Ladder  01
                            .byte $00 ; $35 - Enemy Fall Ri
                            .byte $00 ; $36 - Enemy Fall Le
                            .byte $00 ; $37 - Close Hole 00
                            .byte $00 ; $38 - Close Hole 01
                            .byte $00 ; $39 - Enemy Rebirth 00
                            .byte $00 ; $3a - Enemy Rebirth 01
                            .byte $00 ; $3b - Digit 0
                            .byte $00 ; $3c - Digit 1
                            .byte $00 ; $3d - Digit 2
                            .byte $00 ; $3e - Digit 3
                            .byte $00 ; $3f - Digit 4
                            .byte $00 ; $40 - Digit 5
                            .byte $00 ; $41 - Digit 6
                            .byte $00 ; $42 - Digit 7
                            .byte $00 ; $43 - Digit 8
                            .byte $00 ; $44 - Digit 9
                            .byte $00 ; $45 - Char A
                            .byte $00 ; $46 - Char B
                            .byte $00 ; $47 - Char C
                            .byte $00 ; $48 - Char D
                            .byte $00 ; $49 - Char E
                            .byte $00 ; $4a - Char F
                            .byte $00 ; $4b - Char G
                            .byte $00 ; $4c - Char H
                            .byte $00 ; $4d - Char I
                            .byte $00 ; $4e - Char J
                            .byte $00 ; $4f - Char K
                            .byte $00 ; $50 - Char L
                            .byte $00 ; $51 - Char M
                            .byte $00 ; $52 - Char N
                            .byte $00 ; $53 - Char O
                            .byte $00 ; $54 - Char P
                            .byte $00 ; $55 - Char Q
                            .byte $00 ; $56 - Char R
                            .byte $00 ; $57 - Char S
                            .byte $00 ; $58 - Char T
                            .byte $00 ; $59 - Char U
                            .byte $00 ; $5a - Char V
                            .byte $00 ; $5b - Char W
                            .byte $00 ; $5c - Char X
                            .byte $00 ; $5d - Char Y
                            .byte $00 ; $5e - Char Z
                            .byte $00 ; $5f - Special Char  >
                            .byte $00 ; $60 - Special Char  .
                            .byte $00 ; $61 - Special Char  (
                            .byte $00 ; $62 - Special Char  )
                            .byte $00 ; $63 - Special Char  /
                            .byte $00 ; $64 - Special Char  -
                            .byte $00 ; $65 - Special Char  <
                            .byte $00 ; $66 - Blank
                            .byte $00 ; $67 - Blank
; --------------------------------------------------------------------------------------------------------------------- ;
A_b0f0                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; demo moves table entry layout
; --------------------------------------------------------------------------------------------------------------------- ;
; byte 1 - move direction
;          left  nibble le/ri - offset to TabDemoJoystickMove - 1=le 3=ri 4=fire-ri 5=fire-le 6=none
;          right nibble up/do - offset to TabDemoJoystickMove - 0=up 2=do
; byte 2 - move duration
; --------------------------------------------------------------------------------------------------------------------- ;
; demo moves data level 1
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoMoves                = *       ; 
TabDemoMovesLevel_01        = *       ; 
                            .byte $16 ; left-- ------
                            .byte $4c ; 
TabDemoMoveEntry_Len        = * - TabDemoMoves ; length of each move entry                
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $18 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $14 ; 
                            .byte $36 ; right- ------
                            .byte $0d ; 
                            .byte $30 ; right- up----
                            .byte $17 ; 
                            .byte $60 ; ------ up----
                            .byte $08 ; 
                            .byte $66 ; ------ ------
                            .byte $03 ; 
                            .byte $16 ; left-- ------
                            .byte $16 ; 
                            .byte $66 ; ------ ------
                            .byte $04 ; 
                            .byte $36 ; right- ------
                            .byte $23 ; 
                            .byte $32 ; right- down--
                            .byte $01 ; 
                            .byte $62 ; ------ down--
                            .byte $01 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $20 ; 
                            .byte $16 ; left-- ------
                            .byte $07 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $25 ; 
                            .byte $30 ; right- up----
                            .byte $14 ; 
                            .byte $60 ; ------ up----
                            .byte $0e ; 
                            .byte $10 ; left-- up----
                            .byte $11 ; 
                            .byte $16 ; left-- ------
                            .byte $25 ; 
                            .byte $10 ; left-- up----
                            .byte $08 ; 
                            .byte $16 ; left-- ------
                            .byte $23 ; 
                            .byte $10 ; left-- up----
                            .byte $06 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $30 ; right- up----
                            .byte $0f ; 
                            .byte $36 ; right- ------
                            .byte $17 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $07 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $1e ; 
                            .byte $16 ; left-- ------
                            .byte $38 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $05 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $07 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $07 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $04 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $0b ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $0e ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $60 ; ------ up----
                            .byte $0c ; 
                            .byte $30 ; right- up----
                            .byte $29 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $2b ; 
                            .byte $10 ; left-- up----
                            .byte $04 ; 
                            .byte $60 ; ------ up----
                            .byte $05 ; 
                            .byte $30 ; right- up----
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $67 ; 
                            .byte $32 ; right- down--
                            .byte $01 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $2b ; 
                            .byte $36 ; right- ------
                            .byte $0c ; 
                            .byte $30 ; right- up----
                            .byte $15 ; 
                            .byte $36 ; right- ------
                            .byte $12 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $05 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $4a ; 
                            .byte $10 ; left-- up----
                            .byte $04 ; 
                            .byte $60 ; ------ up----
                            .byte $07 ; 
                            .byte $30 ; right- up----
                            .byte $09 ; 
                            .byte $36 ; right- ------
                            .byte $15 ; 
                            .byte $66 ; ------ ------
                            .byte $0a ; 
                            .byte $16 ; left-- ------
                            .byte $0d ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $02 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $06 ; 
                            .byte $16 ; left-- ------
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $02 ; 
                            .byte $62 ; ------ down--
                            .byte $15 ; 
                            .byte $36 ; right- ------
                            .byte $31 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $62 ; ------ down--
                            .byte $04 ; 
                            .byte $12 ; left-- down--
                            .byte $06 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $37 ; 
                            .byte $36 ; right- ------
                            .byte $01 ; 
                            .byte $30 ; right- up----
                            .byte $1d ; 
                            .byte $60 ; ------ up----
                            .byte $33 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; demo move data level 2
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoMovesLevel_02        = *       ; 
                            .byte $36 ; right- ------
                            .byte $32 ; 
                            .byte $66 ; ------ ------
                            .byte $03 ;
                            .byte $16 ; left-- ------
                            .byte $01 ; 
                            .byte $10 ; left-- up----
                            .byte $1b ; 
                            .byte $60 ; ------ up----
                            .byte $05 ; 
                            .byte $36 ; right- ------
                            .byte $28 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $1f ; 
                            .byte $36 ; right- ------
                            .byte $14 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $2d ; 
                            .byte $36 ; right- ------
                            .byte $01 ; 
                            .byte $30 ; right- up----
                            .byte $12 ; 
                            .byte $60 ; ------ up----
                            .byte $25 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $0d ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $09 ; 
                            .byte $30 ; right- up----
                            .byte $0a ; 
                            .byte $36 ; right- ------
                            .byte $04 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $16 ; left-- ------
                            .byte $22 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $07 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $04 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $27 ; 
                            .byte $12 ; left-- down--
                            .byte $0e ; 
                            .byte $16 ; left-- ------
                            .byte $1e ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $19 ; 
                            .byte $36 ; right- ------
                            .byte $01 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $60 ; ------ up----
                            .byte $07 ; 
                            .byte $10 ; left-- up----
                            .byte $1f ; 
                            .byte $60 ; ------ up----
                            .byte $07 ; 
                            .byte $30 ; right- up----
                            .byte $09 ; 
                            .byte $36 ; right- ------
                            .byte $33 ; 
                            .byte $66 ; ------ ------
                            .byte $04 ; 
                            .byte $10 ; left-- up----
                            .byte $09 ; 
                            .byte $16 ; left-- ------
                            .byte $08 ; 
                            .byte $12 ; left-- down--
                            .byte $01 ; 
                            .byte $62 ; ------ down--
                            .byte $0c ; 
                            .byte $32 ; right- down--
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $32 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $0b ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $09 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $10 ; left-- up----
                            .byte $2c ; 
                            .byte $60 ; ------ up----
                            .byte $04 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $0a ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $05 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $4c ; 
                            .byte $16 ; left-- ------
                            .byte $09 ; 
                            .byte $10 ; left-- up----
                            .byte $15 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $10 ; left-- up----
                            .byte $2f ; 
                            .byte $16 ; left-- ------
                            .byte $09 ; 
                            .byte $12 ; left-- down--
                            .byte $03 ; 
                            .byte $16 ; left-- ------
                            .byte $12 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $06 ; 
                            .byte $66 ; ------ ------
                            .byte $2d ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $10 ; left-- up----
                            .byte $1c ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $32 ; right- down--
                            .byte $15 ; 
                            .byte $36 ; right- ------
                            .byte $0b ; 
                            .byte $30 ; right- up----
                            .byte $0b ; 
                            .byte $60 ; ------ up----
                            .byte $0c ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $62 ; ------ down--
                            .byte $0d ; 
                            .byte $12 ; left-- down--
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $0d ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $20 ; 
                            .byte $36 ; right- ------
                            .byte $04 ; 
                            .byte $30 ; right- up----
                            .byte $17 ; 
                            .byte $36 ; right- ------
                            .byte $1e ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $2f ; 
                            .byte $30 ; right- up----
                            .byte $08 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $10 ; left-- up----
                            .byte $22 ; 
                            .byte $16 ; left-- ------
                            .byte $1b ; 
                            .byte $66 ; ------ ------
                            .byte $26 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $07 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $1d ; 
                            .byte $16 ; left-- ------
                            .byte $02 ; 
                            .byte $10 ; left-- up----
                            .byte $85 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $32 ; right- down--
                            .byte $0f ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $30 ; right- up----
                            .byte $0c ; 
; --------------------------------------------------------------------------------------------------------------------- ;
; demo move data level 3
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoMovesLevel_03        = *       ; 
                            .byte $36 ; right- ------
                            .byte $20 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $0a ; 
                            .byte $60 ; ------ up----
                            .byte $06 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
                            .byte $30 ; right- up----
                            .byte $05 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $66 ; ------ ------
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $08 ; 
                            .byte $10 ; left-- up----
                            .byte $01 ; 
                            .byte $60 ; ------ up----
                            .byte $06 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
                            .byte $30 ; right- up----
                            .byte $04 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $08 ; 
                            .byte $10 ; left-- up----
                            .byte $02 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $30 ; right- up----
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $16 ; left-- ------
                            .byte $09 ; 
                            .byte $10 ; left-- up----
                            .byte $02 ; 
                            .byte $60 ; ------ up----
                            .byte $03 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $07 ; 
                            .byte $30 ; right- up----
                            .byte $03 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $10 ; left-- up----
                            .byte $02 ; 
                            .byte $16 ; left-- ------
                            .byte $08 ; 
                            .byte $10 ; left-- up----
                            .byte $01 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $30 ; right- up----
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $0a ; 
                            .byte $30 ; right- up----
                            .byte $02 ; 
                            .byte $60 ; ------ up----
                            .byte $02 ; 
                            .byte $10 ; left-- up----
                            .byte $03 ; 
                            .byte $16 ; left-- ------
                            .byte $04 ; 
                            .byte $10 ; left-- up----
                            .byte $03 ; 
                            .byte $60 ; ------ up----
                            .byte $05 ; 
                            .byte $30 ; right- up----
                            .byte $02 ; 
                            .byte $36 ; right- ------
                            .byte $07 ; 
                            .byte $66 ; ------ ------
                            .byte $16 ; 
                            .byte $36 ; right- ------
                            .byte $02 ; 
                            .byte $66 ; ------ ------
                            .byte $33 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $05 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $04 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $a9 ; 
                            .byte $62 ; ------ down--
                            .byte $0c ; 
                            .byte $66 ; ------ ------
                            .byte $07 ; 
                            .byte $60 ; ------ up----
                            .byte $0f ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $18 ; 
                            .byte $16 ; left-- ------
                            .byte $2a ; 
                            .byte $55 ; fi_le- fi_le-
                            .byte $01 ; 
                            .byte $16 ; left-- ------
                            .byte $03 ; 
                            .byte $66 ; ------ ------
                            .byte $01 ; 
                            .byte $60 ; ------ up----
                            .byte $07 ; 
                            .byte $66 ; ------ ------
                            .byte $03 ; 
                            .byte $36 ; right- ------
                            .byte $03 ; 
                            .byte $30 ; right- up----
                            .byte $1b ; 
                            .byte $36 ; right- ------
                            .byte $08 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $18 ; 
                            .byte $36 ; right- ------
                            .byte $0f ; 
                            .byte $66 ; ------ ------
                            .byte $08 ; 
                            .byte $44 ; fi_ri- fi_ri-
                            .byte $01 ; 
                            .byte $66 ; ------ ------
                            .byte $38 ; 
                            .byte $30 ; right- up----
                            .byte $0e ; 
                            .byte $66 ; ------ ------
                            .byte $11 ; 
                            .byte $60 ; ------ up----
                            .byte $04 ; 
                            .byte $66 ; ------ ------
                            .byte $49 ; 
                            .byte $37 ; right- ......
                            .byte $03 ; 
; --------------------------------------------------------------------------------------------------------------------- ;
A_b36a                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $30 ; 
A_b370                      .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $33 ; 
                            .byte $07 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $30 ; 
                            .byte $03 ; 
                            .byte $00 ; 
A_b380                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $37 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $30 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_b390                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $33 ; 
                            .byte $07 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $30 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_b3a0                      .byte $37 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $30 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $33 ; 
                            .byte $07 ; 
A_b3b0                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $30 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $37 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_b3c0                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $30 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $09 ; 
                            .byte $00 ; 
                            .byte $33 ; 
                            .byte $07 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_b3d0                      .byte $00 ; 
                            .byte $30 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $30 ; 
                            .byte $11 ; 
                            .byte $11 ; 
                            .byte $11 ; 
                            .byte $11 ; 
                            .byte $11 ; 
                            .byte $11 ; 
                            .byte $11 ; 
                            .byte $11 ; 
                            .byte $03 ; 
                            .byte $00 ; 
                            .byte $30 ; 
A_b3e0                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_b3f0                      .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
                            .byte $00 ; 
A_b400                      .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $b1 ; 
                            .byte $c3 ; 
                            .byte $b3 ; 
                            .byte $b5 ; 
                            .byte $8d ; 
                            .byte $f9 ; 
                            .byte $f4 ; 
                            .byte $e1 ; 
                            .byte $e2 ; 
                            .byte $ec ; 
                            .byte $e5 ; 
                            .byte $a0 ; 
A_b410                      .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $b1 ; 
                            .byte $c3 ; 
                            .byte $b5 ; 
                            .byte $b1 ; 
                            .byte $8d ; 
                            .byte $e2 ; 
                            .byte $f9 ; 
                            .byte $f4 ; 
                            .byte $e1 ; 
                            .byte $e2 ; 
                            .byte $ec ; 
A_b420                      .byte $e5 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $b1 ; 
                            .byte $c3 ; 
                            .byte $b6 ; 
                            .byte $b2 ; 
                            .byte $8d ; 
                            .byte $e2 ; 
                            .byte $e9 ; 
                            .byte $f4 ; 
                            .byte $e1 ; 
A_b430                      .byte $e2 ; 
                            .byte $ec ; 
                            .byte $e5 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $b1 ; 
                            .byte $c3 ; 
                            .byte $b7 ; 
                            .byte $c5 ; 
                            .byte $8d ; 
                            .byte $f8 ; 
                            .byte $e2 ; 
A_b440                      .byte $f9 ; 
                            .byte $f4 ; 
                            .byte $e1 ; 
                            .byte $e2 ; 
                            .byte $ec ; 
                            .byte $e5 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $b1 ; 
                            .byte $c3 ; 
                            .byte $b9 ; 
                            .byte $c1 ; 
A_b450                      .byte $8d ; 
                            .byte $f8 ; 
                            .byte $e2 ; 
                            .byte $e9 ; 
                            .byte $f4 ; 
                            .byte $e1 ; 
                            .byte $e2 ; 
                            .byte $ec ; 
                            .byte $e5 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $b1 ; 
A_b460                      .byte $c4 ; 
                            .byte $b2 ; 
                            .byte $b6 ; 
                            .byte $8d ; 
                            .byte $e2 ; 
                            .byte $ef ; 
                            .byte $ef ; 
                            .byte $f4 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $b1 ; 
                            .byte $c4 ; 
A_b470                      .byte $c2 ; 
                            .byte $b2 ; 
                            .byte $8d ; 
                            .byte $f3 ; 
                            .byte $e3 ; 
                            .byte $ef ; 
                            .byte $f2 ; 
                            .byte $e5 ; 
                            .byte $e2 ; 
                            .byte $f5 ; 
                            .byte $e6 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
A_b480                      .byte $a4 ; 
                            .byte $b1 ; 
                            .byte $c6 ; 
                            .byte $b0 ; 
                            .byte $b0 ; 
                            .byte $8d ; 
                            .byte $e3 ; 
                            .byte $e8 ; 
                            .byte $e1 ; 
                            .byte $f2 ; 
                            .byte $e4 ; 
                            .byte $e1 ; 
                            .byte $f4 ; 
                            .byte $e1 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
A_b490                      .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $c1 ; 
                            .byte $c4 ; 
                            .byte $b0 ; 
                            .byte $b0 ; 
                            .byte $8d ; 
                            .byte $8d ; 
                            .byte $f2 ; 
                            .byte $f7 ; 
                            .byte $f4 ; 
                            .byte $f3 ; 
                            .byte $f0 ; 
                            .byte $e1 ; 
A_b4a0                      .byte $f2 ; 
                            .byte $ed ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $c2 ; 
                            .byte $b7 ; 
                            .byte $c5 ; 
                            .byte $b8 ; 
                            .byte $8d ; 
                            .byte $f2 ; 
                            .byte $f7 ; 
                            .byte $f4 ; 
A_b4b0                      .byte $f3 ; 
                            .byte $f6 ; 
                            .byte $ef ; 
                            .byte $ec ; 
                            .byte $ed ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $c2 ; 
                            .byte $b7 ; 
                            .byte $c5 ; 
                            .byte $c2 ; 
                            .byte $8d ; 
A_b4c0                      .byte $f2 ; 
                            .byte $f7 ; 
                            .byte $f4 ; 
                            .byte $f3 ; 
                            .byte $f4 ; 
                            .byte $f2 ; 
                            .byte $e3 ; 
                            .byte $eb ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $c2 ; 
                            .byte $b7 ; 
A_b4d0                      .byte $c5 ; 
                            .byte $c3 ; 
                            .byte $8d ; 
                            .byte $f2 ; 
                            .byte $f7 ; 
                            .byte $f4 ; 
                            .byte $f3 ; 
                            .byte $f3 ; 
                            .byte $e5 ; 
                            .byte $e3 ; 
                            .byte $f4 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
                            .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
A_b4e0                      .byte $a4 ; 
                            .byte $c2 ; 
                            .byte $b7 ; 
                            .byte $c5 ; 
                            .byte $c4 ; 
                            .byte $8d ; 
                            .byte $f2 ; 
                            .byte $f7 ; 
                            .byte $f4 ; 
                            .byte $f3 ; 
                            .byte $e2 ; 
                            .byte $f5 ; 
                            .byte $e6 ; 
                            .byte $e6 ; 
                            .byte $a0 ; 
                            .byte $c5 ; 
A_b4f0                      .byte $d1 ; 
                            .byte $d5 ; 
                            .byte $a0 ; 
                            .byte $a4 ; 
                            .byte $c2 ; 
                            .byte $b7 ; 
                            .byte $c6 ; 
                            .byte $b0 ; 
                            .byte $8d ; 
                            .byte $f2 ; 
                            .byte $f7 ; 
                            .byte $f4 ; 
                            .byte $f3 ; 
                            .byte $e3 ; 
                            .byte $ed ; 
                            .byte $ee ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoDataLevel             = *      ; demo level data
TabDemoDataLevel_01          = *; $00  $02  $04  $06  $08  $0a  $0c  $0e  $10  $12  $14  $16  $18  $1c ; 
                            .byte $06, $00, $00, $07, $00, $00, $07, $00, $00, $06, $00, $00, $03, $06 ; $00
                            .byte $13, $11, $11, $11, $11, $11, $11, $11, $11, $03, $00, $00, $03, $06 ; $01
                            .byte $03, $00, $00, $00, $00, $00, $00, $07, $00, $43, $44, $44, $03, $76 ; $02
                            .byte $11, $11, $11, $11, $31, $11, $11, $11, $11, $01, $00, $00, $13, $11 ; $03
                            .byte $11, $11, $11, $11, $33, $00, $00, $00, $00, $00, $00, $00, $03, $00 ; $04
                            .byte $11, $11, $11, $31, $43, $44, $44, $44, $03, $00, $00, $00, $03, $00 ; $05
                            .byte $71, $70, $11, $33, $00, $00, $00, $08, $03, $70, $00, $08, $03, $70 ; $06
                            .byte $11, $11, $31, $03, $00, $00, $13, $11, $21, $22, $11, $11, $13, $11 ; $07
                            .byte $00, $00, $30, $00, $00, $00, $03, $00, $00, $00, $00, $00, $03, $00 ; $08
                            .byte $00, $00, $30, $00, $00, $00, $03, $00, $00, $00, $00, $00, $03, $00 ; $09
                            .byte $00, $00, $38, $00, $70, $00, $43, $44, $44, $44, $44, $44, $03, $70 ; $0a
                            .byte $13, $11, $11, $11, $11, $11, $03, $70, $00, $00, $70, $00, $13, $11 ; $0b
                            .byte $03, $00, $00, $00, $00, $00, $03, $11, $11, $11, $11, $01, $03, $00 ; $0c
                            .byte $03, $00, $00, $00, $00, $00, $03, $00, $00, $00, $00, $00, $03, $00 ; $0d
                            .byte $03, $00, $00, $70, $00, $00, $03, $00, $90, $70, $00, $00, $03, $00 ; $0e
                            .byte $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $11, $11 ; $0f
                            
                            .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
                            .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
                            .byte $00, $00, $00, $00                                                   ; 
TabDemoDataLevel_Len        = * - TabDemoDataLevel                                                     ;
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoDataLevel_02          = *; $00  $02  $04  $06  $08  $0a  $0c  $0e  $10  $12  $14  $16  $18  $1c ; 
                            .byte $11, $11, $61, $11, $11, $11, $11, $11, $11, $11, $11, $01, $11, $11 ; $00
                            .byte $06, $00, $61, $01, $44, $44, $44, $04, $00, $00, $00, $00, $00, $10 ; $01
                            .byte $16, $61, $60, $01, $71, $00, $10, $13, $00, $00, $00, $00, $80, $10 ; $02
                            .byte $06, $11, $11, $01, $11, $11, $11, $13, $11, $11, $07, $31, $11, $11 ; $03
                            .byte $61, $00, $00, $47, $44, $11, $11, $13, $11, $11, $11, $31, $01, $11 ; $04
                            .byte $11, $11, $11, $01, $00, $01, $10, $13, $11, $10, $11, $31, $01, $11 ; $05
                            .byte $00, $00, $00, $80, $00, $00, $10, $13, $11, $10, $01, $31, $71, $10 ; $06
                            .byte $13, $11, $11, $11, $13, $73, $10, $13, $11, $10, $01, $31, $11, $11 ; $07
                            .byte $03, $00, $00, $00, $13, $11, $11, $13, $11, $07, $01, $31, $11, $10 ; $08
                            .byte $03, $00, $00, $00, $00, $11, $11, $13, $11, $11, $01, $31, $11, $17 ; $09
                            .byte $03, $00, $00, $00, $01, $00, $00, $03, $00, $00, $00, $30, $00, $10 ; $0a
                            .byte $13, $11, $13, $11, $31, $21, $21, $21, $21, $21, $21, $31, $21, $21 ; $0b
                            .byte $13, $11, $13, $11, $31, $11, $11, $11, $00, $11, $11, $31, $21, $21 ; $0c
                            .byte $03, $00, $03, $00, $30, $11, $11, $11, $01, $10, $11, $31, $00, $00 ; $0d
                            .byte $13, $11, $11, $11, $31, $11, $11, $11, $11, $07, $11, $11, $11, $31 ; $0e
                            .byte $93, $00, $00, $00, $30, $70, $10, $11, $11, $01, $80, $00, $00, $30 ; $0f
                            
                            .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
                            .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
                            .byte $00, $00, $00, $00                                                   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
TabDemoDataLevel_03          = *; $00  $02  $04  $06  $08  $0a  $0c  $0e  $10  $12  $14  $16  $18  $1c ; 
                            .byte $00, $00, $00, $30, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; $00
                            .byte $80, $07, $00, $30, $00, $00, $00, $00, $00, $00, $00, $00, $70, $08 ; $01
                            .byte $13, $81, $07, $30, $00, $00, $00, $00, $00, $00, $00, $70, $18, $31 ; $02
                            .byte $03, $10, $01, $30, $11, $11, $36, $11, $11, $31, $00, $10, $01, $30 ; $03
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $30, $00, $00, $00, $30 ; $04
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $30, $00, $00, $00, $30 ; $05
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; $06
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $00, $00, $00, $00, $30 ; $07
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; $08
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $00, $00, $00, $00, $30 ; $09
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; $0a
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $00, $00, $00, $00, $30 ; $0b
                            .byte $03, $00, $00, $00, $00, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; $0c
                            .byte $03, $00, $00, $00, $00, $00, $37, $03, $00, $00, $00, $00, $00, $30 ; $0d
                            .byte $03, $00, $00, $00, $09, $00, $33, $07, $00, $00, $00, $00, $00, $30 ; $0e
                            .byte $03, $00, $30, $11, $11, $11, $11, $11, $11, $11, $11, $03, $00, $30 ; $0f
                            
                            .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
                            .byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00 ; 
                            .byte $00, $00, $00, $00                                                   ; 
; --------------------------------------------------------------------------------------------------------------------- ;
